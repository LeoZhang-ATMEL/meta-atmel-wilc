From c3e4536593846569acb4cac21405acfa2def9f15 Mon Sep 17 00:00:00 2001
From: Leo Zhang <liang.zhang@microchip.com>
Date: Sun, 16 Dec 2018 14:10:06 +0000
Subject: [PATCH 1/2] Update WILC driver to wilc_linux_15_2_RC1

---
 drivers/staging/Kconfig                            |    2 +-
 drivers/staging/Makefile                           |    2 +-
 drivers/staging/{wilc1000 => wilc}/Kconfig         |   46 +-
 drivers/staging/wilc/Makefile                      |   16 +
 .../staging/{wilc1000 => wilc}/coreconfigurator.c  |  729 ++-
 .../staging/{wilc1000 => wilc}/coreconfigurator.h  |   60 +-
 drivers/staging/wilc/host_interface.c              | 4675 ++++++++++++++++++++
 .../staging/{wilc1000 => wilc}/host_interface.h    |   50 +-
 drivers/staging/{wilc1000 => wilc}/linux_mon.c     |  133 +-
 drivers/staging/wilc/linux_wlan.c                  | 1833 ++++++++
 drivers/staging/wilc/linux_wlan.h                  |   71 +
 drivers/staging/wilc/sysfs.c                       |  111 +
 drivers/staging/wilc/wilc_bt.c                     |  658 +++
 drivers/staging/{wilc1000 => wilc}/wilc_debugfs.c  |   54 +-
 drivers/staging/wilc/wilc_debugfs.h                |   54 +
 drivers/staging/{wilc1000 => wilc}/wilc_sdio.c     |  501 ++-
 drivers/staging/{wilc1000 => wilc}/wilc_spi.c      |  929 ++--
 drivers/staging/wilc/wilc_wfi_cfgoperations.c      | 3046 +++++++++++++
 .../{wilc1000 => wilc}/wilc_wfi_cfgoperations.h    |   11 +-
 .../{wilc1000 => wilc}/wilc_wfi_netdevice.h        |  120 +-
 drivers/staging/wilc/wilc_wlan.c                   | 2077 +++++++++
 drivers/staging/{wilc1000 => wilc}/wilc_wlan.h     |  138 +-
 drivers/staging/{wilc1000 => wilc}/wilc_wlan_cfg.c |  134 +-
 drivers/staging/{wilc1000 => wilc}/wilc_wlan_cfg.h |   11 +-
 drivers/staging/{wilc1000 => wilc}/wilc_wlan_if.h  |  152 +-
 drivers/staging/wilc1000/Makefile                  |   18 -
 drivers/staging/wilc1000/TODO                      |   18 -
 drivers/staging/wilc1000/host_interface.c          | 4092 -----------------
 drivers/staging/wilc1000/linux_wlan.c              | 1280 ------
 drivers/staging/wilc1000/wilc_wfi_cfgoperations.c  | 2343 ----------
 drivers/staging/wilc1000/wilc_wlan.c               | 1439 ------
 31 files changed, 14280 insertions(+), 10523 deletions(-)
 rename drivers/staging/{wilc1000 => wilc}/Kconfig (52%)
 create mode 100644 drivers/staging/wilc/Makefile
 rename drivers/staging/{wilc1000 => wilc}/coreconfigurator.c (67%)
 rename drivers/staging/{wilc1000 => wilc}/coreconfigurator.h (71%)
 create mode 100644 drivers/staging/wilc/host_interface.c
 rename drivers/staging/{wilc1000 => wilc}/host_interface.h (88%)
 rename drivers/staging/{wilc1000 => wilc}/linux_mon.c (71%)
 create mode 100644 drivers/staging/wilc/linux_wlan.c
 create mode 100755 drivers/staging/wilc/linux_wlan.h
 create mode 100644 drivers/staging/wilc/sysfs.c
 create mode 100644 drivers/staging/wilc/wilc_bt.c
 rename drivers/staging/{wilc1000 => wilc}/wilc_debugfs.c (62%)
 create mode 100755 drivers/staging/wilc/wilc_debugfs.h
 rename drivers/staging/{wilc1000 => wilc}/wilc_sdio.c (72%)
 rename drivers/staging/{wilc1000 => wilc}/wilc_spi.c (58%)
 create mode 100644 drivers/staging/wilc/wilc_wfi_cfgoperations.c
 rename drivers/staging/{wilc1000 => wilc}/wilc_wfi_cfgoperations.h (69%)
 rename drivers/staging/{wilc1000 => wilc}/wilc_wfi_netdevice.h (69%)
 create mode 100644 drivers/staging/wilc/wilc_wlan.c
 rename drivers/staging/{wilc1000 => wilc}/wilc_wlan.h (71%)
 rename drivers/staging/{wilc1000 => wilc}/wilc_wlan_cfg.c (76%)
 rename drivers/staging/{wilc1000 => wilc}/wilc_wlan_cfg.h (75%)
 rename drivers/staging/{wilc1000 => wilc}/wilc_wlan_if.h (94%)
 delete mode 100644 drivers/staging/wilc1000/Makefile
 delete mode 100644 drivers/staging/wilc1000/TODO
 delete mode 100644 drivers/staging/wilc1000/host_interface.c
 delete mode 100644 drivers/staging/wilc1000/linux_wlan.c
 delete mode 100644 drivers/staging/wilc1000/wilc_wfi_cfgoperations.c
 delete mode 100644 drivers/staging/wilc1000/wilc_wlan.c

diff --git a/drivers/staging/Kconfig b/drivers/staging/Kconfig
index 5546839..329a59b 100644
--- a/drivers/staging/Kconfig
+++ b/drivers/staging/Kconfig
@@ -100,7 +100,7 @@ source "drivers/staging/fsl-mc/Kconfig"
 
 source "drivers/staging/fsl-dpaa2/Kconfig"
 
-source "drivers/staging/wilc1000/Kconfig"
+source "drivers/staging/wilc/Kconfig"
 
 source "drivers/staging/most/Kconfig"
 
diff --git a/drivers/staging/Makefile b/drivers/staging/Makefile
index 6e53602..400c377 100644
--- a/drivers/staging/Makefile
+++ b/drivers/staging/Makefile
@@ -42,7 +42,7 @@ obj-$(CONFIG_COMMON_CLK_XLNX_CLKWZRD)	+= clocking-wizard/
 obj-$(CONFIG_FB_TFT)		+= fbtft/
 obj-$(CONFIG_FSL_MC_BUS)	+= fsl-mc/
 obj-$(CONFIG_FSL_DPAA2)		+= fsl-dpaa2/
-obj-$(CONFIG_WILC1000)		+= wilc1000/
+obj-$(CONFIG_WILC)		+= wilc/
 obj-$(CONFIG_MOST)		+= most/
 obj-$(CONFIG_KS7010)		+= ks7010/
 obj-$(CONFIG_GREYBUS)		+= greybus/
diff --git a/drivers/staging/wilc1000/Kconfig b/drivers/staging/wilc/Kconfig
similarity index 52%
rename from drivers/staging/wilc1000/Kconfig
rename to drivers/staging/wilc/Kconfig
index 73f7fef..0d93f40 100644
--- a/drivers/staging/wilc1000/Kconfig
+++ b/drivers/staging/wilc/Kconfig
@@ -1,42 +1,52 @@
-config WILC1000
+config WILC
 	tristate
+
+config WLAN_VENDOR_MCHP
+        bool "Microhip devices"
+        default y
 	---help---
-	  This module only support IEEE 802.11n WiFi.
+	This adds support for WILC1000 & WILC3000 chips which support
+	IEEE 802.11n WiFi. WILC3000 is a WiFi-BT combo chip.
+
+if WLAN_VENDOR_MCHP
 
-config WILC1000_SDIO
-	tristate "Atmel WILC1000 SDIO (WiFi only)"
+config WILC_SDIO
+	tristate "WILC SDIO"
 	depends on CFG80211 && INET && MMC
-	select WILC1000
+	select WILC
 	---help---
 	  This module adds support for the SDIO interface of adapters using
-	  WILC1000 chipset. The Atmel WILC1000 SDIO is a full speed interface.
+	  WILC1000 & WILC3000 chipset. The Atmel WILC1000 SDIO is a full speed interface.
 	  It meets SDIO card specification version 2.0. The interface supports
 	  the 1-bit/4-bit SD transfer mode at the clock range of 0-50 MHz.
 	  The host can use this interface to read and write from any register
 	  within the chip as well as configure the WILC1000 for data DMA.
 	  To use this interface, pin9 (SDIO_SPI_CFG) must be grounded. Select
 	  this if your platform is using the SDIO bus.
+	  WILC3000 additionally supports BT 4.0 and BLE modes.
 
-config WILC1000_SPI
-	tristate "Atmel WILC1000 SPI (WiFi only)"
+config WILC_SPI
+	tristate "WILC SPI"
 	depends on CFG80211 && INET && SPI
-	select WILC1000
+	select WILC
 	---help---
 	  This module adds support for the SPI interface of adapters using
-	  WILC1000 chipset. The Atmel WILC1000 has a Serial Peripheral
+	  WILC1000 & WILC3000 chipset. The Atmel WILC1000 has a Serial Peripheral
 	  Interface (SPI) that operates as a SPI slave. This SPI interface can
 	  be used for control and for serial I/O of 802.11 data. The SPI is a
 	  full-duplex slave synchronous serial interface that is available
 	  immediately following reset when pin 9 (SDIO_SPI_CFG) is tied to
 	  VDDIO. Select this if your platform is using the SPI bus.
+	  WILC3000 additionally supports BT 4.0 and BLE modes.
 
-config WILC1000_HW_OOB_INTR
-	bool "WILC1000 out of band interrupt"
-	depends on WILC1000_SDIO
+config WILC_HW_OOB_INTR
+	bool "WILC out of band interrupt"
+	depends on WILC_SDIO
 	default n
 	---help---
-	  This option enables out-of-band interrupt support for the WILC1000
-	  chipset. This OOB interrupt is intended to provide a faster interrupt
-	  mechanism for SDIO host controllers that don't support SDIO interrupt.
-	  Select this option If the SDIO host controller in your platform
-	  doesn't support SDIO time devision interrupt.
+	  This option enables out-of-band interrupt support for the WILC1000 &
+	  WILC3000 chipset. This OOB interrupt is intended to provide a faster
+	  interrupt mechanism for SDIO host controllers that don't support SDIO
+	  interrupt. Select this option If the SDIO host controller in your
+	  platform doesn't support SDIO time devision interrupt.
+endif
diff --git a/drivers/staging/wilc/Makefile b/drivers/staging/wilc/Makefile
new file mode 100644
index 0000000..8f4135b
--- /dev/null
+++ b/drivers/staging/wilc/Makefile
@@ -0,0 +1,16 @@
+# SPDX-License-Identifier: GPL-2.0
+ccflags-y += -I$(src)/ -DWILC_ASIC_A0 -DWILC_DEBUGFS
+ccflags-y += -DDISABLE_PWRSAVE_AND_SCAN_DURING_IP
+
+wilc-objs := wilc_wfi_cfgoperations.o linux_wlan.o linux_mon.o \
+			coreconfigurator.o host_interface.o \
+			wilc_wlan_cfg.o wilc_debugfs.o \
+			wilc_wlan.o sysfs.o wilc_bt.o
+
+obj-$(CONFIG_WILC_SDIO) += wilc-sdio.o
+wilc-sdio-objs += $(wilc-objs)
+wilc-sdio-objs += wilc_sdio.o
+
+obj-$(CONFIG_WILC_SPI) += wilc-spi.o
+wilc-spi-objs += $(wilc-objs)
+wilc-spi-objs += wilc_spi.o 
diff --git a/drivers/staging/wilc1000/coreconfigurator.c b/drivers/staging/wilc/coreconfigurator.c
similarity index 67%
rename from drivers/staging/wilc1000/coreconfigurator.c
rename to drivers/staging/wilc/coreconfigurator.c
index 8cf886d..0a09e1d 100644
--- a/drivers/staging/wilc1000/coreconfigurator.c
+++ b/drivers/staging/wilc/coreconfigurator.c
@@ -1,388 +1,341 @@
-// SPDX-License-Identifier: GPL-2.0
-#include "coreconfigurator.h"
-#include "wilc_wlan_if.h"
-#include "wilc_wlan.h"
-#include <linux/errno.h>
-#include <linux/slab.h>
-#define TAG_PARAM_OFFSET	(MAC_HDR_LEN + TIME_STAMP_LEN + \
-				 BEACON_INTERVAL_LEN + CAP_INFO_LEN)
-
-enum basic_frame_type {
-	FRAME_TYPE_CONTROL     = 0x04,
-	FRAME_TYPE_DATA        = 0x08,
-	FRAME_TYPE_MANAGEMENT  = 0x00,
-	FRAME_TYPE_RESERVED    = 0x0C,
-	FRAME_TYPE_FORCE_32BIT = 0xFFFFFFFF
-};
-
-enum sub_frame_type {
-	ASSOC_REQ             = 0x00,
-	ASSOC_RSP             = 0x10,
-	REASSOC_REQ           = 0x20,
-	REASSOC_RSP           = 0x30,
-	PROBE_REQ             = 0x40,
-	PROBE_RSP             = 0x50,
-	BEACON                = 0x80,
-	ATIM                  = 0x90,
-	DISASOC               = 0xA0,
-	AUTH                  = 0xB0,
-	DEAUTH                = 0xC0,
-	ACTION                = 0xD0,
-	PS_POLL               = 0xA4,
-	RTS                   = 0xB4,
-	CTS                   = 0xC4,
-	ACK                   = 0xD4,
-	CFEND                 = 0xE4,
-	CFEND_ACK             = 0xF4,
-	DATA                  = 0x08,
-	DATA_ACK              = 0x18,
-	DATA_POLL             = 0x28,
-	DATA_POLL_ACK         = 0x38,
-	NULL_FRAME            = 0x48,
-	CFACK                 = 0x58,
-	CFPOLL                = 0x68,
-	CFPOLL_ACK            = 0x78,
-	QOS_DATA              = 0x88,
-	QOS_DATA_ACK          = 0x98,
-	QOS_DATA_POLL         = 0xA8,
-	QOS_DATA_POLL_ACK     = 0xB8,
-	QOS_NULL_FRAME        = 0xC8,
-	QOS_CFPOLL            = 0xE8,
-	QOS_CFPOLL_ACK        = 0xF8,
-	BLOCKACK_REQ          = 0x84,
-	BLOCKACK              = 0x94,
-	FRAME_SUBTYPE_FORCE_32BIT  = 0xFFFFFFFF
-};
-
-enum info_element_id {
-	ISSID               = 0,   /* Service Set Identifier         */
-	ISUPRATES           = 1,   /* Supported Rates                */
-	IFHPARMS            = 2,   /* FH parameter set               */
-	IDSPARMS            = 3,   /* DS parameter set               */
-	ICFPARMS            = 4,   /* CF parameter set               */
-	ITIM                = 5,   /* Traffic Information Map        */
-	IIBPARMS            = 6,   /* IBSS parameter set             */
-	ICOUNTRY            = 7,   /* Country element                */
-	IEDCAPARAMS         = 12,  /* EDCA parameter set             */
-	ITSPEC              = 13,  /* Traffic Specification          */
-	ITCLAS              = 14,  /* Traffic Classification         */
-	ISCHED              = 15,  /* Schedule                       */
-	ICTEXT              = 16,  /* Challenge Text                 */
-	IPOWERCONSTRAINT    = 32,  /* Power Constraint               */
-	IPOWERCAPABILITY    = 33,  /* Power Capability               */
-	ITPCREQUEST         = 34,  /* TPC Request                    */
-	ITPCREPORT          = 35,  /* TPC Report                     */
-	ISUPCHANNEL         = 36,  /* Supported channel list         */
-	ICHSWANNOUNC        = 37,  /* Channel Switch Announcement    */
-	IMEASUREMENTREQUEST = 38,  /* Measurement request            */
-	IMEASUREMENTREPORT  = 39,  /* Measurement report             */
-	IQUIET              = 40,  /* Quiet element Info             */
-	IIBSSDFS            = 41,  /* IBSS DFS                       */
-	IERPINFO            = 42,  /* ERP Information                */
-	ITSDELAY            = 43,  /* TS Delay                       */
-	ITCLASPROCESS       = 44,  /* TCLAS Processing               */
-	IHTCAP              = 45,  /* HT Capabilities                */
-	IQOSCAP             = 46,  /* QoS Capability                 */
-	IRSNELEMENT         = 48,  /* RSN Information Element        */
-	IEXSUPRATES         = 50,  /* Extended Supported Rates       */
-	IEXCHSWANNOUNC      = 60,  /* Extended Ch Switch Announcement*/
-	IHTOPERATION        = 61,  /* HT Information                 */
-	ISECCHOFF           = 62,  /* Secondary Channel Offeset      */
-	I2040COEX           = 72,  /* 20/40 Coexistence IE           */
-	I2040INTOLCHREPORT  = 73,  /* 20/40 Intolerant channel report*/
-	IOBSSSCAN           = 74,  /* OBSS Scan parameters           */
-	IEXTCAP             = 127, /* Extended capability            */
-	IWMM                = 221, /* WMM parameters                 */
-	IWPAELEMENT         = 221, /* WPA Information Element        */
-	INFOELEM_ID_FORCE_32BIT  = 0xFFFFFFFF
-};
-
-static inline u16 get_beacon_period(u8 *data)
-{
-	u16 bcn_per;
-
-	bcn_per  = data[0];
-	bcn_per |= (data[1] << 8);
-
-	return bcn_per;
-}
-
-static inline u32 get_beacon_timestamp_lo(u8 *data)
-{
-	u32 time_stamp = 0;
-	u32 index    = MAC_HDR_LEN;
-
-	time_stamp |= data[index++];
-	time_stamp |= (data[index++] << 8);
-	time_stamp |= (data[index++] << 16);
-	time_stamp |= (data[index]   << 24);
-
-	return time_stamp;
-}
-
-static inline u32 get_beacon_timestamp_hi(u8 *data)
-{
-	u32 time_stamp = 0;
-	u32 index    = (MAC_HDR_LEN + 4);
-
-	time_stamp |= data[index++];
-	time_stamp |= (data[index++] << 8);
-	time_stamp |= (data[index++] << 16);
-	time_stamp |= (data[index]   << 24);
-
-	return time_stamp;
-}
-
-static inline enum sub_frame_type get_sub_type(u8 *header)
-{
-	return ((enum sub_frame_type)(header[0] & 0xFC));
-}
-
-static inline u8 get_to_ds(u8 *header)
-{
-	return (header[1] & 0x01);
-}
-
-static inline u8 get_from_ds(u8 *header)
-{
-	return ((header[1] & 0x02) >> 1);
-}
-
-static inline void get_address1(u8 *pu8msa, u8 *addr)
-{
-	memcpy(addr, pu8msa + 4, 6);
-}
-
-static inline void get_address2(u8 *pu8msa, u8 *addr)
-{
-	memcpy(addr, pu8msa + 10, 6);
-}
-
-static inline void get_address3(u8 *pu8msa, u8 *addr)
-{
-	memcpy(addr, pu8msa + 16, 6);
-}
-
-static inline void get_BSSID(u8 *data, u8 *bssid)
-{
-	if (get_from_ds(data) == 1)
-		get_address2(data, bssid);
-	else if (get_to_ds(data) == 1)
-		get_address1(data, bssid);
-	else
-		get_address3(data, bssid);
-}
-
-static inline void get_ssid(u8 *data, u8 *ssid, u8 *p_ssid_len)
-{
-	u8 len = 0;
-	u8 i   = 0;
-	u8 j   = 0;
-
-	len = data[TAG_PARAM_OFFSET + 1];
-	j   = TAG_PARAM_OFFSET + 2;
-
-	if (len >= MAX_SSID_LEN)
-		len = 0;
-
-	for (i = 0; i < len; i++, j++)
-		ssid[i] = data[j];
-
-	ssid[len] = '\0';
-
-	*p_ssid_len = len;
-}
-
-static inline u16 get_cap_info(u8 *data)
-{
-	u16 cap_info = 0;
-	u16 index    = MAC_HDR_LEN;
-	enum sub_frame_type st;
-
-	st = get_sub_type(data);
-
-	if ((st == BEACON) || (st == PROBE_RSP))
-		index += TIME_STAMP_LEN + BEACON_INTERVAL_LEN;
-
-	cap_info  = data[index];
-	cap_info |= (data[index + 1] << 8);
-
-	return cap_info;
-}
-
-static inline u16 get_assoc_resp_cap_info(u8 *data)
-{
-	u16 cap_info;
-
-	cap_info  = data[0];
-	cap_info |= (data[1] << 8);
-
-	return cap_info;
-}
-
-static inline u16 get_asoc_status(u8 *data)
-{
-	u16 asoc_status;
-
-	asoc_status = data[3];
-	return (asoc_status << 8) | data[2];
-}
-
-static inline u16 get_asoc_id(u8 *data)
-{
-	u16 asoc_id;
-
-	asoc_id  = data[4];
-	asoc_id |= (data[5] << 8);
-
-	return asoc_id;
-}
-
-static u8 *get_tim_elm(u8 *pu8msa, u16 rx_len, u16 tag_param_offset)
-{
-	u16 index;
-
-	index = tag_param_offset;
-
-	while (index < (rx_len - FCS_LEN)) {
-		if (pu8msa[index] == ITIM)
-			return &pu8msa[index];
-		index += (IE_HDR_LEN + pu8msa[index + 1]);
-	}
-
-	return NULL;
-}
-
-static u8 get_current_channel_802_11n(u8 *pu8msa, u16 rx_len)
-{
-	u16 index;
-
-	index = TAG_PARAM_OFFSET;
-	while (index < (rx_len - FCS_LEN)) {
-		if (pu8msa[index] == IDSPARMS)
-			return pu8msa[index + 2];
-		index += pu8msa[index + 1] + IE_HDR_LEN;
-	}
-
-	return 0;
-}
-
-s32 wilc_parse_network_info(u8 *msg_buffer,
-			    struct network_info **ret_network_info)
-{
-	struct network_info *network_info = NULL;
-	u8 msg_type = 0;
-	u8 msg_id = 0;
-	u16 msg_len = 0;
-
-	u16 wid_id = (u16)WID_NIL;
-	u16 wid_len  = 0;
-	u8 *wid_val = NULL;
-
-	msg_type = msg_buffer[0];
-
-	if ('N' != msg_type)
-		return -EFAULT;
-
-	msg_id = msg_buffer[1];
-	msg_len = MAKE_WORD16(msg_buffer[2], msg_buffer[3]);
-	wid_id = MAKE_WORD16(msg_buffer[4], msg_buffer[5]);
-	wid_len = MAKE_WORD16(msg_buffer[6], msg_buffer[7]);
-	wid_val = &msg_buffer[8];
-
-	{
-		u8 *msa = NULL;
-		u16 rx_len = 0;
-		u8 *tim_elm = NULL;
-		u8 *ies = NULL;
-		u16 ies_len = 0;
-		u8 index = 0;
-		u32 tsf_lo;
-		u32 tsf_hi;
-
-		network_info = kzalloc(sizeof(*network_info), GFP_KERNEL);
-		if (!network_info)
-			return -ENOMEM;
-
-		network_info->rssi = wid_val[0];
-
-		msa = &wid_val[1];
-
-		rx_len = wid_len - 1;
-		network_info->cap_info = get_cap_info(msa);
-		network_info->tsf_lo = get_beacon_timestamp_lo(msa);
-
-		tsf_lo = get_beacon_timestamp_lo(msa);
-		tsf_hi = get_beacon_timestamp_hi(msa);
-
-		network_info->tsf_hi = tsf_lo | ((u64)tsf_hi << 32);
-
-		get_ssid(msa, network_info->ssid, &network_info->ssid_len);
-		get_BSSID(msa, network_info->bssid);
-
-		network_info->ch = get_current_channel_802_11n(msa,
-							rx_len + FCS_LEN);
-
-		index = MAC_HDR_LEN + TIME_STAMP_LEN;
-
-		network_info->beacon_period = get_beacon_period(msa + index);
-
-		index += BEACON_INTERVAL_LEN + CAP_INFO_LEN;
-
-		tim_elm = get_tim_elm(msa, rx_len + FCS_LEN, index);
-		if (tim_elm)
-			network_info->dtim_period = tim_elm[3];
-		ies = &msa[TAG_PARAM_OFFSET];
-		ies_len = rx_len - TAG_PARAM_OFFSET;
-
-		if (ies_len > 0) {
-			network_info->ies = kmemdup(ies, ies_len, GFP_KERNEL);
-			if (!network_info->ies) {
-				kfree(network_info);
-				return -ENOMEM;
-			}
-		}
-		network_info->ies_len = ies_len;
-	}
-
-	*ret_network_info = network_info;
-
-	return 0;
-}
-
-s32 wilc_parse_assoc_resp_info(u8 *buffer, u32 buffer_len,
-			       struct connect_resp_info **ret_connect_resp_info)
-{
-	struct connect_resp_info *connect_resp_info = NULL;
-	u16 assoc_resp_len = 0;
-	u8 *ies = NULL;
-	u16 ies_len = 0;
-
-	connect_resp_info = kzalloc(sizeof(*connect_resp_info), GFP_KERNEL);
-	if (!connect_resp_info)
-		return -ENOMEM;
-
-	assoc_resp_len = (u16)buffer_len;
-
-	connect_resp_info->status = get_asoc_status(buffer);
-	if (connect_resp_info->status == SUCCESSFUL_STATUSCODE) {
-		connect_resp_info->capability = get_assoc_resp_cap_info(buffer);
-		connect_resp_info->assoc_id = get_asoc_id(buffer);
-
-		ies = &buffer[CAP_INFO_LEN + STATUS_CODE_LEN + AID_LEN];
-		ies_len = assoc_resp_len - (CAP_INFO_LEN + STATUS_CODE_LEN +
-					    AID_LEN);
-
-		connect_resp_info->ies = kmemdup(ies, ies_len, GFP_KERNEL);
-		if (!connect_resp_info->ies) {
-			kfree(connect_resp_info);
-			return -ENOMEM;
-		}
-
-		connect_resp_info->ies_len = ies_len;
-	}
-
-	*ret_connect_resp_info = connect_resp_info;
-
-	return 0;
-}
+// SPDX-License-Identifier: GPL-2.0
+#include "coreconfigurator.h"
+#include "wilc_wlan_if.h"
+#include "wilc_wlan.h"
+#include "wilc_wfi_netdevice.h"
+#include <linux/errno.h>
+#include <linux/slab.h>
+#define TAG_PARAM_OFFSET	(MAC_HDR_LEN + TIME_STAMP_LEN + \
+				 BEACON_INTERVAL_LEN + CAP_INFO_LEN)
+
+enum basic_frame_type {
+	FRAME_TYPE_CONTROL     = 0x04,
+	FRAME_TYPE_DATA        = 0x08,
+	FRAME_TYPE_MANAGEMENT  = 0x00,
+	FRAME_TYPE_RESERVED    = 0x0C,
+	FRAME_TYPE_FORCE_32BIT = 0xFFFFFFFF
+};
+
+enum info_element_id {
+	ISSID               = 0,   /* Service Set Identifier         */
+	ISUPRATES           = 1,   /* Supported Rates                */
+	IFHPARMS            = 2,   /* FH parameter set               */
+	IDSPARMS            = 3,   /* DS parameter set               */
+	ICFPARMS            = 4,   /* CF parameter set               */
+	ITIM                = 5,   /* Traffic Information Map        */
+	IIBPARMS            = 6,   /* IBSS parameter set             */
+	ICOUNTRY            = 7,   /* Country element                */
+	IEDCAPARAMS         = 12,  /* EDCA parameter set             */
+	ITSPEC              = 13,  /* Traffic Specification          */
+	ITCLAS              = 14,  /* Traffic Classification         */
+	ISCHED              = 15,  /* Schedule                       */
+	ICTEXT              = 16,  /* Challenge Text                 */
+	IPOWERCONSTRAINT    = 32,  /* Power Constraint               */
+	IPOWERCAPABILITY    = 33,  /* Power Capability               */
+	ITPCREQUEST         = 34,  /* TPC Request                    */
+	ITPCREPORT          = 35,  /* TPC Report                     */
+	ISUPCHANNEL         = 36,  /* Supported channel list         */
+	ICHSWANNOUNC        = 37,  /* Channel Switch Announcement    */
+	IMEASUREMENTREQUEST = 38,  /* Measurement request            */
+	IMEASUREMENTREPORT  = 39,  /* Measurement report             */
+	IQUIET              = 40,  /* Quiet element Info             */
+	IIBSSDFS            = 41,  /* IBSS DFS                       */
+	IERPINFO            = 42,  /* ERP Information                */
+	ITSDELAY            = 43,  /* TS Delay                       */
+	ITCLASPROCESS       = 44,  /* TCLAS Processing               */
+	IHTCAP              = 45,  /* HT Capabilities                */
+	IQOSCAP             = 46,  /* QoS Capability                 */
+	IRSNELEMENT         = 48,  /* RSN Information Element        */
+	IEXSUPRATES         = 50,  /* Extended Supported Rates       */
+	IEXCHSWANNOUNC      = 60,  /* Extended Ch Switch Announcement*/
+	IHTOPERATION        = 61,  /* HT Information                 */
+	ISECCHOFF           = 62,  /* Secondary Channel Offeset      */
+	I2040COEX           = 72,  /* 20/40 Coexistence IE           */
+	I2040INTOLCHREPORT  = 73,  /* 20/40 Intolerant channel report*/
+	IOBSSSCAN           = 74,  /* OBSS Scan parameters           */
+	IEXTCAP             = 127, /* Extended capability            */
+	IWMM                = 221, /* WMM parameters                 */
+	IWPAELEMENT         = 221, /* WPA Information Element        */
+	INFOELEM_ID_FORCE_32BIT  = 0xFFFFFFFF
+};
+
+static inline u16 get_beacon_period(u8 *data)
+{
+	u16 bcn_per;
+
+	bcn_per  = data[0];
+	bcn_per |= (data[1] << 8);
+
+	return bcn_per;
+}
+
+static inline u32 get_beacon_timestamp_lo(u8 *data)
+{
+	u32 time_stamp = 0;
+	u32 index    = MAC_HDR_LEN;
+
+	time_stamp |= data[index++];
+	time_stamp |= (data[index++] << 8);
+	time_stamp |= (data[index++] << 16);
+	time_stamp |= (data[index]   << 24);
+
+	return time_stamp;
+}
+
+static inline u32 get_beacon_timestamp_hi(u8 *data)
+{
+	u32 time_stamp = 0;
+	u32 index    = (MAC_HDR_LEN + 4);
+
+	time_stamp |= data[index++];
+	time_stamp |= (data[index++] << 8);
+	time_stamp |= (data[index++] << 16);
+	time_stamp |= (data[index]   << 24);
+
+	return time_stamp;
+}
+
+static inline enum sub_frame_type get_sub_type(u8 *header)
+{
+	return ((enum sub_frame_type)(header[0] & 0xFC));
+}
+
+static inline u8 get_to_ds(u8 *header)
+{
+	return (header[1] & 0x01);
+}
+
+static inline u8 get_from_ds(u8 *header)
+{
+	return ((header[1] & 0x02) >> 1);
+}
+
+static inline void get_address1(u8 *msa, u8 *addr)
+{
+	memcpy(addr, msa + 4, 6);
+}
+
+static inline void get_address2(u8 *msa, u8 *addr)
+{
+	memcpy(addr, msa + 10, 6);
+}
+
+static inline void get_address3(u8 *msa, u8 *addr)
+{
+	memcpy(addr, msa + 16, 6);
+}
+
+static inline void get_BSSID(u8 *data, u8 *bssid)
+{
+	if (get_from_ds(data) == 1)
+		get_address2(data, bssid);
+	else if (get_to_ds(data) == 1)
+		get_address1(data, bssid);
+	else
+		get_address3(data, bssid);
+}
+
+static inline void get_ssid(u8 *data, u8 *ssid, u8 *p_ssid_len)
+{
+	u8 len = 0;
+	u8 i   = 0;
+	u8 j   = 0;
+
+	len = data[TAG_PARAM_OFFSET + 1];
+	j   = TAG_PARAM_OFFSET + 2;
+
+	if (len >= MAX_SSID_LEN)
+		len = 0;
+
+	for (i = 0; i < len; i++, j++)
+		ssid[i] = data[j];
+
+	ssid[len] = '\0';
+
+	*p_ssid_len = len;
+}
+
+static inline u16 get_cap_info(u8 *data)
+{
+	u16 cap_info = 0;
+	u16 index    = MAC_HDR_LEN;
+	enum sub_frame_type st;
+
+	st = get_sub_type(data);
+
+	if (st == BEACON || st == PROBE_RSP)
+		index += TIME_STAMP_LEN + BEACON_INTERVAL_LEN;
+
+	cap_info  = data[index];
+	cap_info |= (data[index + 1] << 8);
+
+	return cap_info;
+}
+
+static inline u16 get_assoc_resp_cap_info(u8 *data)
+{
+	u16 cap_info;
+
+	cap_info  = data[0];
+	cap_info |= (data[1] << 8);
+
+	return cap_info;
+}
+
+static inline u16 get_asoc_status(u8 *data)
+{
+	u16 asoc_status;
+
+	asoc_status = data[3];
+	return (asoc_status << 8) | data[2];
+}
+
+static inline u16 get_asoc_id(u8 *data)
+{
+	u16 asoc_id;
+
+	asoc_id  = data[4];
+	asoc_id |= (data[5] << 8);
+
+	return asoc_id;
+}
+
+static u8 *get_tim_elm(u8 *msa, u16 rx_len, u16 tag_param_offset)
+{
+	u16 index;
+
+	index = tag_param_offset;
+
+	while (index < (rx_len - FCS_LEN)) {
+		if (msa[index] == ITIM)
+			return &msa[index];
+		index += (IE_HDR_LEN + msa[index + 1]);
+	}
+
+	return NULL;
+}
+
+static u8 get_current_channel_802_11n(u8 *msa, u16 rx_len)
+{
+	u16 index;
+
+	index = TAG_PARAM_OFFSET;
+	while (index < (rx_len - FCS_LEN)) {
+		if (msa[index] == IDSPARMS)
+			return msa[index + 2];
+		index += msa[index + 1] + IE_HDR_LEN;
+	}
+
+	return 0;
+}
+
+s32 wilc_parse_network_info(struct wilc_vif *vif, u8 *msg_buffer,
+			    struct network_info **ret_network_info)
+{
+	struct network_info *network_info = NULL;
+	u8 msg_type = 0;
+	u16 wid_len  = 0;
+	u8 *wid_val = NULL;
+	u8 *msa = NULL;
+	u16 rx_len = 0;
+	u8 *tim_elm = NULL;
+	u8 *ies = NULL;
+	u16 ies_len = 0;
+	u8 index = 0;
+	u32 tsf_lo;
+	u32 tsf_hi;
+
+	msg_type = msg_buffer[0];
+
+	if ('N' != msg_type)
+		return -EFAULT;
+
+	wid_len = MAKE_WORD16(msg_buffer[6], msg_buffer[7]);
+	wid_val = &msg_buffer[8];
+
+	network_info = kzalloc(sizeof(*network_info), GFP_KERNEL);
+	if (!network_info)
+		return -ENOMEM;
+
+	network_info->rssi = wid_val[0];
+
+	msa = &wid_val[1];
+
+	rx_len = wid_len - 1;
+	network_info->cap_info = get_cap_info(msa);
+	network_info->tsf_lo = get_beacon_timestamp_lo(msa);
+	PRINT_INFO(vif->ndev, CORECONFIG_DBG,"TSF :%x\n",network_info->tsf_lo);
+
+	tsf_lo = get_beacon_timestamp_lo(msa);
+	tsf_hi = get_beacon_timestamp_hi(msa);
+
+	network_info->tsf_hi = tsf_lo | ((u64)tsf_hi << 32);
+
+	get_ssid(msa, network_info->ssid, &network_info->ssid_len);
+	get_BSSID(msa, network_info->bssid);
+
+	network_info->ch = get_current_channel_802_11n(msa, rx_len
+						       + FCS_LEN);
+
+	index = MAC_HDR_LEN + TIME_STAMP_LEN;
+
+	network_info->beacon_period = get_beacon_period(msa + index);
+
+	index += BEACON_INTERVAL_LEN + CAP_INFO_LEN;
+
+	tim_elm = get_tim_elm(msa, rx_len + FCS_LEN, index);
+	if (tim_elm)
+		network_info->dtim_period = tim_elm[3];
+	ies = &msa[TAG_PARAM_OFFSET];
+	ies_len = rx_len - TAG_PARAM_OFFSET;
+
+	if (ies_len > 0) {
+		network_info->ies = kmemdup(ies, ies_len, GFP_KERNEL);
+		if (!network_info->ies) {
+			kfree(network_info);
+			return -ENOMEM;
+		}
+	}
+	network_info->ies_len = ies_len;
+
+	*ret_network_info = network_info;
+
+	return 0;
+}
+
+s32 wilc_parse_assoc_resp_info(u8 *buffer, u32 buffer_len,
+			       struct connect_resp_info **ret_connect_resp_info)
+{
+	struct connect_resp_info *connect_resp_info = NULL;
+	u16 assoc_resp_len = 0;
+	u8 *ies = NULL;
+	u16 ies_len = 0;
+
+	connect_resp_info = kzalloc(sizeof(*connect_resp_info), GFP_KERNEL);
+	if (!connect_resp_info)
+		return -ENOMEM;
+
+	assoc_resp_len = (u16)buffer_len;
+
+	connect_resp_info->status = get_asoc_status(buffer);
+	if (connect_resp_info->status == SUCCESSFUL_STATUSCODE) {
+		connect_resp_info->capability = get_assoc_resp_cap_info(buffer);
+		connect_resp_info->assoc_id = get_asoc_id(buffer);
+
+		ies = &buffer[CAP_INFO_LEN + STATUS_CODE_LEN + AID_LEN];
+		ies_len = assoc_resp_len - (CAP_INFO_LEN + STATUS_CODE_LEN +
+					    AID_LEN);
+
+		connect_resp_info->ies = kmemdup(ies, ies_len, GFP_KERNEL);
+		if (!connect_resp_info->ies) {
+			kfree(connect_resp_info);
+			return -ENOMEM;
+		}
+
+		connect_resp_info->ies_len = ies_len;
+	}
+
+	*ret_connect_resp_info = connect_resp_info;
+
+	return 0;
+}
diff --git a/drivers/staging/wilc1000/coreconfigurator.h b/drivers/staging/wilc/coreconfigurator.h
similarity index 71%
rename from drivers/staging/wilc1000/coreconfigurator.h
rename to drivers/staging/wilc/coreconfigurator.h
index 3f5da8c..ba1deba 100644
--- a/drivers/staging/wilc1000/coreconfigurator.h
+++ b/drivers/staging/wilc/coreconfigurator.h
@@ -14,21 +14,9 @@
 
 #include "wilc_wlan_if.h"
 
-#define NUM_BASIC_SWITCHES      45
-#define NUM_FHSS_SWITCHES       0
-
 #define NUM_RSSI                5
 
-#ifdef MAC_802_11N
-#define NUM_11N_BASIC_SWITCHES  25
-#define NUM_11N_HUT_SWITCHES    47
-#else
-#define NUM_11N_BASIC_SWITCHES  0
-#define NUM_11N_HUT_SWITCHES    0
-#endif
-
 #define MAC_HDR_LEN             24
-#define MAX_SSID_LEN            33
 #define FCS_LEN                 4
 #define TIME_STAMP_LEN          8
 #define BEACON_INTERVAL_LEN     2
@@ -41,16 +29,52 @@
 #define GET_CFG              1
 
 #define MAX_STRING_LEN               256
-#define MAX_SURVEY_RESULT_FRAG_SIZE  MAX_STRING_LEN
-#define SURVEY_RESULT_LENGTH         44
 #define MAX_ASSOC_RESP_FRAME_SIZE    MAX_STRING_LEN
 
-#define MAC_CONNECTED                1
-#define MAC_DISCONNECTED             0
-
 #define MAKE_WORD16(lsb, msb) ((((u16)(msb) << 8) & 0xFF00) | (lsb))
 #define MAKE_WORD32(lsw, msw) ((((u32)(msw) << 16) & 0xFFFF0000) | (lsw))
 
+extern uint32_t cfg_packet_timeout;
+
+enum sub_frame_type {
+	ASSOC_REQ	      = 0x00,
+	ASSOC_RSP	      = 0x10,
+	REASSOC_REQ	      = 0x20,
+	REASSOC_RSP	      = 0x30,
+	PROBE_REQ	      = 0x40,
+	PROBE_RSP	      = 0x50,
+	BEACON		      = 0x80,
+	ATIM		      = 0x90,
+	DISASOC		      = 0xA0,
+	AUTH		      = 0xB0,
+	DEAUTH		      = 0xC0,
+	ACTION		      = 0xD0,
+	PS_POLL		      = 0xA4,
+	RTS		      = 0xB4,
+	CTS		      = 0xC4,
+	ACK		      = 0xD4,
+	CFEND		      = 0xE4,
+	CFEND_ACK	      = 0xF4,
+	DATA		      = 0x08,
+	DATA_ACK	      = 0x18,
+	DATA_POLL	      = 0x28,
+	DATA_POLL_ACK	      = 0x38,
+	NULL_FRAME	      = 0x48,
+	CFACK		      = 0x58,
+	CFPOLL		      = 0x68,
+	CFPOLL_ACK	      = 0x78,
+	QOS_DATA	      = 0x88,
+	QOS_DATA_ACK	      = 0x98,
+	QOS_DATA_POLL	      = 0xA8,
+	QOS_DATA_POLL_ACK     = 0xB8,
+	QOS_NULL_FRAME	      = 0xC8,
+	QOS_CFPOLL	      = 0xE8,
+	QOS_CFPOLL_ACK	      = 0xF8,
+	BLOCKACK_REQ	      = 0x84,
+	BLOCKACK	      = 0x94,
+	FRAME_SUBTYPE_FORCE_32BIT  = 0xFFFFFFFF
+};
+
 enum connect_status {
 	SUCCESSFUL_STATUSCODE    = 0,
 	UNSPEC_FAIL              = 1,
@@ -121,7 +145,7 @@ struct disconnect_info {
 	size_t ie_len;
 };
 
-s32 wilc_parse_network_info(u8 *msg_buffer,
+s32 wilc_parse_network_info(struct wilc_vif *vif, u8 *msg_buffer,
 			    struct network_info **ret_network_info);
 s32 wilc_parse_assoc_resp_info(u8 *buffer, u32 buffer_len,
 			       struct connect_resp_info **ret_connect_resp_info);
diff --git a/drivers/staging/wilc/host_interface.c b/drivers/staging/wilc/host_interface.c
new file mode 100644
index 0000000..a55121d
--- /dev/null
+++ b/drivers/staging/wilc/host_interface.c
@@ -0,0 +1,4675 @@
+// SPDX-License-Identifier: GPL-2.0
+#include <linux/slab.h>
+#include <linux/time.h>
+#include <linux/kthread.h>
+#include <linux/delay.h>
+#include <linux/completion.h>
+#include <linux/list.h>
+#include <linux/workqueue.h>
+#include "host_interface.h"
+#include <linux/spinlock.h>
+#include <linux/errno.h>
+#include "coreconfigurator.h"
+#include "wilc_wlan.h"
+#include "linux_wlan.h"
+#include "wilc_wlan_if.h"
+#include <linux/etherdevice.h>
+#include <linux/version.h>
+#include "wilc_wfi_netdevice.h"
+
+#define HOST_IF_MSG_SCAN                        0
+#define HOST_IF_MSG_CONNECT                     1
+#define HOST_IF_MSG_RCVD_GNRL_ASYNC_INFO        2
+#define HOST_IF_MSG_KEY                         3
+#define HOST_IF_MSG_RCVD_NTWRK_INFO             4
+#define HOST_IF_MSG_RCVD_SCAN_COMPLETE          5
+#define HOST_IF_MSG_CFG_PARAMS                  6
+#define HOST_IF_MSG_SET_CHANNEL                 7
+#define HOST_IF_MSG_DISCONNECT                  8
+#define HOST_IF_MSG_GET_RSSI                    9
+#define HOST_IF_MSG_ADD_BEACON                  11
+#define HOST_IF_MSG_DEL_BEACON                  12
+#define HOST_IF_MSG_ADD_STATION                 13
+#define HOST_IF_MSG_DEL_STATION                 14
+#define HOST_IF_MSG_EDIT_STATION                15
+#define HOST_IF_MSG_SCAN_TIMER_FIRED            16
+#define HOST_IF_MSG_CONNECT_TIMER_FIRED         17
+#define HOST_IF_MSG_POWER_MGMT                  18
+#define HOST_IF_MSG_GET_INACTIVETIME            19
+#define HOST_IF_MSG_REMAIN_ON_CHAN              20
+#define HOST_IF_MSG_REGISTER_FRAME              21
+#define HOST_IF_MSG_LISTEN_TIMER_FIRED          22
+#define HOST_IF_MSG_SET_WFIDRV_HANDLER          24
+#define HOST_IF_MSG_SET_MAC_ADDRESS             25
+#define HOST_IF_MSG_GET_MAC_ADDRESS             26
+#define HOST_IF_MSG_SET_OPERATION_MODE          27
+#define HOST_IF_MSG_GET_STATISTICS              31
+#define HOST_IF_MSG_SET_MULTICAST_FILTER        32
+#define HOST_IF_MSG_DEL_ALL_STA                 36
+#define HOST_IF_MSG_SET_TX_POWER		38
+#define HOST_IF_MSG_GET_TX_POWER		39
+#define HOST_IF_MSG_SET_ANTENNA_MODE		40
+#define HOST_IF_MSG_SEND_BUFFERED_EAP		41
+#define HOST_IF_MSG_SET_WOWLAN_TRIGGER 		43
+#define HOST_IF_MSG_EXIT                        100
+
+#define HOST_IF_SCAN_TIMEOUT                    4000
+#define HOST_IF_CONNECT_TIMEOUT                 9500
+
+#define FALSE_FRMWR_CHANNEL			100
+
+#define TCP_ACK_FILTER_LINK_SPEED_THRESH	54
+#define DEFAULT_LINK_SPEED			72
+
+/* Generic success will return 0 */
+#define WILC_SUCCESS 		0	/* Generic success */
+
+/* Negative numbers to indicate failures */
+#define	WILC_FAIL		-100	/* Generic Fail */		
+#define	WILC_BUSY		-101	/* Busy with another operation*/
+#define	WILC_INVALID_ARGUMENT	-102	/* A given argument is invalid*/
+#define	WILC_INVALID_STATE	-103	/* An API request would violate the Driver state machine (i.e. to start PID while not camped)*/
+#define	WILC_BUFFER_OVERFLOW	-104	/* In copy operations if the copied data is larger than the allocated buffer*/
+#define WILC_NULL_PTR		-105	/* null pointer is passed or used */
+#define	WILC_EMPTY		-107
+#define WILC_FULL		-108
+#define	WILC_TIMEOUT		-109
+#define WILC_CANCELED		-110	/* The required operation have been canceled by the user*/
+#define WILC_INVALID_FILE	-112	/* The Loaded file is corruped or having an invalid format */
+#define WILC_NOT_FOUND		-113	/* Cant find the file to load */
+#define WILC_NO_MEM		-114
+#define WILC_UNSUPPORTED_VERSION -115
+#define WILC_FILE_EOF		-116
+
+struct host_if_wpa_attr {
+	u8 *key;
+	const u8 *mac_addr;
+	u8 *seq;
+	u8 seq_len;
+	u8 index;
+	u8 key_len;
+	u8 mode;
+};
+
+struct host_if_wep_attr {
+	u8 *key;
+	u8 key_len;
+	u8 index;
+	u8 mode;
+	enum AUTHTYPE auth_type;
+};
+
+union host_if_key_attr {
+	struct host_if_wep_attr wep;
+	struct host_if_wpa_attr wpa;
+	struct host_if_pmkid_attr pmkid;
+};
+
+struct key_attr {
+	enum KEY_TYPE type;
+	u8 action;
+	union host_if_key_attr attr;
+};
+
+struct send_buffered_eap {
+	wilc_frmw_to_linux_t frmw_to_linux;
+	free_eap_buf_param eap_buf_param;
+	u8 *buff;
+	unsigned int size;
+	unsigned int pkt_offset;
+	void *user_arg;
+};
+
+extern void filter_shadow_scan(void* pUserVoid, u8 *ch_freq_list,
+							   u8 ch_list_len);
+
+signed int wilc_send_buffered_eap(struct wilc_vif *vif,
+				  wilc_frmw_to_linux_t frmw_to_linux,
+				  free_eap_buf_param eap_buf_param,
+				  u8 *buff, unsigned int size,
+				  unsigned int pkt_offset,
+				  void *user_arg);
+
+struct scan_attr {
+	u8 src;
+	u8 type;
+	u8 *ch_freq_list;
+	u8 ch_list_len;
+	u8 *ies;
+	size_t ies_len;
+	wilc_scan_result result;
+	void *arg;
+	struct hidden_network hidden_network;
+};
+
+struct connect_attr {
+	u8 *bssid;
+	u8 *ssid;
+	size_t ssid_len;
+	u8 *ies;
+	size_t ies_len;
+	u8 security;
+	wilc_connect_result result;
+	void *arg;
+	enum AUTHTYPE auth_type;
+	u8 ch;
+	void *params;
+};
+
+struct rcvd_async_info {
+	u8 *buffer;
+	u32 len;
+};
+
+struct channel_attr {
+	u8 set_ch;
+};
+
+struct beacon_attr {
+	u32 interval;
+	u32 dtim_period;
+	u32 head_len;
+	u8 *head;
+	u32 tail_len;
+	u8 *tail;
+};
+
+struct set_multicast {
+	bool enabled;
+	u32 cnt;
+};
+
+struct del_all_sta {
+	u8 del_all_sta[MAX_NUM_STA][ETH_ALEN];
+	u8 assoc_sta;
+};
+
+struct del_sta {
+	u8 mac_addr[ETH_ALEN];
+};
+
+struct power_mgmt_param {
+	bool enabled;
+	u32 timeout;
+};
+
+struct sta_inactive_t {
+	u8 mac[6];
+};
+
+struct host_if_wowlan_trigger {
+	u8 wowlan_trigger;
+};
+
+struct tx_power {
+	u8 tx_pwr;
+};
+
+struct bt_coex_mode {
+	u8 bt_coex;
+};
+
+struct host_if_set_ant {
+	u8 mode;
+	u8 antenna1;
+	u8 antenna2;
+	u8 gpio_mode;
+};
+
+union message_body {
+	struct scan_attr scan_info;
+	struct connect_attr con_info;
+	struct rcvd_net_info net_info;
+	struct rcvd_async_info async_info;
+	struct key_attr key_info;
+	struct cfg_param_attr cfg_info;
+	struct channel_attr channel_info;
+	struct beacon_attr beacon_info;
+	struct add_sta_param add_sta_info;
+	struct del_sta del_sta_info;
+	struct add_sta_param edit_sta_info;
+	struct power_mgmt_param pwr_mgmt_info;
+	struct sta_inactive_t mac_info;
+	struct drv_handler drv;
+	struct set_multicast multicast_info;
+	struct op_mode mode;
+	struct dev_mac_addr dev_mac_info;
+	struct ba_session_info session_info;
+	struct remain_ch remain_on_ch;
+	struct reg_frame reg_frame;
+	char *data;
+	struct del_all_sta del_all_sta_info;
+	struct send_buffered_eap send_buff_eap;
+	struct tx_power tx_power;
+	struct host_if_set_ant set_ant;
+	struct host_if_wowlan_trigger wow_trigger;
+	struct bt_coex_mode bt_coex_mode;
+};
+
+struct host_if_msg {
+	u16 id;
+	union message_body body;
+	struct wilc_vif *vif;
+	struct work_struct work;
+};
+
+struct join_bss_param {
+	enum bss_types bss_type;
+	u8 dtim_period;
+	u16 beacon_period;
+	u16 cap_info;
+	u8 bssid[6];
+	char ssid[MAX_SSID_LEN];
+	u8 ssid_len;
+	u8 supp_rates[MAX_RATES_SUPPORTED + 1];
+	u8 ht_capable;
+	u8 wmm_cap;
+	u8 uapsd_cap;
+	bool rsn_found;
+	u8 rsn_grp_policy;
+	u8 mode_802_11i;
+	u8 rsn_pcip_policy[3];
+	u8 rsn_auth_policy[3];
+	u8 rsn_cap[2];
+	u32 tsf;
+	u8 noa_enabled;
+	u8 opp_enabled;
+	u8 ct_window;
+	u8 cnt;
+	u8 idx;
+	u8 duration[4];
+	u8 interval[4];
+	u8 start_time[4];
+};
+
+static struct host_if_drv *terminated_handle;
+#ifdef DISABLE_PWRSAVE_AND_SCAN_DURING_IP
+bool wilc_optaining_ip;
+#endif
+static struct workqueue_struct *hif_workqueue;
+static struct completion hif_thread_comp;
+static struct completion hif_driver_comp;
+static struct completion hif_wait_response;
+static struct mutex hif_deinit_lock;
+static struct timer_list periodic_rssi;
+static struct wilc_vif *periodic_rssi_vif;
+
+u8 wilc_multicast_mac_addr_list[WILC_MULTICAST_TABLE_SIZE][ETH_ALEN];
+
+static u8 rcv_assoc_resp[MAX_ASSOC_RESP_FRAME_SIZE];
+
+static s8 rssi;
+static u32 inactive_time;
+static u8 del_beacon;
+static u32 clients_count;
+
+extern int recovery_on;
+
+#define REAL_JOIN_REQ 0
+#define FLUSHED_JOIN_REQ 1
+#define FLUSHED_BYTE_POS 79
+
+static void *host_int_parse_join_bss_param(struct network_info *info);
+static void host_if_work(struct work_struct *work);
+
+/*!
+ *  @author		syounan
+ *  @date		1 Sep 2010
+ *  @note		copied from FLO glue implementatuion
+ *  @version		1.0
+ */
+static int wilc_enqueue_cmd(struct host_if_msg *msg)
+{
+	struct host_if_msg *new_msg;
+
+	new_msg = kmemdup(msg, sizeof(*new_msg), GFP_ATOMIC);
+	if (!new_msg)
+		return -ENOMEM;
+
+	INIT_WORK(&new_msg->work, host_if_work);
+
+	if(!hif_workqueue)
+		return -EFAULT;
+
+	queue_work(hif_workqueue, &new_msg->work);
+	return 0;
+}
+
+/* The u8IfIdx starts from 0 to NUM_CONCURRENT_IFC -1, but 0 index used as
+ * special purpose in wilc device, so we add 1 to the index to starts from 1.
+ * As a result, the returned index will be 1 to NUM_CONCURRENT_IFC.
+ */
+int wilc_get_vif_idx(struct wilc_vif *vif)
+{
+	return vif->idx + 1;
+}
+
+/* We need to minus 1 from idx which is from wilc device to get real index
+ * of wilc->vif[], because we add 1 when pass to wilc device in the function
+ * wilc_get_vif_idx.
+ * As a result, the index should be between 0 and NUM_CONCURRENT_IFC -1.
+ */
+static struct wilc_vif *wilc_get_vif_from_idx(struct wilc *wilc, int idx)
+{
+	int index = idx - 1;
+
+	if (index < 0 || index >= NUM_CONCURRENT_IFC)
+		return NULL;
+
+	return wilc->vif[index];
+}
+
+static int handle_send_buffered_eap(struct wilc_vif *vif,
+				    struct send_buffered_eap *hif_buff_eap)
+{
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "Sending bufferd eapol to WPAS\n");
+	if (!hif_buff_eap->buff)
+		return -EINVAL;
+
+	if (hif_buff_eap->frmw_to_linux)
+		hif_buff_eap->frmw_to_linux(vif->wilc, hif_buff_eap->buff,
+					    hif_buff_eap->size,
+					    hif_buff_eap->pkt_offset,
+					    PKT_STATUS_BUFFERED);
+	if (hif_buff_eap->eap_buf_param)
+		hif_buff_eap->eap_buf_param(hif_buff_eap->user_arg);
+
+	if(hif_buff_eap->buff != NULL){
+		kfree(hif_buff_eap->buff);
+		hif_buff_eap->buff = NULL;
+	}
+
+	return 0;
+}
+
+static void handle_set_channel(struct wilc_vif *vif,
+			       struct channel_attr *hif_set_ch)
+{
+	int ret = 0;
+	struct wid wid;
+
+	wid.id = (u16)WID_CURRENT_CHANNEL;
+	wid.type = WID_CHAR;
+	wid.val = (char *)&hif_set_ch->set_ch;
+	wid.size = sizeof(char);
+
+	ret = wilc_send_config_pkt(vif, SET_CFG, &wid, 1,
+				   wilc_get_vif_idx(vif));
+
+	if (ret)
+		PRINT_ER(vif->ndev, "Failed to set channel\n");
+}
+
+static int handle_set_wfi_drv_handler(struct wilc_vif *vif,
+				      struct drv_handler *hif_drv_handler)
+{
+	int ret = 0;
+	struct wid wid;
+	u8 *currbyte, *buffer;
+	struct host_if_drv *hif_drv = NULL;
+
+	if (!vif->hif_drv)
+		return -EINVAL;
+
+	if (!hif_drv_handler)
+		return -EINVAL;
+
+	hif_drv	= vif->hif_drv;
+
+	buffer = kzalloc(DRV_HANDLER_SIZE, GFP_KERNEL);
+	if (!buffer)
+		return -ENOMEM;
+
+	currbyte = buffer;
+	*currbyte = hif_drv_handler->handler & DRV_HANDLER_MASK;
+	currbyte++;
+	*currbyte = (u32)0 & DRV_HANDLER_MASK;
+	currbyte++;
+	*currbyte = (u32)0 & DRV_HANDLER_MASK;
+	currbyte++;
+	*currbyte = (u32)0 & DRV_HANDLER_MASK;
+	currbyte++;
+	*currbyte = (hif_drv_handler->ifc_id | (hif_drv_handler->mode << 1));
+
+	wid.id = (u16)WID_SET_DRV_HANDLER;
+	wid.type = WID_STR;
+	wid.val = (s8 *)buffer;
+	wid.size = DRV_HANDLER_SIZE;
+
+	ret = wilc_send_config_pkt(vif, SET_CFG, &wid, 1,
+				   hif_drv->driver_handler_id);
+
+	complete(&hif_driver_comp);
+
+	if (ret)
+		PRINT_ER(vif->ndev, "Failed to set driver handler\n");
+	kfree(buffer);
+	return ret;
+}
+
+static void handle_set_operation_mode(struct wilc_vif *vif,
+				      struct op_mode *hif_op_mode)
+{
+	int ret = 0;
+	struct wid wid;
+
+	wid.id = (u16)WID_SET_OPERATION_MODE;
+	wid.type = WID_INT;
+	wid.val = (s8 *)&hif_op_mode->mode;
+	wid.size = sizeof(u32);
+
+	ret = wilc_send_config_pkt(vif, SET_CFG, &wid, 1,
+				   wilc_get_vif_idx(vif));
+
+	if (hif_op_mode->mode == IDLE_MODE)
+		complete(&hif_driver_comp);
+
+	if (ret)
+		PRINT_ER(vif->ndev, "Failed to set driver handler\n");
+}
+
+static void handle_get_mac_address(struct wilc_vif *vif,
+				   struct dev_mac_addr *get_mac_addr)
+{
+	int ret = 0;
+	struct wid wid;
+
+	wid.id = (u16)WID_MAC_ADDR;
+	wid.type = WID_STR;
+	wid.val = get_mac_addr->mac_addr;
+	wid.size = ETH_ALEN;
+
+	ret = wilc_send_config_pkt(vif, GET_CFG, &wid, 1,
+				   wilc_get_vif_idx(vif));
+
+	if (ret)
+		PRINT_ER(vif->ndev, "Failed to get mac address\n");
+	complete(&hif_wait_response);
+}
+
+static void handle_set_mac_address(struct wilc_vif *vif,
+				   struct dev_mac_addr *set_mac_addr)
+{
+	int ret;
+	struct wid wid;
+
+	wid.id = (u16)WID_MAC_ADDR;
+	wid.type = WID_STR;
+	wid.val = set_mac_addr->mac_addr;
+	wid.size = ETH_ALEN;
+
+	ret = wilc_send_config_pkt(vif, SET_CFG, &wid, 1,
+				   wilc_get_vif_idx(vif));
+
+	if (ret)
+		PRINT_ER(vif->ndev, "Failed to set mac address\n");
+	complete(&hif_wait_response);
+}
+
+static void handle_cfg_param(struct wilc_vif *vif, struct cfg_param_attr *param)
+{
+	int ret = 0;
+	struct wid wid_list[32];
+	struct host_if_drv *hif_drv = vif->hif_drv;
+	int i = 0;
+
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "Setting CFG params\n");
+	
+	mutex_lock(&hif_drv->cfg_values_lock);
+
+	if (param->flag & BSS_TYPE) {
+		u8 bss_type = param->bss_type;
+
+		if (bss_type < 6) {
+			wid_list[i].id = WID_BSS_TYPE;
+			wid_list[i].val = (s8 *)&param->bss_type;
+			wid_list[i].type = WID_CHAR;
+			wid_list[i].size = sizeof(char);
+			hif_drv->cfg_values.bss_type = bss_type;
+		} else {
+			PRINT_ER(vif->ndev, "check value 6 over\n");
+			goto unlock;
+		}
+		i++;
+	}
+	if (param->flag & AUTH_TYPE) {
+		u8 auth_type = param->auth_type;
+
+		if (auth_type == 1 || auth_type == 2 || auth_type == 5) {
+			wid_list[i].id = WID_AUTH_TYPE;
+			wid_list[i].val = (s8 *)&param->auth_type;
+			wid_list[i].type = WID_CHAR;
+			wid_list[i].size = sizeof(char);
+			hif_drv->cfg_values.auth_type = auth_type;
+		} else {
+			PRINT_ER(vif->ndev, "Impossible value\n");
+			goto unlock;
+		}
+		i++;
+	}
+	if (param->flag & AUTHEN_TIMEOUT) {
+		if (param->auth_timeout > 0) {
+			wid_list[i].id = WID_AUTH_TIMEOUT;
+			wid_list[i].val = (s8 *)&param->auth_timeout;
+			wid_list[i].type = WID_SHORT;
+			wid_list[i].size = sizeof(u16);
+			hif_drv->cfg_values.auth_timeout = param->auth_timeout;
+		} else {
+			PRINT_ER(vif->ndev, "Range(1 ~ 65535) over\n");
+			goto unlock;
+		}
+		i++;
+	}
+	if (param->flag & POWER_MANAGEMENT) {
+		u8 pm_mode = param->power_mgmt_mode;
+
+		if (pm_mode < 5) {
+			wid_list[i].id = WID_POWER_MANAGEMENT;
+			wid_list[i].val = (s8 *)&param->power_mgmt_mode;
+			wid_list[i].type = WID_CHAR;
+			wid_list[i].size = sizeof(char);
+			hif_drv->cfg_values.power_mgmt_mode = pm_mode;
+		} else {
+			PRINT_ER(vif->ndev, "Invalid power mode\n");
+			goto unlock;
+		}
+		i++;
+	}
+	if (param->flag & RETRY_SHORT) {
+		u16 retry_limit = param->short_retry_limit;
+
+		if (retry_limit > 0 && retry_limit < 256) {
+			wid_list[i].id = WID_SHORT_RETRY_LIMIT;
+			wid_list[i].val = (s8 *)&param->short_retry_limit;
+			wid_list[i].type = WID_SHORT;
+			wid_list[i].size = sizeof(u16);
+			hif_drv->cfg_values.short_retry_limit = retry_limit;
+		} else {
+			PRINT_ER(vif->ndev, "Range(1~256) over\n");
+			goto unlock;
+		}
+		i++;
+	}
+	if (param->flag & RETRY_LONG) {
+		u16 limit = param->long_retry_limit;
+
+		if (limit > 0 && limit < 256) {
+			wid_list[i].id = WID_LONG_RETRY_LIMIT;
+			wid_list[i].val = (s8 *)&param->long_retry_limit;
+			wid_list[i].type = WID_SHORT;
+			wid_list[i].size = sizeof(u16);
+			hif_drv->cfg_values.long_retry_limit = limit;
+		} else {
+			PRINT_ER(vif->ndev, "Range(1~256) over\n");
+			goto unlock;
+		}
+		i++;
+	}
+	if (param->flag & FRAG_THRESHOLD) {
+		u16 frag_th = param->frag_threshold;
+
+		if (frag_th > 255 && frag_th < 7937) {
+			wid_list[i].id = WID_FRAG_THRESHOLD;
+			wid_list[i].val = (s8 *)&param->frag_threshold;
+			wid_list[i].type = WID_SHORT;
+			wid_list[i].size = sizeof(u16);
+			hif_drv->cfg_values.frag_threshold = frag_th;
+		} else {
+			PRINT_ER(vif->ndev, "Threshold Range fail\n");
+			goto unlock;
+		}
+		i++;
+	}
+	if (param->flag & RTS_THRESHOLD) {
+		u16 rts_th = param->rts_threshold;
+
+		if (rts_th > 255) {
+			wid_list[i].id = WID_RTS_THRESHOLD;
+			wid_list[i].val = (s8 *)&param->rts_threshold;
+			wid_list[i].type = WID_SHORT;
+			wid_list[i].size = sizeof(u16);
+			hif_drv->cfg_values.rts_threshold = rts_th;
+		} else {
+			PRINT_ER(vif->ndev, "Threshold Range fail\n");
+			goto unlock;
+		}
+		i++;
+	}
+	if (param->flag & PREAMBLE) {
+		u16 preamble_type = param->preamble_type;
+
+		if (param->preamble_type < 3) {
+			wid_list[i].id = WID_PREAMBLE;
+			wid_list[i].val = (s8 *)&param->preamble_type;
+			wid_list[i].type = WID_CHAR;
+			wid_list[i].size = sizeof(char);
+			hif_drv->cfg_values.preamble_type = preamble_type;
+		} else {
+			PRINT_ER(vif->ndev, "Preamle Range(0~2) over\n");
+			goto unlock;
+		}
+		i++;
+	}
+	if (param->flag & SHORT_SLOT_ALLOWED) {
+		u8 slot_allowed = param->short_slot_allowed;
+
+		if (slot_allowed < 2) {
+			wid_list[i].id = WID_SHORT_SLOT_ALLOWED;
+			wid_list[i].val = (s8 *)&param->short_slot_allowed;
+			wid_list[i].type = WID_CHAR;
+			wid_list[i].size = sizeof(char);
+			hif_drv->cfg_values.short_slot_allowed = slot_allowed;
+		} else {
+			PRINT_ER(vif->ndev, "Short slot(2) over\n");
+			goto unlock;
+		}
+		i++;
+	}
+	if (param->flag & TXOP_PROT_DISABLE) {
+		u8 prot_disabled = param->txop_prot_disabled;
+
+		if (param->txop_prot_disabled < 2) {
+			wid_list[i].id = WID_11N_TXOP_PROT_DISABLE;
+			wid_list[i].val = (s8 *)&param->txop_prot_disabled;
+			wid_list[i].type = WID_CHAR;
+			wid_list[i].size = sizeof(char);
+			hif_drv->cfg_values.txop_prot_disabled = prot_disabled;
+		} else {
+			PRINT_ER(vif->ndev, "TXOP prot disable\n");
+			goto unlock;
+		}
+		i++;
+	}
+	if (param->flag & BEACON_INTERVAL) {
+		u16 beacon_interval = param->beacon_interval;
+
+		if (beacon_interval > 0) {
+			wid_list[i].id = WID_BEACON_INTERVAL;
+			wid_list[i].val = (s8 *)&param->beacon_interval;
+			wid_list[i].type = WID_SHORT;
+			wid_list[i].size = sizeof(u16);
+			hif_drv->cfg_values.beacon_interval = beacon_interval;
+		} else {
+			PRINT_ER(vif->ndev, "Beacon interval(1~65535)fail\n");
+			goto unlock;
+		}
+		i++;
+	}
+	if (param->flag & DTIM_PERIOD) {
+		if (param->dtim_period > 0 && param->dtim_period < 256) {
+			wid_list[i].id = WID_DTIM_PERIOD;
+			wid_list[i].val = (s8 *)&param->dtim_period;
+			wid_list[i].type = WID_CHAR;
+			wid_list[i].size = sizeof(char);
+			hif_drv->cfg_values.dtim_period = param->dtim_period;
+		} else {
+			PRINT_ER(vif->ndev, "DTIM range(1~255) fail\n");
+			goto unlock;
+		}
+		i++;
+	}
+	if (param->flag & SITE_SURVEY) {
+		enum SITESURVEY enabled = param->site_survey_enabled;
+
+		if (enabled < 3) {
+			wid_list[i].id = WID_SITE_SURVEY;
+			wid_list[i].val = (s8 *)&param->site_survey_enabled;
+			wid_list[i].type = WID_CHAR;
+			wid_list[i].size = sizeof(char);
+			hif_drv->cfg_values.site_survey_enabled = enabled;
+		} else {
+			PRINT_ER(vif->ndev, "Site survey disable\n");
+			goto unlock;
+		}
+		i++;
+	}
+	if (param->flag & SITE_SURVEY_SCAN_TIME) {
+		u16 scan_time = param->site_survey_scan_time;
+
+		if (scan_time > 0) {
+			wid_list[i].id = WID_SITE_SURVEY_SCAN_TIME;
+			wid_list[i].val = (s8 *)&param->site_survey_scan_time;
+			wid_list[i].type = WID_SHORT;
+			wid_list[i].size = sizeof(u16);
+			hif_drv->cfg_values.site_survey_scan_time = scan_time;
+		} else {
+			PRINT_ER(vif->ndev, "Site scan time(1~65535) over\n");
+			goto unlock;
+		}
+		i++;
+	}
+	if (param->flag & ACTIVE_SCANTIME) {
+		u16 active_scan_time = param->active_scan_time;
+
+		if (active_scan_time > 0) {
+			wid_list[i].id = WID_ACTIVE_SCAN_TIME;
+			wid_list[i].val = (s8 *)&param->active_scan_time;
+			wid_list[i].type = WID_SHORT;
+			wid_list[i].size = sizeof(u16);
+			hif_drv->cfg_values.active_scan_time = active_scan_time;
+		} else {
+			PRINT_ER(vif->ndev, "Active time(1~65535) over\n");
+			goto unlock;
+		}
+		i++;
+	}
+	if (param->flag & PASSIVE_SCANTIME) {
+		u16 time = param->passive_scan_time;
+
+		if (time > 0) {
+			wid_list[i].id = WID_PASSIVE_SCAN_TIME;
+			wid_list[i].val = (s8 *)&param->passive_scan_time;
+			wid_list[i].type = WID_SHORT;
+			wid_list[i].size = sizeof(u16);
+			hif_drv->cfg_values.passive_scan_time = time;
+		} else {
+			PRINT_ER(vif->ndev, "Passive time(1~65535) over\n");
+			goto unlock;
+		}
+		i++;
+	}
+	if (param->flag & CURRENT_TX_RATE) {
+		enum CURRENT_TXRATE curr_tx_rate = param->curr_tx_rate;
+
+		if (curr_tx_rate == AUTORATE || curr_tx_rate == MBPS_1 ||
+		    curr_tx_rate == MBPS_2 || curr_tx_rate == MBPS_5_5 ||
+		    curr_tx_rate == MBPS_11 || curr_tx_rate == MBPS_6 ||
+		    curr_tx_rate == MBPS_9 || curr_tx_rate == MBPS_12 ||
+		    curr_tx_rate == MBPS_18 || curr_tx_rate == MBPS_24 ||
+		    curr_tx_rate == MBPS_36 || curr_tx_rate == MBPS_48 ||
+		    curr_tx_rate == MBPS_54) {
+			wid_list[i].id = WID_CURRENT_TX_RATE;
+			wid_list[i].val = (s8 *)&curr_tx_rate;
+			wid_list[i].type = WID_SHORT;
+			wid_list[i].size = sizeof(u16);
+			hif_drv->cfg_values.curr_tx_rate = (u8)curr_tx_rate;
+		} else {
+			PRINT_ER(vif->ndev, "out of TX rate\n");
+			goto unlock;
+		}
+		i++;
+	}
+
+	ret = wilc_send_config_pkt(vif, SET_CFG, wid_list,
+				   i, wilc_get_vif_idx(vif));
+
+	if (ret)
+		PRINT_ER(vif->ndev, "Error in setting CFG params\n");
+
+unlock:
+	mutex_unlock(&hif_drv->cfg_values_lock);
+}
+
+static s32 handle_scan(struct wilc_vif *vif, struct scan_attr *scan_info)
+{
+	s32 result = 0;
+	struct wid wid_list[5];
+	u32 index = 0;
+	u32 i;
+	u8 *buffer;
+	u8 valuesize = 0;
+	u8 *hdn_ntwk_wid_val = NULL;
+	struct host_if_drv *hif_drv = vif->hif_drv;
+	struct hidden_network *hidden_net = &scan_info->hidden_network;
+	struct host_if_drv *hif_drv_p2p  = wilc_get_drv_handler_by_ifc(vif->wilc, P2P_IFC);
+	struct host_if_drv *hif_drv_wlan = wilc_get_drv_handler_by_ifc(vif->wilc, WLAN_IFC);
+
+	PRINT_INFO(vif->ndev, HOSTINF_DBG,"Setting SCAN params\n");
+	PRINT_INFO(vif->ndev, HOSTINF_DBG,"Scanning: In [%d] state \n", hif_drv->hif_state);
+
+	if (!hif_drv) {
+		PRINT_ER(vif->ndev, "Driver is null\n");
+		return -EFAULT;
+	}
+	hif_drv->usr_scan_req.scan_result = scan_info->result;
+	hif_drv->usr_scan_req.arg = scan_info->arg;
+
+	if (hif_drv_p2p != NULL) {
+		if ((hif_drv_p2p->hif_state != HOST_IF_IDLE) &&
+	    (hif_drv_p2p->hif_state != HOST_IF_CONNECTED)) {
+			PRINT_INFO(vif->ndev, GENERIC_DBG,"Don't scan. P2P_IFC is in state [%d]\n",
+			 hif_drv_p2p->hif_state);
+			result = -EBUSY;
+			goto error;
+		}
+	}
+
+	if (hif_drv_wlan != NULL) {
+		if (hif_drv_wlan->hif_state != HOST_IF_IDLE &&
+	    hif_drv_wlan->hif_state != HOST_IF_CONNECTED) {
+			PRINT_INFO(vif->ndev, GENERIC_DBG,"Don't scan. WLAN_IFC is in state [%d]\n",
+			 hif_drv_wlan->hif_state);
+			result = -EBUSY;
+			goto error;
+		}
+	}
+	if(wilc_connecting) {
+		PRINT_INFO(vif->ndev, GENERIC_DBG, "[handle_scan]: Don't do scan in (CONNECTING) state\n");
+		result = -EBUSY;
+		goto error;
+	}
+#ifdef DISABLE_PWRSAVE_AND_SCAN_DURING_IP
+	if (wilc_optaining_ip) {
+		PRINT_ER(vif->ndev, "Don't do obss scan\n");
+		result = -EBUSY;
+		goto error;
+	}
+#endif
+
+	PRINT_INFO(vif->ndev, HOSTINF_DBG,"Setting SCAN params\n");
+	hif_drv->usr_scan_req.rcvd_ch_cnt = 0;
+
+	wid_list[index].id = (u16)WID_SSID_PROBE_REQ;
+	wid_list[index].type = WID_STR;
+
+	for (i = 0; i < hidden_net->n_ssids; i++)
+		valuesize += ((hidden_net->net_info[i].ssid_len) + 1);
+	hdn_ntwk_wid_val = kmalloc(valuesize + 1, GFP_KERNEL);
+	wid_list[index].val = hdn_ntwk_wid_val;
+	if (wid_list[index].val) {
+		buffer = wid_list[index].val;
+
+		*buffer++ = hidden_net->n_ssids;
+
+		PRINT_INFO(vif->ndev, HOSTINF_DBG,"In Handle_ProbeRequest number of ssid %d\n",
+			 hidden_net->n_ssids);
+		for (i = 0; i < hidden_net->n_ssids; i++) {
+			*buffer++ = hidden_net->net_info[i].ssid_len;
+			memcpy(buffer, hidden_net->net_info[i].ssid,
+			       hidden_net->net_info[i].ssid_len);
+			buffer += hidden_net->net_info[i].ssid_len;
+		}
+
+		wid_list[index].size = (s32)(valuesize + 1);
+		index++;
+	}
+
+	wid_list[index].id = WID_INFO_ELEMENT_PROBE;
+	wid_list[index].type = WID_BIN_DATA;
+	wid_list[index].val = scan_info->ies;
+	wid_list[index].size = scan_info->ies_len;
+	index++;
+
+	wid_list[index].id = WID_SCAN_TYPE;
+	wid_list[index].type = WID_CHAR;
+	wid_list[index].size = sizeof(char);
+	wid_list[index].val = (s8 *)&scan_info->type;
+	index++;
+
+	wid_list[index].id = WID_SCAN_CHANNEL_LIST;
+	wid_list[index].type = WID_BIN_DATA;
+
+	if (scan_info->ch_freq_list &&
+	    scan_info->ch_list_len > 0) {
+		int i;
+
+		for (i = 0; i < scan_info->ch_list_len; i++)	{
+			if (scan_info->ch_freq_list[i] > 0)
+				scan_info->ch_freq_list[i] -= 1;
+		}
+	}
+
+	wid_list[index].val = scan_info->ch_freq_list;
+	wid_list[index].size = scan_info->ch_list_len;
+	index++;
+
+	wid_list[index].id = WID_START_SCAN_REQ;
+	wid_list[index].type = WID_CHAR;
+	wid_list[index].size = sizeof(char);
+	wid_list[index].val = (s8 *)&scan_info->src;
+	index++;
+
+    /* 
+     * Remove APs from shadow scan list which are 
+     * not in the requested scan channels list 
+     */
+	filter_shadow_scan(vif, scan_info->ch_freq_list,
+			   scan_info->ch_list_len);
+	
+	result = wilc_send_config_pkt(vif, SET_CFG, wid_list,
+				      index,
+				      wilc_get_vif_idx(vif));
+
+	if (result)
+		PRINT_ER(vif->ndev, "Failed to send scan parameters\n");
+
+error:
+	if (result) {
+		del_timer(&hif_drv->scan_timer);
+		handle_scan_done(vif, SCAN_EVENT_ABORTED);
+	}
+
+	kfree(scan_info->ch_freq_list);
+	scan_info->ch_freq_list = NULL;
+
+	kfree(scan_info->ies);
+	scan_info->ies = NULL;
+	kfree(scan_info->hidden_network.net_info);
+	scan_info->hidden_network.net_info = NULL;
+
+	kfree(hdn_ntwk_wid_val);
+
+	return result;
+}
+
+s32 handle_scan_done(struct wilc_vif *vif, enum scan_event evt)
+{
+	s32 result = 0;
+	u8 abort_running_scan;
+	struct wid wid;
+	struct host_if_drv *hif_drv = vif->hif_drv;
+	struct user_scan_req *scan_req;
+	u8 null_bssid[6] = {0};
+
+	PRINT_INFO(vif->ndev, HOSTINF_DBG,"in handle_scan_done()\n");
+
+	if (!hif_drv) {
+		PRINT_ER(vif->ndev, "Driver handler is NULL\n");
+		return result;
+	}
+
+	if(evt == SCAN_EVENT_DONE){
+		if (memcmp(hif_drv->assoc_bssid, null_bssid, ETH_ALEN) == 0) {
+			hif_drv->hif_state = HOST_IF_IDLE;
+		} else {
+			hif_drv->hif_state = HOST_IF_CONNECTED;
+		}
+	} else if (evt == SCAN_EVENT_ABORTED) {
+		PRINT_INFO(vif->ndev, GENERIC_DBG,"Abort running scan\n");		
+		abort_running_scan = 1;
+		wid.id = (u16)WID_ABORT_RUNNING_SCAN;
+		wid.type = WID_CHAR;
+		wid.val = (s8 *)&abort_running_scan;
+		wid.size = sizeof(char);
+
+		result = wilc_send_config_pkt(vif, SET_CFG, &wid, 1,
+					      wilc_get_vif_idx(vif));
+
+		if (result) {
+			PRINT_ER(vif->ndev, "Failed to set abort running\n");
+			result = -EFAULT;
+		}
+	}
+
+	scan_req = &hif_drv->usr_scan_req;
+	if (scan_req->scan_result) {
+		scan_req->scan_result(evt, NULL, scan_req->arg, NULL);
+		scan_req->scan_result = NULL;
+	}
+
+	return result;
+}
+
+u8 wilc_connected_ssid[6] = {0};
+static s32 handle_connect(struct wilc_vif *vif,
+			  struct connect_attr *conn_attr)
+{
+	s32 result = 0;
+	struct wid wid_list[8];
+	u32 wid_cnt = 0, dummyval = 0;
+	u8 *cur_byte = NULL;
+	struct join_bss_param *bss_param;
+	struct host_if_drv *hif_drv = vif->hif_drv;
+	struct host_if_drv *hif_drv_p2p  = wilc_get_drv_handler_by_ifc(vif->wilc, P2P_IFC);
+	struct host_if_drv *hif_drv_wlan = wilc_get_drv_handler_by_ifc(vif->wilc, WLAN_IFC);
+
+	if (!hif_drv) {
+		PRINT_ER(vif->ndev, "Driver is null\n");
+		return -EFAULT;
+	}
+	
+	if (hif_drv_p2p != NULL) {
+		if (hif_drv_p2p->hif_state == HOST_IF_SCANNING) {
+			PRINT_INFO(vif->ndev, GENERIC_DBG,"Don't scan. P2P_IFC is in state [%d]\n",
+			 hif_drv_p2p->hif_state);
+			 result = -EFAULT;
+			goto error;
+		}
+	}
+	if (hif_drv_wlan != NULL) {
+		if (hif_drv_wlan->hif_state == HOST_IF_SCANNING) {
+			PRINT_INFO(vif->ndev, GENERIC_DBG,"Don't scan. WLAN_IFC is in state [%d]\n",
+			 hif_drv_wlan->hif_state);
+			result = -EFAULT;
+			goto error;
+		}
+	}
+	if (memcmp(conn_attr->bssid, wilc_connected_ssid, ETH_ALEN) == 0) {
+		result = 0;
+		PRINT_ER(vif->ndev, "Discard connect request\n");
+		return result;
+	}
+
+	PRINT_D(vif->ndev, HOSTINF_DBG, "Saving connection parameters in global structure\n");
+	bss_param = conn_attr->params;
+	if (!bss_param) {
+		PRINT_ER(vif->ndev, "Required BSSID not found\n");
+		result = -ENOENT;
+		goto error;
+	}
+
+	if (conn_attr->bssid) {
+		hif_drv->usr_conn_req.bssid = kmemdup(conn_attr->bssid, 6,
+						      GFP_KERNEL);
+		if (!hif_drv->usr_conn_req.bssid) {
+			result = -ENOMEM;
+			goto error;
+		}
+	}
+
+	hif_drv->usr_conn_req.ssid_len = conn_attr->ssid_len;
+	if (conn_attr->ssid) {
+		hif_drv->usr_conn_req.ssid = kmalloc(conn_attr->ssid_len + 1,
+						     GFP_KERNEL);
+		if (!hif_drv->usr_conn_req.ssid) {
+			result = -ENOMEM;
+			goto error;
+		}
+		memcpy(hif_drv->usr_conn_req.ssid,
+		       conn_attr->ssid,
+		       conn_attr->ssid_len);
+		hif_drv->usr_conn_req.ssid[conn_attr->ssid_len] = '\0';
+	}
+
+	hif_drv->usr_conn_req.ies_len = conn_attr->ies_len;
+	if (conn_attr->ies) {
+		hif_drv->usr_conn_req.ies = kmemdup(conn_attr->ies,
+						    conn_attr->ies_len,
+						    GFP_KERNEL);
+		if (!hif_drv->usr_conn_req.ies) {
+			result = -ENOMEM;
+			goto error;
+		}
+	}
+
+	hif_drv->usr_conn_req.security = conn_attr->security;
+	hif_drv->usr_conn_req.auth_type = conn_attr->auth_type;
+	hif_drv->usr_conn_req.conn_result = conn_attr->result;
+	hif_drv->usr_conn_req.arg = conn_attr->arg;
+
+	wid_list[wid_cnt].id = WID_SUCCESS_FRAME_COUNT;
+	wid_list[wid_cnt].type = WID_INT;
+	wid_list[wid_cnt].size = sizeof(u32);
+	wid_list[wid_cnt].val = (s8 *)(&(dummyval));
+	wid_cnt++;
+
+	wid_list[wid_cnt].id = WID_RECEIVED_FRAGMENT_COUNT;
+	wid_list[wid_cnt].type = WID_INT;
+	wid_list[wid_cnt].size = sizeof(u32);
+	wid_list[wid_cnt].val = (s8 *)(&(dummyval));
+	wid_cnt++;
+
+	wid_list[wid_cnt].id = WID_FAILED_COUNT;
+	wid_list[wid_cnt].type = WID_INT;
+	wid_list[wid_cnt].size = sizeof(u32);
+	wid_list[wid_cnt].val = (s8 *)(&(dummyval));
+	wid_cnt++;
+
+	wid_list[wid_cnt].id = WID_INFO_ELEMENT_ASSOCIATE;
+	wid_list[wid_cnt].type = WID_BIN_DATA;
+	wid_list[wid_cnt].val = hif_drv->usr_conn_req.ies;
+	wid_list[wid_cnt].size = hif_drv->usr_conn_req.ies_len;
+	wid_cnt++;
+
+	wid_list[wid_cnt].id = (u16)WID_11I_MODE;
+	wid_list[wid_cnt].type = WID_CHAR;
+	wid_list[wid_cnt].size = sizeof(char);
+	wid_list[wid_cnt].val = (s8 *)&hif_drv->usr_conn_req.security;
+	wid_cnt++;
+
+	PRINT_D(vif->ndev, HOSTINF_DBG, "Encrypt Mode = %x\n", hif_drv->usr_conn_req.security);
+	wid_list[wid_cnt].id = (u16)WID_AUTH_TYPE;
+	wid_list[wid_cnt].type = WID_CHAR;
+	wid_list[wid_cnt].size = sizeof(char);
+	wid_list[wid_cnt].val = (s8 *)&hif_drv->usr_conn_req.auth_type;
+	wid_cnt++;
+
+	PRINT_D(vif->ndev, HOSTINF_DBG, "Authentication Type = %x\n", hif_drv->usr_conn_req.auth_type);
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "Connecting to network of SSID %s on channel %d\n",
+		 hif_drv->usr_conn_req.ssid, conn_attr->ch);
+
+	wid_list[wid_cnt].id = (u16)WID_JOIN_REQ_EXTENDED;
+	wid_list[wid_cnt].type = WID_STR;
+	wid_list[wid_cnt].size = 112;
+	wid_list[wid_cnt].val = kmalloc(wid_list[wid_cnt].size, GFP_KERNEL);
+
+	if (!wid_list[wid_cnt].val) {
+		result = -EFAULT;
+		goto error;
+	}
+
+	cur_byte = wid_list[wid_cnt].val;
+
+	if (conn_attr->ssid) {
+		memcpy(cur_byte, conn_attr->ssid, conn_attr->ssid_len);
+		cur_byte[conn_attr->ssid_len] = '\0';
+	}
+	cur_byte += MAX_SSID_LEN;
+	*(cur_byte++) = INFRASTRUCTURE;
+
+	if (conn_attr->ch >= 1 && conn_attr->ch <= 14) {
+		*(cur_byte++) = conn_attr->ch;
+	} else {
+		PRINT_ER(vif->ndev, "Channel out of range\n");
+		*(cur_byte++) = 0xFF;
+	}
+	*(cur_byte++)  = (bss_param->cap_info) & 0xFF;
+	*(cur_byte++)  = ((bss_param->cap_info) >> 8) & 0xFF;
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "* Cap Info %0x*\n", (*(cur_byte - 2) | ((*(cur_byte - 1)) << 8)));
+
+	if (conn_attr->bssid)
+		memcpy(cur_byte, conn_attr->bssid, 6);
+	cur_byte += 6;
+
+	if (conn_attr->bssid)
+		memcpy(cur_byte, conn_attr->bssid, 6);
+	cur_byte += 6;
+
+	*(cur_byte++)  = (bss_param->beacon_period) & 0xFF;
+	*(cur_byte++)  = ((bss_param->beacon_period) >> 8) & 0xFF;
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "* Beacon Period %d*\n", (*(cur_byte - 2) | ((*(cur_byte - 1)) << 8)));
+	*(cur_byte++)  =  bss_param->dtim_period;
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "* DTIM Period %d*\n", (*(cur_byte - 1)));
+
+	memcpy(cur_byte, bss_param->supp_rates, MAX_RATES_SUPPORTED + 1);
+	cur_byte += (MAX_RATES_SUPPORTED + 1);
+
+	*(cur_byte++)  =  bss_param->wmm_cap;
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "* wmm cap%d*\n", (*(cur_byte - 1)));
+	*(cur_byte++)  = bss_param->uapsd_cap;
+
+	*(cur_byte++)  = bss_param->ht_capable;
+	hif_drv->usr_conn_req.ht_capable = bss_param->ht_capable;
+
+	*(cur_byte++)  =  bss_param->rsn_found;
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "* rsn found %d*\n", *(cur_byte - 1));
+	*(cur_byte++)  =  bss_param->rsn_grp_policy;
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "* rsn group policy %0x*\n", (*(cur_byte - 1)));
+	*(cur_byte++) =  bss_param->mode_802_11i;
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "* mode_802_11i %d*\n", (*(cur_byte - 1)));
+	memcpy(cur_byte, bss_param->rsn_pcip_policy,
+	       sizeof(bss_param->rsn_pcip_policy));
+	cur_byte += sizeof(bss_param->rsn_pcip_policy);
+
+	memcpy(cur_byte, bss_param->rsn_auth_policy,
+	       sizeof(bss_param->rsn_auth_policy));
+	cur_byte += sizeof(bss_param->rsn_auth_policy);
+
+	memcpy(cur_byte, bss_param->rsn_cap, sizeof(bss_param->rsn_cap));
+	cur_byte += sizeof(bss_param->rsn_cap);
+
+	*(cur_byte++) = REAL_JOIN_REQ;
+	*(cur_byte++) = bss_param->noa_enabled;
+
+	if (bss_param->noa_enabled) {
+		PRINT_INFO(vif->ndev, HOSTINF_DBG, "NOA present\n");
+		*(cur_byte++) = (bss_param->tsf) & 0xFF;
+		*(cur_byte++) = ((bss_param->tsf) >> 8) & 0xFF;
+		*(cur_byte++) = ((bss_param->tsf) >> 16) & 0xFF;
+		*(cur_byte++) = ((bss_param->tsf) >> 24) & 0xFF;
+
+		*(cur_byte++) = bss_param->idx;
+		*(cur_byte++) = bss_param->opp_enabled;
+
+		if (bss_param->opp_enabled)
+			*(cur_byte++) = bss_param->ct_window;
+
+		*(cur_byte++) = bss_param->cnt;
+
+		memcpy(cur_byte, bss_param->duration,
+		       sizeof(bss_param->duration));
+		cur_byte += sizeof(bss_param->duration);
+
+		memcpy(cur_byte, bss_param->interval,
+		       sizeof(bss_param->interval));
+		cur_byte += sizeof(bss_param->interval);
+
+		memcpy(cur_byte, bss_param->start_time,
+		       sizeof(bss_param->start_time));
+		cur_byte += sizeof(bss_param->start_time);
+	} else {
+		PRINT_INFO(vif->ndev, HOSTINF_DBG, "NOA not present\n");
+	}
+
+	cur_byte = wid_list[wid_cnt].val;
+	wid_cnt++;
+
+	PRINT_INFO(vif->ndev, GENERIC_DBG,"send HOST_IF_WAITING_CONN_RESP\n");
+	if (conn_attr->bssid) {
+		memcpy(wilc_connected_ssid,
+		       conn_attr->bssid, ETH_ALEN);
+		PRINT_INFO(vif->ndev, HOSTINF_DBG, "save Bssid = %x:%x:%x:%x:%x:%x\n",
+			 (conn_attr->bssid[0]),
+			 (conn_attr->bssid[1]),
+			 (conn_attr->bssid[2]),
+			 (conn_attr->bssid[3]),
+			 (conn_attr->bssid[4]),
+			 (conn_attr->bssid[5]));
+		PRINT_INFO(vif->ndev, HOSTINF_DBG, "save bssid = %x:%x:%x:%x:%x:%x\n",
+			 (wilc_connected_ssid[0]), (wilc_connected_ssid[1]),
+			 (wilc_connected_ssid[2]), (wilc_connected_ssid[3]),
+			 (wilc_connected_ssid[4]), (wilc_connected_ssid[5]));
+	}
+
+	result = wilc_send_config_pkt(vif, SET_CFG, wid_list,
+				      wid_cnt,
+				      wilc_get_vif_idx(vif));
+	if (result) {
+		PRINT_ER(vif->ndev, "failed to send config packet\n");
+		result = -EFAULT;
+		goto error;
+	} else {
+		PRINT_INFO(vif->ndev, GENERIC_DBG,"set HOST_IF_WAITING_CONN_RESP\n");
+		hif_drv->hif_state = HOST_IF_WAITING_CONN_RESP;
+	}
+
+error:
+	if (result) {
+		struct connect_info conn_info;
+
+		del_timer(&hif_drv->connect_timer);
+
+		PRINT_INFO(vif->ndev, HOSTINF_DBG, "could not start connecting to the required network\n");
+		memset(&conn_info, 0, sizeof(struct connect_info));
+
+		if (conn_attr->result) {
+			if (conn_attr->bssid)
+				memcpy(conn_info.bssid, conn_attr->bssid, 6);
+
+			if (conn_attr->ies) {
+				conn_info.req_ies_len = conn_attr->ies_len;
+				conn_info.req_ies = kmalloc(conn_attr->ies_len,
+							    GFP_KERNEL);
+				memcpy(conn_info.req_ies,
+				       conn_attr->ies,
+				       conn_attr->ies_len);
+			}
+
+			conn_attr->result(CONN_DISCONN_EVENT_CONN_RESP,
+							       &conn_info,
+							       MAC_STATUS_DISCONNECTED,
+							       NULL,
+							       conn_attr->arg);
+			hif_drv->hif_state = HOST_IF_IDLE;
+			kfree(conn_info.req_ies);
+			conn_info.req_ies = NULL;
+
+		} else {
+			PRINT_ER(vif->ndev, "Connect callback is NULL\n");
+		}
+	}
+
+	kfree(conn_attr->bssid);
+	conn_attr->bssid = NULL;
+
+	kfree(conn_attr->ssid);
+	conn_attr->ssid = NULL;
+
+	kfree(conn_attr->ies);
+	conn_attr->ies = NULL;
+
+	kfree(cur_byte);
+	return result;
+}
+
+static s32 handle_connect_timeout(struct wilc_vif *vif)
+{
+	s32 result = 0;
+	struct connect_info info;
+	struct wid wid;
+	u16 dummy_reason_code = 0;
+	struct host_if_drv *hif_drv = vif->hif_drv;
+
+	if (!hif_drv) {
+		PRINT_ER(vif->ndev, "Driver handler is NULL\n");
+		return result;
+	}
+
+	hif_drv->hif_state = HOST_IF_IDLE;
+
+	memset(&info, 0, sizeof(struct connect_info));
+
+	if (hif_drv->usr_conn_req.conn_result) {
+		if (hif_drv->usr_conn_req.bssid) {
+			memcpy(info.bssid,
+			       hif_drv->usr_conn_req.bssid, 6);
+		}
+
+		if (hif_drv->usr_conn_req.ies) {
+			info.req_ies_len = hif_drv->usr_conn_req.ies_len;
+			info.req_ies = kmalloc(hif_drv->usr_conn_req.ies_len, GFP_KERNEL);
+			memcpy(info.req_ies,
+			       hif_drv->usr_conn_req.ies,
+			       hif_drv->usr_conn_req.ies_len);
+		}
+
+		hif_drv->usr_conn_req.conn_result(CONN_DISCONN_EVENT_CONN_RESP,
+						  &info,
+						  MAC_STATUS_DISCONNECTED,
+						  NULL,
+						  hif_drv->usr_conn_req.arg);
+
+		kfree(info.req_ies);
+		info.req_ies = NULL;
+	} else {
+		PRINT_ER(vif->ndev, "Connect callback is NULL\n");
+	}
+
+	wid.id = (u16)WID_DISCONNECT;
+	wid.type = WID_CHAR;
+	wid.val = (s8 *)&dummy_reason_code;
+	wid.size = sizeof(char);
+
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "Sending disconnect request\n");
+	result = wilc_send_config_pkt(vif, SET_CFG, &wid, 1,
+				      wilc_get_vif_idx(vif));
+	if (result)
+		PRINT_ER(vif->ndev, "Failed to send disconect\n");
+
+	hif_drv->usr_conn_req.ssid_len = 0;
+	kfree(hif_drv->usr_conn_req.ssid);
+	hif_drv->usr_conn_req.ssid = NULL;
+	kfree(hif_drv->usr_conn_req.bssid);
+	hif_drv->usr_conn_req.bssid = NULL;
+	hif_drv->usr_conn_req.ies_len = 0;
+	kfree(hif_drv->usr_conn_req.ies);
+	hif_drv->usr_conn_req.ies = NULL;
+
+	eth_zero_addr(wilc_connected_ssid);
+
+	return result;
+}
+
+static s32 handle_rcvd_ntwrk_info(struct wilc_vif *vif,
+				  struct rcvd_net_info *rcvd_info)
+{
+	u32 i;
+	bool found;
+	s32 result = 0;
+	struct network_info *info = NULL;
+	void *params = NULL;
+	struct host_if_drv *hif_drv = vif->hif_drv;
+	struct user_scan_req *scan_req = &hif_drv->usr_scan_req;
+
+	found = true;
+	PRINT_D(vif->ndev, HOSTINF_DBG, "Handling received network info\n");
+
+	if (!scan_req->scan_result)
+		goto done;
+
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "State: Scanning, parsing network information received\n");
+	wilc_parse_network_info(vif, rcvd_info->buffer, &info);
+	if (!info || !scan_req->scan_result) {
+		PRINT_ER(vif->ndev, "driver is null\n");
+		result = -EINVAL;
+		goto done;
+	}
+
+	for (i = 0; i < scan_req->rcvd_ch_cnt; i++) {
+		if (memcmp(scan_req->net_info[i].bssid, info->bssid, 6) == 0) {
+			if (info->rssi <= scan_req->net_info[i].rssi) {
+				PRINT_INFO(vif->ndev, HOSTINF_DBG, "Network previously discovered\n");
+				goto done;
+			} else {
+				scan_req->net_info[i].rssi = info->rssi;
+				found = false;
+				break;
+			}
+		}
+	}
+
+	if (found) {
+		PRINT_INFO(vif->ndev, HOSTINF_DBG, "New network found\n");
+		if (scan_req->rcvd_ch_cnt < MAX_NUM_SCANNED_NETWORKS) {
+			scan_req->net_info[scan_req->rcvd_ch_cnt].rssi = info->rssi;
+
+			memcpy(scan_req->net_info[scan_req->rcvd_ch_cnt].bssid,
+			       info->bssid, 6);
+
+			scan_req->rcvd_ch_cnt++;
+
+			info->new_network = true;
+			params = host_int_parse_join_bss_param(info);
+
+			scan_req->scan_result(SCAN_EVENT_NETWORK_FOUND, info,
+					       scan_req->arg, params);
+		} else {
+			PRINT_WRN(vif->ndev, HOSTINF_DBG, "Discovered networks exceeded max. limit\n");
+		}
+	} else {
+		info->new_network = false;
+		scan_req->scan_result(SCAN_EVENT_NETWORK_FOUND, info,
+				      scan_req->arg, NULL);
+	}
+
+done:
+	kfree(rcvd_info->buffer);
+	rcvd_info->buffer = NULL;
+
+	if (info) {
+		kfree(info->ies);
+		kfree(info);
+	}
+
+	return result;
+}
+
+static s32 host_int_get_assoc_res_info(struct wilc_vif *vif,
+				       u8 *assoc_resp_info,
+				       u32 max_assoc_resp_info_len,
+				       u32 *rcvd_assoc_resp_info_len);
+
+static inline void host_int_free_user_conn_req(struct host_if_drv *hif_drv)
+{
+	hif_drv->usr_conn_req.ssid_len = 0;
+	kfree(hif_drv->usr_conn_req.ssid);
+	hif_drv->usr_conn_req.ssid = NULL;
+	kfree(hif_drv->usr_conn_req.bssid);
+	hif_drv->usr_conn_req.bssid = NULL;
+	hif_drv->usr_conn_req.ies_len = 0;
+	kfree(hif_drv->usr_conn_req.ies);
+	hif_drv->usr_conn_req.ies = NULL;
+}
+
+static inline void host_int_parse_assoc_resp_info(struct wilc_vif *vif,
+						  u8 mac_status)
+{
+	struct connect_resp_info *connect_resp_info = NULL;
+	struct connect_info conn_info;
+	struct host_if_drv *hif_drv = vif->hif_drv;
+
+	memset(&conn_info, 0, sizeof(struct connect_info));
+
+	if (mac_status == MAC_STATUS_CONNECTED) {
+		u32 rcvd_assoc_resp_info_len;
+
+		memset(rcv_assoc_resp, 0, MAX_ASSOC_RESP_FRAME_SIZE);
+
+		host_int_get_assoc_res_info(vif, rcv_assoc_resp,
+					    MAX_ASSOC_RESP_FRAME_SIZE,
+					    &rcvd_assoc_resp_info_len);
+
+		PRINT_D(vif->ndev, HOSTINF_DBG,
+			"Received association response = %d\n",
+			rcvd_assoc_resp_info_len);
+		if (rcvd_assoc_resp_info_len != 0) {
+			s32 err = 0;
+			PRINT_INFO(vif->ndev, HOSTINF_DBG, 
+				   "Parsing association response\n");
+			err = wilc_parse_assoc_resp_info(rcv_assoc_resp, rcvd_assoc_resp_info_len,
+							 &connect_resp_info);
+			if (err) {
+				PRINT_ER(vif->ndev,
+					 "wilc_parse_assoc_resp_info() returned error %d\n",
+					 err);
+			} else {
+				conn_info.status = connect_resp_info->status;
+
+				if (conn_info.status == SUCCESSFUL_STATUSCODE &&
+				    connect_resp_info->ies) {
+					PRINT_D(vif->ndev, HOSTINF_DBG,
+						"Association response received : Successful connection status\n");
+					conn_info.resp_ies = kmemdup(connect_resp_info->ies,
+								     connect_resp_info->ies_len,
+								     GFP_KERNEL);
+					if (conn_info.resp_ies)
+						conn_info.resp_ies_len = connect_resp_info->ies_len;
+				}
+
+				kfree(connect_resp_info->ies);
+				kfree(connect_resp_info);
+			}
+		}
+	}
+
+	if (mac_status == MAC_STATUS_CONNECTED &&
+	    conn_info.status != SUCCESSFUL_STATUSCODE) {
+		PRINT_ER(vif->ndev,
+			 "Received MAC status is MAC_STATUS_CONNECTED while the received status code in Asoc Resp is not SUCCESSFUL_STATUSCODE\n");
+		eth_zero_addr(wilc_connected_ssid);
+	} else if (mac_status == MAC_STATUS_DISCONNECTED)    {
+		PRINT_ER(vif->ndev, "Received MAC status is MAC_STATUS_DISCONNECTED\n");
+		eth_zero_addr(wilc_connected_ssid);
+	}
+
+	if (hif_drv->usr_conn_req.bssid) {
+		memcpy(conn_info.bssid, hif_drv->usr_conn_req.bssid, 6);
+
+		if (mac_status == MAC_STATUS_CONNECTED &&
+		    conn_info.status == SUCCESSFUL_STATUSCODE) {
+			memcpy(hif_drv->assoc_bssid,
+			       hif_drv->usr_conn_req.bssid, ETH_ALEN);
+		}
+	}
+
+	if (hif_drv->usr_conn_req.ies) {
+		conn_info.req_ies = kmemdup(hif_drv->usr_conn_req.ies,
+					    hif_drv->usr_conn_req.ies_len,
+					    GFP_KERNEL);
+		if (conn_info.req_ies)
+			conn_info.req_ies_len = hif_drv->usr_conn_req.ies_len;
+	}
+
+	del_timer(&hif_drv->connect_timer);
+	hif_drv->usr_conn_req.conn_result(CONN_DISCONN_EVENT_CONN_RESP,
+					  &conn_info, mac_status, NULL,
+					  hif_drv->usr_conn_req.arg);
+
+	if (mac_status == MAC_STATUS_CONNECTED &&
+	    conn_info.status == SUCCESSFUL_STATUSCODE) {
+
+		PRINT_INFO(vif->ndev, HOSTINF_DBG,
+			   "MAC status : CONNECTED and Connect Status : Successful\n");
+		hif_drv->hif_state = HOST_IF_CONNECTED;
+
+#ifdef DISABLE_PWRSAVE_AND_SCAN_DURING_IP
+		handle_pwrsave_during_obtainingIP(vif, IP_STATE_OBTAINING);
+#endif
+	} else {
+		PRINT_INFO(vif->ndev, HOSTINF_DBG,
+			   "MAC status : %d and Connect Status : %d\n",
+			   mac_status, conn_info.status);
+		hif_drv->hif_state = HOST_IF_IDLE;
+	}
+
+	kfree(conn_info.resp_ies);
+	conn_info.resp_ies = NULL;
+
+	kfree(conn_info.req_ies);
+	conn_info.req_ies = NULL;
+	host_int_free_user_conn_req(hif_drv);
+}
+
+static inline void host_int_handle_disconnect(struct wilc_vif *vif)
+{
+	struct disconnect_info disconn_info;
+	struct host_if_drv *hif_drv = vif->hif_drv;
+
+	PRINT_INFO(vif->ndev, HOSTINF_DBG,
+		   "Received MAC_STATUS_DISCONNECTED from the FW\n");
+	memset(&disconn_info, 0, sizeof(struct disconnect_info));
+
+	if (hif_drv->usr_scan_req.scan_result) {
+		PRINT_INFO(vif->ndev, HOSTINF_DBG, 
+			   "\n\n<< Abort the running OBSS Scan >>\n\n");
+		del_timer(&hif_drv->scan_timer);
+		handle_scan_done(vif, SCAN_EVENT_ABORTED);
+	}
+
+	disconn_info.reason = 0;
+	disconn_info.ie = NULL;
+	disconn_info.ie_len = 0;
+
+	if (hif_drv->usr_conn_req.conn_result) {
+#ifdef DISABLE_PWRSAVE_AND_SCAN_DURING_IP
+		handle_pwrsave_during_obtainingIP(vif, IP_STATE_DEFAULT);
+#endif
+
+		hif_drv->usr_conn_req.conn_result(CONN_DISCONN_EVENT_DISCONN_NOTIF,
+						  NULL, 0, &disconn_info,
+						  hif_drv->usr_conn_req.arg);
+	} else {
+		PRINT_ER(vif->ndev, "Connect result NULL\n");
+	}
+
+	eth_zero_addr(hif_drv->assoc_bssid);
+
+	host_int_free_user_conn_req(hif_drv);
+	hif_drv->hif_state = HOST_IF_IDLE;
+}
+
+static s32 handle_rcvd_gnrl_async_info(struct wilc_vif *vif,
+				       struct rcvd_async_info *rcvd_info)
+{
+	s32 result = 0;
+	u8 msg_type = 0;
+	u8 msg_id = 0;
+	u16 msg_len = 0;
+	u16 wid_id = (u16)WID_NIL;
+	u8 wid_len  = 0;
+	u8 mac_status;
+	u8 mac_status_reason_code;
+	u8 mac_status_additional_info;
+	struct host_if_drv *hif_drv = vif->hif_drv;
+
+	if (!rcvd_info->buffer) {
+		netdev_err(vif->ndev, "Received buffer is NULL\n");
+		return -EINVAL;
+	}
+
+	if (!hif_drv) {
+		PRINT_ER(vif->ndev, "Driver handler is NULL\n");
+		kfree(rcvd_info->buffer);
+		rcvd_info->buffer = NULL;
+		return -ENODEV;
+	}
+	PRINT_INFO(vif->ndev, GENERIC_DBG, "Current State = %d,Received state = %d\n",
+		   hif_drv->hif_state,
+		   rcvd_info->buffer[7]);
+
+	if (hif_drv->hif_state == HOST_IF_WAITING_CONN_RESP ||
+	    hif_drv->hif_state == HOST_IF_CONNECTED ||
+	    hif_drv->usr_scan_req.scan_result) {
+		if (!hif_drv->usr_conn_req.conn_result) {
+			PRINT_ER(vif->ndev, "driver is null\n");
+			kfree(rcvd_info->buffer);
+			rcvd_info->buffer = NULL;
+			return -EINVAL;
+		}
+
+		msg_type = rcvd_info->buffer[0];
+
+		if ('I' != msg_type) {
+			PRINT_ER(vif->ndev, "Received Message incorrect.\n");
+			kfree(rcvd_info->buffer);
+			rcvd_info->buffer = NULL;
+			return -EFAULT;
+		}
+
+		msg_id = rcvd_info->buffer[1];
+		msg_len = MAKE_WORD16(rcvd_info->buffer[2], rcvd_info->buffer[3]);
+		wid_id = MAKE_WORD16(rcvd_info->buffer[4], rcvd_info->buffer[5]);
+		wid_len = rcvd_info->buffer[6];
+		mac_status  = rcvd_info->buffer[7];
+		mac_status_reason_code = rcvd_info->buffer[8];
+		mac_status_additional_info = rcvd_info->buffer[9];
+		PRINT_INFO(vif->ndev, HOSTINF_DBG, 
+			   "Recieved MAC status= %d Reason= %d Info = %d\n",
+			   mac_status, mac_status_reason_code,
+			   mac_status_additional_info);
+		if (hif_drv->hif_state == HOST_IF_WAITING_CONN_RESP) {
+			PRINT_INFO(vif->ndev, HOSTINF_DBG,
+				   "Recieved MAC status= %d Reason= %d Code= %d\n",
+				   mac_status, mac_status_reason_code,
+				   mac_status_additional_info);
+			host_int_parse_assoc_resp_info(vif, mac_status);
+		} else if ((mac_status == MAC_STATUS_DISCONNECTED) &&
+			   (hif_drv->hif_state == HOST_IF_CONNECTED)) {
+			host_int_handle_disconnect(vif);
+		} else if ((mac_status == MAC_STATUS_DISCONNECTED) &&
+			   (hif_drv->usr_scan_req.scan_result)) {
+			PRINT_INFO(vif->ndev, HOSTINF_DBG, 
+				   "Received MAC_STATUS_DISCONNECTED from the FW while scanning\n");
+			PRINT_WRN(vif->ndev, HOSTINF_DBG,
+				  "\n\n<< Abort the running Scan >>\n\n");
+			del_timer(&hif_drv->scan_timer);
+			if (hif_drv->usr_scan_req.scan_result)
+				handle_scan_done(vif, SCAN_EVENT_ABORTED);
+		}
+	}
+
+	kfree(rcvd_info->buffer);
+	rcvd_info->buffer = NULL;
+
+	return result;
+}
+
+static int handle_key(struct wilc_vif *vif, struct key_attr *hif_key)
+{
+	s32 result = 0;
+	struct wid wid;
+	struct wid wid_list[5];
+	u8 i;
+	u8 *key_buf;
+	s8 s8idxarray[1];
+	s8 ret = 0;
+	struct host_if_drv *hif_drv = vif->hif_drv;
+
+	switch (hif_key->type) {
+	case WEP:
+
+		if (hif_key->action & ADDKEY_AP) {
+			PRINT_INFO(vif->ndev, HOSTINF_DBG, 
+				   "Handling WEP key index: %d\n",
+				   hif_key->attr.wep.index);
+			wid_list[0].id = (u16)WID_11I_MODE;
+			wid_list[0].type = WID_CHAR;
+			wid_list[0].size = sizeof(char);
+			wid_list[0].val = (s8 *)&hif_key->attr.wep.mode;
+
+			wid_list[1].id = WID_AUTH_TYPE;
+			wid_list[1].type = WID_CHAR;
+			wid_list[1].size = sizeof(char);
+			wid_list[1].val = (s8 *)&hif_key->attr.wep.auth_type;
+
+			key_buf = kmalloc(hif_key->attr.wep.key_len + 2,
+					  GFP_KERNEL);
+			if (!key_buf) {
+				PRINT_ER(vif->ndev, "No buffer to send Key\n");
+				return -ENOMEM;
+			}
+			key_buf[0] = hif_key->attr.wep.index;
+			key_buf[1] = hif_key->attr.wep.key_len;
+
+			memcpy(&key_buf[2], hif_key->attr.wep.key,
+			       hif_key->attr.wep.key_len);
+
+			kfree(hif_key->attr.wep.key);
+
+			wid_list[2].id = (u16)WID_WEP_KEY_VALUE;
+			wid_list[2].type = WID_STR;
+			wid_list[2].size = hif_key->attr.wep.key_len + 2;
+			wid_list[2].val = (s8 *)key_buf;
+
+			result = wilc_send_config_pkt(vif, SET_CFG,
+						      wid_list, 3,
+						      wilc_get_vif_idx(vif));
+			kfree(key_buf);
+		} else if (hif_key->action & ADDKEY) {
+			PRINT_INFO(vif->ndev, HOSTINF_DBG, 
+				   "Handling WEP key\n");
+			key_buf = kmalloc(hif_key->attr.wep.key_len + 2, GFP_KERNEL);
+			if (!key_buf) {
+				PRINT_ER(vif->ndev, "No buffer to send Key\n");
+				return -ENOMEM;
+			}
+			key_buf[0] = hif_key->attr.wep.index;
+			memcpy(key_buf + 1, &hif_key->attr.wep.key_len, 1);
+			memcpy(key_buf + 2, hif_key->attr.wep.key,
+			       hif_key->attr.wep.key_len);
+			kfree(hif_key->attr.wep.key);
+
+			wid.id = (u16)WID_ADD_WEP_KEY;
+			wid.type = WID_STR;
+			wid.val = (s8 *)key_buf;
+			wid.size = hif_key->attr.wep.key_len + 2;
+
+			result = wilc_send_config_pkt(vif, SET_CFG,
+						      &wid, 1,
+						      wilc_get_vif_idx(vif));
+			kfree(key_buf);
+		} else if (hif_key->action & REMOVEKEY) {
+			PRINT_INFO(vif->ndev, HOSTINF_DBG, "Removing key\n");
+			wid.id = (u16)WID_REMOVE_WEP_KEY;
+			wid.type = WID_STR;
+
+			s8idxarray[0] = (s8)hif_key->attr.wep.index;
+			wid.val = s8idxarray;
+			wid.size = 1;
+
+			result = wilc_send_config_pkt(vif, SET_CFG,
+						      &wid, 1,
+						      wilc_get_vif_idx(vif));
+		} else if (hif_key->action & DEFAULTKEY) {
+			wid.id = (u16)WID_KEY_ID;
+			wid.type = WID_CHAR;
+			wid.val = (s8 *)&hif_key->attr.wep.index;
+			wid.size = sizeof(char);
+
+			PRINT_INFO(vif->ndev, HOSTINF_DBG, "Setting default key index\n");
+			result = wilc_send_config_pkt(vif, SET_CFG,
+						      &wid, 1,
+						      wilc_get_vif_idx(vif));
+		}
+		complete(&hif_drv->comp_test_key_block);
+		break;
+
+	case WPA_RX_GTK:
+		if (hif_key->action & ADDKEY_AP) {
+			key_buf = kzalloc(RX_MIC_KEY_MSG_LEN, GFP_KERNEL);
+			if (!key_buf) {
+				PRINT_ER(vif->ndev, "No buffer to send RxGTK Key\n");
+				ret = -ENOMEM;
+				goto out_wpa_rx_gtk;
+			}
+
+			if (hif_key->attr.wpa.seq)
+				memcpy(key_buf + 6, hif_key->attr.wpa.seq, 8);
+
+			memcpy(key_buf + 14, &hif_key->attr.wpa.index, 1);
+			memcpy(key_buf + 15, &hif_key->attr.wpa.key_len, 1);
+			memcpy(key_buf + 16, hif_key->attr.wpa.key,
+			       hif_key->attr.wpa.key_len);
+
+			wid_list[0].id = (u16)WID_11I_MODE;
+			wid_list[0].type = WID_CHAR;
+			wid_list[0].size = sizeof(char);
+			wid_list[0].val = (s8 *)&hif_key->attr.wpa.mode;
+
+			wid_list[1].id = (u16)WID_ADD_RX_GTK;
+			wid_list[1].type = WID_STR;
+			wid_list[1].val = (s8 *)key_buf;
+			wid_list[1].size = RX_MIC_KEY_MSG_LEN;
+
+			result = wilc_send_config_pkt(vif, SET_CFG,
+						      wid_list, 2,
+						      wilc_get_vif_idx(vif));
+
+			kfree(key_buf);
+			complete(&hif_drv->comp_test_key_block);
+		} else if (hif_key->action & ADDKEY) {
+			PRINT_INFO(vif->ndev, HOSTINF_DBG, "Handling group key(Rx) function\n");
+			key_buf = kzalloc(RX_MIC_KEY_MSG_LEN, GFP_KERNEL);
+			if (!key_buf) {
+				PRINT_ER(vif->ndev, "No buffer to send RxGTK Key\n");
+				ret = -ENOMEM;
+				goto out_wpa_rx_gtk;
+			}
+
+			if (hif_drv->hif_state == HOST_IF_CONNECTED)
+				memcpy(key_buf, hif_drv->assoc_bssid, ETH_ALEN);
+			else
+				PRINT_ER(vif->ndev, "Couldn't handle\n");
+
+			memcpy(key_buf + 6, hif_key->attr.wpa.seq, 8);
+			memcpy(key_buf + 14, &hif_key->attr.wpa.index, 1);
+			memcpy(key_buf + 15, &hif_key->attr.wpa.key_len, 1);
+			memcpy(key_buf + 16, hif_key->attr.wpa.key,
+			       hif_key->attr.wpa.key_len);
+
+			wid.id = (u16)WID_ADD_RX_GTK;
+			wid.type = WID_STR;
+			wid.val = (s8 *)key_buf;
+			wid.size = RX_MIC_KEY_MSG_LEN;
+
+			result = wilc_send_config_pkt(vif, SET_CFG,
+						      &wid, 1,
+						      wilc_get_vif_idx(vif));
+
+			kfree(key_buf);
+			complete(&hif_drv->comp_test_key_block);
+		}
+out_wpa_rx_gtk:
+		kfree(hif_key->attr.wpa.key);
+		kfree(hif_key->attr.wpa.seq);
+		if (ret)
+			return ret;
+
+		break;
+
+	case WPA_PTK:
+		if (hif_key->action & ADDKEY_AP) {
+			key_buf = kmalloc(PTK_KEY_MSG_LEN + 1, GFP_KERNEL);
+			if (!key_buf) {
+				PRINT_ER(vif->ndev, "No buffer to send PTK Key\n");
+				ret = -ENOMEM;
+				goto out_wpa_ptk;
+			}
+
+			memcpy(key_buf, hif_key->attr.wpa.mac_addr, 6);
+			memcpy(key_buf + 6, &hif_key->attr.wpa.index, 1);
+			memcpy(key_buf + 7, &hif_key->attr.wpa.key_len, 1);
+			memcpy(key_buf + 8, hif_key->attr.wpa.key,
+			       hif_key->attr.wpa.key_len);
+
+			wid_list[0].id = (u16)WID_11I_MODE;
+			wid_list[0].type = WID_CHAR;
+			wid_list[0].size = sizeof(char);
+			wid_list[0].val = (s8 *)&hif_key->attr.wpa.mode;
+
+			wid_list[1].id = (u16)WID_ADD_PTK;
+			wid_list[1].type = WID_STR;
+			wid_list[1].val = (s8 *)key_buf;
+			wid_list[1].size = PTK_KEY_MSG_LEN + 1;
+
+			result = wilc_send_config_pkt(vif, SET_CFG,
+						      wid_list, 2,
+						      wilc_get_vif_idx(vif));
+			kfree(key_buf);
+			complete(&hif_drv->comp_test_key_block);
+		} else if (hif_key->action & ADDKEY) {
+			key_buf = kmalloc(PTK_KEY_MSG_LEN, GFP_KERNEL);
+			if (!key_buf) {
+				PRINT_ER(vif->ndev, "No buffer send PTK\n");
+				ret = -ENOMEM;
+				goto out_wpa_ptk;
+			}
+
+			memcpy(key_buf, hif_key->attr.wpa.mac_addr, 6);
+			memcpy(key_buf + 6, &hif_key->attr.wpa.key_len, 1);
+			memcpy(key_buf + 7, hif_key->attr.wpa.key,
+			       hif_key->attr.wpa.key_len);
+
+			wid.id = (u16)WID_ADD_PTK;
+			wid.type = WID_STR;
+			wid.val = (s8 *)key_buf;
+			wid.size = PTK_KEY_MSG_LEN;
+
+			result = wilc_send_config_pkt(vif, SET_CFG,
+						      &wid, 1,
+						      wilc_get_vif_idx(vif));
+			kfree(key_buf);
+			complete(&hif_drv->comp_test_key_block);
+		}
+
+out_wpa_ptk:
+		kfree(hif_key->attr.wpa.key);
+		if (ret)
+			return ret;
+
+		break;
+
+	case PMKSA:
+		PRINT_INFO(vif->ndev, HOSTINF_DBG, "Handling PMKSA key\n");
+		key_buf = kmalloc((hif_key->attr.pmkid.numpmkid * PMKSA_KEY_LEN) + 1, GFP_KERNEL);
+		if (!key_buf) {
+			PRINT_ER(vif->ndev, "No buffer to send PMKSA Key\n");
+			return -ENOMEM;
+		}
+
+		key_buf[0] = hif_key->attr.pmkid.numpmkid;
+
+		for (i = 0; i < hif_key->attr.pmkid.numpmkid; i++) {
+			memcpy(key_buf + ((PMKSA_KEY_LEN * i) + 1), hif_key->attr.pmkid.pmkidlist[i].bssid, ETH_ALEN);
+			memcpy(key_buf + ((PMKSA_KEY_LEN * i) + ETH_ALEN + 1), hif_key->attr.pmkid.pmkidlist[i].pmkid, PMKID_LEN);
+		}
+
+		wid.id = (u16)WID_PMKID_INFO;
+		wid.type = WID_STR;
+		wid.val = (s8 *)key_buf;
+		wid.size = (hif_key->attr.pmkid.numpmkid * PMKSA_KEY_LEN) + 1;
+
+		result = wilc_send_config_pkt(vif, SET_CFG, &wid, 1,
+					      wilc_get_vif_idx(vif));
+
+		kfree(key_buf);
+		break;
+	}
+
+	if (result)
+		PRINT_ER(vif->ndev, "Failed to send key config packet\n");
+
+	return result;
+}
+
+static void handle_disconnect(struct wilc_vif *vif)
+{
+	struct wid wid;
+	struct host_if_drv *hif_drv = vif->hif_drv;
+	struct disconnect_info disconn_info;
+	struct user_scan_req *scan_req;
+	struct user_conn_req *conn_req;
+	s32 result = 0;
+	u16 dummy_reason_code = 0;
+	struct host_if_drv *hif_drv_p2p  = wilc_get_drv_handler_by_ifc(vif->wilc, P2P_IFC);
+	struct host_if_drv *hif_drv_wlan = wilc_get_drv_handler_by_ifc(vif->wilc, WLAN_IFC);
+
+	if (!hif_drv) {
+		PRINT_ER(vif->ndev, "Driver is null\n");
+		return;
+	}
+	
+	if (hif_drv_wlan != NULL)	{
+		if (hif_drv_wlan->hif_state == HOST_IF_SCANNING) {
+			PRINT_INFO(vif->ndev, GENERIC_DBG,"Abort Scan before disconnecting. WLAN_IFC is in state [%d]\n",
+				hif_drv_wlan->hif_state);
+			del_timer(&(hif_drv_wlan->scan_timer));
+			handle_scan_done(vif, SCAN_EVENT_ABORTED);
+		}
+	}
+	if (hif_drv_p2p != NULL) {
+		if (hif_drv_p2p->hif_state == HOST_IF_SCANNING) {
+			PRINT_INFO(vif->ndev, GENERIC_DBG,"Abort Scan before disconnecting. P2P_IFC is in state [%d]\n",
+				 hif_drv_p2p->hif_state);
+			del_timer(&(hif_drv_p2p->scan_timer));
+			handle_scan_done(vif, SCAN_EVENT_ABORTED);
+		}
+	}
+	wid.id = (u16)WID_DISCONNECT;
+	wid.type = WID_CHAR;
+	wid.val = (s8 *)&dummy_reason_code;
+	wid.size = sizeof(char);
+
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "Sending disconnect request\n");
+
+#ifdef DISABLE_PWRSAVE_AND_SCAN_DURING_IP
+	handle_pwrsave_during_obtainingIP(vif, IP_STATE_DEFAULT);
+#endif
+	eth_zero_addr(wilc_connected_ssid);
+
+	result = wilc_send_config_pkt(vif, SET_CFG, &wid, 1,
+				      wilc_get_vif_idx(vif));
+
+	if (result) {
+		PRINT_ER(vif->ndev, "Failed to send dissconect\n");
+		goto out;
+	}
+
+	memset(&disconn_info, 0, sizeof(struct disconnect_info));
+
+	disconn_info.reason = 0;
+	disconn_info.ie = NULL;
+	disconn_info.ie_len = 0;
+	scan_req = &hif_drv->usr_scan_req;
+	conn_req = &hif_drv->usr_conn_req;
+
+	if (scan_req->scan_result) {
+		del_timer(&hif_drv->scan_timer);
+		scan_req->scan_result(SCAN_EVENT_ABORTED, NULL, scan_req->arg,
+				      NULL);
+		scan_req->scan_result = NULL;
+	}
+
+	if (conn_req->conn_result) {
+		if (hif_drv->hif_state == HOST_IF_WAITING_CONN_RESP) {
+			struct connect_info strConnectInfo;
+			PRINT_INFO(vif->ndev, HOSTINF_DBG,
+				   "Upper layer requested termination of connection\n");
+			memset(&strConnectInfo, 0, sizeof(struct connect_info));
+			del_timer(&hif_drv->connect_timer);
+			if (conn_req->bssid != NULL)
+				memcpy(strConnectInfo.bssid, conn_req->bssid, 6);
+			if (conn_req->ies != NULL) {
+				strConnectInfo.req_ies_len = conn_req->ies_len;
+				strConnectInfo.req_ies = kmalloc(conn_req->ies_len, GFP_ATOMIC);
+				memcpy(strConnectInfo.req_ies,
+				       conn_req->ies,
+				       conn_req->ies_len);
+			}
+			conn_req->conn_result(CONN_DISCONN_EVENT_CONN_RESP,
+					      &strConnectInfo,
+					      MAC_STATUS_DISCONNECTED, NULL,
+					      conn_req->arg);
+
+			if (strConnectInfo.req_ies != NULL) {
+				kfree(strConnectInfo.req_ies);
+				strConnectInfo.req_ies = NULL;
+			}
+
+		} else if (hif_drv->hif_state == HOST_IF_CONNECTED) {
+			conn_req->conn_result(CONN_DISCONN_EVENT_DISCONN_NOTIF,
+					      NULL, 0, &disconn_info,
+					      conn_req->arg);
+		}
+	} else {
+		PRINT_ER(vif->ndev, "conn_result = NULL\n");
+	}
+
+	hif_drv->hif_state = HOST_IF_IDLE;
+
+	eth_zero_addr(hif_drv->assoc_bssid);
+
+	conn_req->ssid_len = 0;
+	kfree(conn_req->ssid);
+	conn_req->ssid = NULL;
+	kfree(conn_req->bssid);
+	conn_req->bssid = NULL;
+	conn_req->ies_len = 0;
+	kfree(conn_req->ies);
+	conn_req->ies = NULL;
+
+out:
+
+	complete(&hif_drv->comp_test_disconn_block);
+}
+
+void wilc_resolve_disconnect_aberration(struct wilc_vif *vif)
+{
+	if (!vif->hif_drv)
+		return;
+	if (vif->hif_drv->hif_state == HOST_IF_WAITING_CONN_RESP ||
+	    vif->hif_drv->hif_state == HOST_IF_CONNECTING) {
+		PRINT_INFO(vif->ndev, HOSTINF_DBG, "\n\n<< correcting Supplicant state machine >>\n\n");
+		wilc_disconnect(vif, 1);
+	}
+}
+
+static void handle_get_rssi(struct wilc_vif *vif)
+{
+	s32 result = 0;
+	struct wid wid;
+
+	wid.id = (u16)WID_RSSI;
+	wid.type = WID_CHAR;
+	wid.val = &rssi;
+	wid.size = sizeof(char);
+
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "Getting RSSI value\n");
+	result = wilc_send_config_pkt(vif, GET_CFG, &wid, 1,
+				      wilc_get_vif_idx(vif));
+	if (result) {
+		PRINT_ER(vif->ndev, "Failed to get RSSI value\n");
+		result = -EFAULT;
+	}
+
+	complete(&vif->hif_drv->comp_get_rssi);
+}
+
+static s32 handle_get_statistics(struct wilc_vif *vif,
+				 struct rf_info *stats)
+{
+	struct wid wid_list[5];
+	u32 wid_cnt = 0, result = 0;
+
+	wid_list[wid_cnt].id = WID_LINKSPEED;
+	wid_list[wid_cnt].type = WID_CHAR;
+	wid_list[wid_cnt].size = sizeof(char);
+	wid_list[wid_cnt].val = (s8 *)&stats->link_speed;
+	wid_cnt++;
+
+	wid_list[wid_cnt].id = WID_RSSI;
+	wid_list[wid_cnt].type = WID_CHAR;
+	wid_list[wid_cnt].size = sizeof(char);
+	wid_list[wid_cnt].val = (s8 *)&stats->rssi;
+	wid_cnt++;
+
+	wid_list[wid_cnt].id = WID_SUCCESS_FRAME_COUNT;
+	wid_list[wid_cnt].type = WID_INT;
+	wid_list[wid_cnt].size = sizeof(u32);
+	wid_list[wid_cnt].val = (s8 *)&stats->tx_cnt;
+	wid_cnt++;
+
+	wid_list[wid_cnt].id = WID_RECEIVED_FRAGMENT_COUNT;
+	wid_list[wid_cnt].type = WID_INT;
+	wid_list[wid_cnt].size = sizeof(u32);
+	wid_list[wid_cnt].val = (s8 *)&stats->rx_cnt;
+	wid_cnt++;
+
+	wid_list[wid_cnt].id = WID_FAILED_COUNT;
+	wid_list[wid_cnt].type = WID_INT;
+	wid_list[wid_cnt].size = sizeof(u32);
+	wid_list[wid_cnt].val = (s8 *)&stats->tx_fail_cnt;
+	wid_cnt++;
+
+	result = wilc_send_config_pkt(vif, GET_CFG, wid_list,
+				      wid_cnt,
+				      wilc_get_vif_idx(vif));
+
+	if (result)
+		PRINT_ER(vif->ndev, "Failed to send scan parameters\n");
+
+	if (stats->link_speed > TCP_ACK_FILTER_LINK_SPEED_THRESH &&
+	    stats->link_speed != DEFAULT_LINK_SPEED) {
+		PRINT_INFO(vif->ndev, HOSTINF_DBG, "Enable TCP filter\n");
+		wilc_enable_tcp_ack_filter(true);
+	} else if (stats->link_speed != DEFAULT_LINK_SPEED) {
+		PRINT_INFO(vif->ndev, HOSTINF_DBG, "Disable TCP filter %d\n",stats->link_speed);
+		wilc_enable_tcp_ack_filter(false);
+	}
+	if (stats != &vif->wilc->dummy_statistics)
+		complete(&hif_wait_response);
+	return 0;
+}
+
+static s32 handle_get_inactive_time(struct wilc_vif *vif,
+				    struct sta_inactive_t *hif_sta_inactive)
+{
+	s32 result = 0;
+	struct wid wid;
+	struct host_if_drv *hif_drv = vif->hif_drv;
+
+	wid.id = (u16)WID_SET_STA_MAC_INACTIVE_TIME;
+	wid.type = WID_STR;
+	wid.size = ETH_ALEN;
+	wid.val = kmalloc(wid.size, GFP_KERNEL);
+	if (!wid.val)
+		return -ENOMEM;
+
+	ether_addr_copy(wid.val, hif_sta_inactive->mac);
+
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "SETING STA inactive time\n");
+	result = wilc_send_config_pkt(vif, SET_CFG, &wid, 1,
+				      wilc_get_vif_idx(vif));
+	kfree(wid.val);
+
+	if (result) {
+		PRINT_ER(vif->ndev, "Failed to SET inactive time\n");
+		return -EFAULT;
+	}
+
+	wid.id = (u16)WID_GET_INACTIVE_TIME;
+	wid.type = WID_INT;
+	wid.val = (s8 *)&inactive_time;
+	wid.size = sizeof(u32);
+
+	result = wilc_send_config_pkt(vif, GET_CFG, &wid, 1,
+				      wilc_get_vif_idx(vif));
+
+	if (result) {
+		PRINT_ER(vif->ndev, "Failed to get inactive time\n");
+		return -EFAULT;
+	}
+
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "Getting inactive time : %d\n", inactive_time);
+	complete(&hif_drv->comp_inactive_time);
+
+	return result;
+}
+
+static void handle_add_beacon(struct wilc_vif *vif, struct beacon_attr *param)
+{
+	s32 result = 0;
+	struct wid wid;
+	u8 *cur_byte;
+
+	wid.id = (u16)WID_ADD_BEACON;
+	wid.type = WID_BIN;
+	wid.size = param->head_len + param->tail_len + 16;
+	wid.val = kmalloc(wid.size, GFP_KERNEL);
+	if (!wid.val)
+		goto error;
+
+	cur_byte = wid.val;
+	*cur_byte++ = (param->interval & 0xFF);
+	*cur_byte++ = ((param->interval >> 8) & 0xFF);
+	*cur_byte++ = ((param->interval >> 16) & 0xFF);
+	*cur_byte++ = ((param->interval >> 24) & 0xFF);
+
+	*cur_byte++ = (param->dtim_period & 0xFF);
+	*cur_byte++ = ((param->dtim_period >> 8) & 0xFF);
+	*cur_byte++ = ((param->dtim_period >> 16) & 0xFF);
+	*cur_byte++ = ((param->dtim_period >> 24) & 0xFF);
+
+	*cur_byte++ = (param->head_len & 0xFF);
+	*cur_byte++ = ((param->head_len >> 8) & 0xFF);
+	*cur_byte++ = ((param->head_len >> 16) & 0xFF);
+	*cur_byte++ = ((param->head_len >> 24) & 0xFF);
+
+	memcpy(cur_byte, param->head, param->head_len);
+	cur_byte += param->head_len;
+
+	*cur_byte++ = (param->tail_len & 0xFF);
+	*cur_byte++ = ((param->tail_len >> 8) & 0xFF);
+	*cur_byte++ = ((param->tail_len >> 16) & 0xFF);
+	*cur_byte++ = ((param->tail_len >> 24) & 0xFF);
+
+	if (param->tail)
+		memcpy(cur_byte, param->tail, param->tail_len);
+	cur_byte += param->tail_len;
+
+	result = wilc_send_config_pkt(vif, SET_CFG, &wid, 1,
+				      wilc_get_vif_idx(vif));
+	if (result)
+		PRINT_ER(vif->ndev, "Failed to send add beacon\n");
+
+error:
+	kfree(wid.val);
+	kfree(param->head);
+	kfree(param->tail);
+}
+
+static void handle_del_beacon(struct wilc_vif *vif)
+{
+	s32 result = 0;
+	struct wid wid;
+	u8 *cur_byte;
+
+	wid.id = (u16)WID_DEL_BEACON;
+	wid.type = WID_CHAR;
+	wid.size = sizeof(char);
+	wid.val = &del_beacon;
+
+	if (!wid.val)
+		return;
+
+	cur_byte = wid.val;
+
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "Deleting BEACON\n");
+	result = wilc_send_config_pkt(vif, SET_CFG, &wid, 1,
+				      wilc_get_vif_idx(vif));
+	if (result)
+		PRINT_ER(vif->ndev, "Failed to send delete beacon\n");
+}
+
+static u32 wilc_hif_pack_sta_param(struct wilc_vif *vif, u8 *buff,
+				    struct add_sta_param *param)
+{
+	u8 *cur_byte;
+
+	cur_byte = buff;
+
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "Packing STA params\n");
+	memcpy(cur_byte, param->bssid, ETH_ALEN);
+	cur_byte +=  ETH_ALEN;
+
+	*cur_byte++ = param->aid & 0xFF;
+	*cur_byte++ = (param->aid >> 8) & 0xFF;
+
+	*cur_byte++ = param->rates_len;
+	if (param->rates_len > 0)
+		memcpy(cur_byte, param->rates,
+		       param->rates_len);
+	cur_byte += param->rates_len;
+
+	*cur_byte++ = param->ht_supported;
+	memcpy(cur_byte, &param->ht_capa,
+	       sizeof(struct ieee80211_ht_cap));
+	cur_byte += sizeof(struct ieee80211_ht_cap);
+
+	*cur_byte++ = param->flags_mask & 0xFF;
+	*cur_byte++ = (param->flags_mask >> 8) & 0xFF;
+
+	*cur_byte++ = param->flags_set & 0xFF;
+	*cur_byte++ = (param->flags_set >> 8) & 0xFF;
+
+	return cur_byte - buff;
+}
+
+static void handle_add_station(struct wilc_vif *vif,
+			       struct add_sta_param *param)
+{
+	s32 result = 0;
+	struct wid wid;
+	u8 *cur_byte;
+
+	wid.id = (u16)WID_ADD_STA;
+	wid.type = WID_BIN;
+	wid.size = WILC_ADD_STA_LENGTH + param->rates_len;
+
+	wid.val = kmalloc(wid.size, GFP_KERNEL);
+	if (!wid.val)
+		goto error;
+
+	cur_byte = wid.val;
+	cur_byte += wilc_hif_pack_sta_param(vif, cur_byte, param);
+
+	result = wilc_send_config_pkt(vif, SET_CFG, &wid, 1,
+				      wilc_get_vif_idx(vif));
+	if (result != 0)
+		PRINT_ER(vif->ndev, "Failed to send add station\n");
+
+error:
+	kfree(param->rates);
+	kfree(wid.val);
+}
+
+static void handle_del_all_sta(struct wilc_vif *vif,
+			       struct del_all_sta *param)
+{
+	s32 result = 0;
+	struct wid wid;
+	u8 *curr_byte;
+	u8 i;
+	u8 zero_buff[6] = {0};
+
+	wid.id = (u16)WID_DEL_ALL_STA;
+	wid.type = WID_STR;
+	wid.size = (param->assoc_sta * ETH_ALEN) + 1;
+
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "Handling delete station\n");
+	wid.val = kmalloc((param->assoc_sta * ETH_ALEN) + 1, GFP_KERNEL);
+	if (!wid.val)
+		goto error;
+
+	curr_byte = wid.val;
+
+	*(curr_byte++) = param->assoc_sta;
+
+	for (i = 0; i < MAX_NUM_STA; i++) {
+		if (memcmp(param->del_all_sta[i], zero_buff, ETH_ALEN))
+			memcpy(curr_byte, param->del_all_sta[i], ETH_ALEN);
+		else
+			continue;
+
+		curr_byte += ETH_ALEN;
+	}
+
+	result = wilc_send_config_pkt(vif, SET_CFG, &wid, 1,
+				      wilc_get_vif_idx(vif));
+	if (result)
+		PRINT_ER(vif->ndev, "Failed to send add station\n");
+
+error:
+	kfree(wid.val);
+
+	complete(&hif_wait_response);
+}
+
+static void handle_del_station(struct wilc_vif *vif, struct del_sta *param)
+{
+	s32 result = 0;
+	struct wid wid;
+	u8 *cur_byte;
+
+	wid.id = (u16)WID_REMOVE_STA;
+	wid.type = WID_BIN;
+	wid.size = ETH_ALEN;
+
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "Handling delete station\n");
+	wid.val = kmalloc(wid.size, GFP_KERNEL);
+	if (!wid.val)
+		goto error;
+
+	cur_byte = wid.val;
+
+	ether_addr_copy(cur_byte, param->mac_addr);
+
+	result = wilc_send_config_pkt(vif, SET_CFG, &wid, 1,
+				      wilc_get_vif_idx(vif));
+	if (result)
+		PRINT_ER(vif->ndev, "Failed to send add station\n");
+
+error:
+	kfree(wid.val);
+}
+
+static void handle_edit_station(struct wilc_vif *vif,
+				struct add_sta_param *param)
+{
+	s32 result = 0;
+	struct wid wid;
+	u8 *cur_byte;
+
+	wid.id = (u16)WID_EDIT_STA;
+	wid.type = WID_BIN;
+	wid.size = WILC_ADD_STA_LENGTH + param->rates_len;
+
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "Handling edit station\n");
+	wid.val = kmalloc(wid.size, GFP_KERNEL);
+	if (!wid.val)
+		goto error;
+
+	cur_byte = wid.val;
+	cur_byte += wilc_hif_pack_sta_param(vif, cur_byte, param);
+
+	result = wilc_send_config_pkt(vif, SET_CFG, &wid, 1,
+				      wilc_get_vif_idx(vif));
+	if (result)
+		PRINT_ER(vif->ndev, "Failed to send edit station\n");
+
+error:
+	kfree(param->rates);
+	kfree(wid.val);
+}
+
+static int handle_remain_on_chan(struct wilc_vif *vif,
+				 struct remain_ch *hif_remain_ch)
+{
+	s32 result = 0;
+	u8 remain_on_chan_flag;
+	struct wid wid;
+	struct host_if_drv *hif_drv = vif->hif_drv;
+	struct host_if_drv *hif_drv_p2p  = wilc_get_drv_handler_by_ifc(vif->wilc, P2P_IFC);
+	struct host_if_drv *hif_drv_wlan = wilc_get_drv_handler_by_ifc(vif->wilc, WLAN_IFC);
+
+	if (!hif_drv) {
+		PRINT_ER(vif->ndev, "Driver is null\n");
+		return -EFAULT;
+	}
+	
+	if (!hif_drv->remain_on_ch_pending) {
+		hif_drv->remain_on_ch.arg = hif_remain_ch->arg;
+		hif_drv->remain_on_ch.expired = hif_remain_ch->expired;
+		hif_drv->remain_on_ch.ready = hif_remain_ch->ready;
+		hif_drv->remain_on_ch.ch = hif_remain_ch->ch;
+		hif_drv->remain_on_ch.id = hif_remain_ch->id;
+	} else {
+		hif_remain_ch->ch = hif_drv->remain_on_ch.ch;
+	}
+
+	if (hif_drv_p2p != NULL) {
+		if (hif_drv_p2p->hif_state == HOST_IF_SCANNING) {
+			PRINT_INFO(vif->ndev, GENERIC_DBG,"Interface busy scanning. P2P_IFC is in state [%d]\n",
+				hif_drv_p2p->hif_state);
+			hif_drv->remain_on_ch_pending = 1;
+			result = -EBUSY;
+			goto error;
+		} else if ((hif_drv_p2p->hif_state != HOST_IF_IDLE) &&
+		(hif_drv_p2p->hif_state != HOST_IF_CONNECTED)) {
+			PRINT_INFO(vif->ndev, GENERIC_DBG,"Interface busy connecting or listening. P2P_IFC is in state [%d]\n",
+			 hif_drv_p2p->hif_state);
+			result = -EBUSY;
+			goto error;
+		}
+	}
+	if (hif_drv_wlan != NULL) {
+		if (hif_drv_wlan->hif_state == HOST_IF_SCANNING) {
+			PRINT_INFO(vif->ndev, GENERIC_DBG,"Interface busy scanning. WLAN_IFC is in state [%d]\n",
+				hif_drv_wlan->hif_state);
+			hif_drv->remain_on_ch_pending = 1;
+			result = -EBUSY;
+			goto error;
+		} else if ((hif_drv_wlan->hif_state != HOST_IF_IDLE) &&
+		(hif_drv_wlan->hif_state != HOST_IF_CONNECTED)) {
+			PRINT_INFO(vif->ndev, GENERIC_DBG,"Interface busy connecting or listening. WLAN_IFC is in state [%d]\n",
+			 hif_drv_wlan->hif_state);
+			result = -EBUSY;
+			goto error;
+		}
+	}
+
+	if(wilc_connecting) {
+		PRINT_INFO(vif->ndev, GENERIC_DBG, "[handle_scan]: Don't do scan in (CONNECTING) state\n");
+		result = -EBUSY;
+		goto error;
+	}
+#ifdef DISABLE_PWRSAVE_AND_SCAN_DURING_IP
+	if (wilc_optaining_ip) {
+		PRINT_INFO(vif->ndev, GENERIC_DBG, "[handle_scan]: Don't do obss scan until IP adresss is obtained\n");
+		result = -EBUSY;
+		goto error;
+	}
+#endif
+
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "Setting channel :%d\n", hif_remain_ch->ch);
+	remain_on_chan_flag = true;
+	wid.id = (u16)WID_REMAIN_ON_CHAN;
+	wid.type = WID_STR;
+	wid.size = 2;
+	wid.val = kmalloc(wid.size, GFP_KERNEL);
+	if (!wid.val) {
+		result = -ENOMEM;
+		goto error;
+	}
+
+	wid.val[0] = remain_on_chan_flag;
+	wid.val[1] = (s8)hif_remain_ch->ch;
+
+	result = wilc_send_config_pkt(vif, SET_CFG, &wid, 1,
+				      wilc_get_vif_idx(vif));
+	kfree(wid.val);
+	if (result != 0)
+		PRINT_ER(vif->ndev, "Failed to set remain on channel\n");
+
+	hif_drv->hif_state = HOST_IF_P2P_LISTEN;
+error:
+	
+	hif_drv->remain_on_ch_timer_vif = vif;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,15,0)
+	hif_drv->remain_on_ch_timer.data = (unsigned long)hif_drv;
+#endif
+	mod_timer(&hif_drv->remain_on_ch_timer,
+			  jiffies +
+			  msecs_to_jiffies(hif_remain_ch->duration));
+
+	if (hif_drv->remain_on_ch.ready)
+		hif_drv->remain_on_ch.ready(hif_drv->remain_on_ch.arg);
+
+	if (hif_drv->remain_on_ch_pending)
+		hif_drv->remain_on_ch_pending = 0;
+
+	return result;
+}
+
+static int handle_register_frame(struct wilc_vif *vif,
+				 struct reg_frame *hif_reg_frame)
+{
+	s32 result = 0;
+	struct wid wid;
+	u8 *cur_byte;
+
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "Handling frame register Flag : %d FrameType: %d\n",
+					hif_reg_frame->reg,
+					hif_reg_frame->frame_type);
+	wid.id = (u16)WID_REGISTER_FRAME;
+	wid.type = WID_STR;
+	wid.val = kmalloc(sizeof(u16) + 2, GFP_KERNEL);
+	if (!wid.val)
+		return -ENOMEM;
+
+	cur_byte = wid.val;
+
+	*cur_byte++ = hif_reg_frame->reg;
+	*cur_byte++ = hif_reg_frame->reg_id;
+	memcpy(cur_byte, &hif_reg_frame->frame_type, sizeof(u16));
+
+	wid.size = sizeof(u16) + 2;
+
+	result = wilc_send_config_pkt(vif, SET_CFG, &wid, 1,
+				      wilc_get_vif_idx(vif));
+	kfree(wid.val);
+	if (result) {
+		PRINT_ER(vif->ndev, "Failed to frame register\n");
+		result = -EINVAL;
+	}
+
+	return result;
+}
+
+static u32 handle_listen_state_expired(struct wilc_vif *vif,
+				       struct remain_ch *hif_remain_ch)
+{
+	u8 remain_on_chan_flag;
+	struct wid wid;
+	s32 result = 0;
+	struct host_if_drv *hif_drv = vif->hif_drv;
+	u8 null_bssid[6] = {0};
+
+
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "CANCEL REMAIN ON CHAN\n");
+
+	if (hif_drv->hif_state == HOST_IF_P2P_LISTEN) {
+		remain_on_chan_flag = false;
+		wid.id = (u16)WID_REMAIN_ON_CHAN;
+		wid.type = WID_STR;
+		wid.size = 2;
+		wid.val = kmalloc(wid.size, GFP_KERNEL);
+
+		if (!wid.val) {
+			PRINT_ER(vif->ndev, "Failed to allocate memory\n");
+			return -ENOMEM;
+		}
+
+		wid.val[0] = remain_on_chan_flag;
+		wid.val[1] = FALSE_FRMWR_CHANNEL;
+
+		result = wilc_send_config_pkt(vif, SET_CFG, &wid, 1,
+					      wilc_get_vif_idx(vif));
+		kfree(wid.val);
+		if (result != 0) {
+			PRINT_ER(vif->ndev, "Failed to set remain channel\n");
+			return result;
+		}
+
+		if (hif_drv->remain_on_ch.expired)
+			hif_drv->remain_on_ch.expired(hif_drv->remain_on_ch.arg,
+						      hif_remain_ch->id);
+
+		if (memcmp(hif_drv->assoc_bssid, null_bssid, ETH_ALEN) == 0)
+			hif_drv->hif_state = HOST_IF_IDLE;
+		else
+			hif_drv->hif_state = HOST_IF_CONNECTED;
+	} else {
+		PRINT_D(vif->ndev, GENERIC_DBG,  "Not in listen state\n");
+		result = -EFAULT;
+	}
+
+	return result;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,15,0)
+static void listen_timer_cb(struct timer_list *t)
+#else
+static void listen_timer_cb(unsigned long arg)
+#endif
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,15,0)
+	struct host_if_drv *hif_drv = from_timer(hif_drv, t,
+						      remain_on_ch_timer);
+#else
+	struct host_if_drv *hif_drv = (struct host_if_drv *)arg;
+#endif
+	struct wilc_vif *vif = hif_drv->remain_on_ch_timer_vif;
+	s32 result = 0;
+	struct host_if_msg msg;
+
+	del_timer(&vif->hif_drv->remain_on_ch_timer);
+
+	memset(&msg, 0, sizeof(struct host_if_msg));
+	msg.id = HOST_IF_MSG_LISTEN_TIMER_FIRED;
+	msg.vif = vif;
+	msg.body.remain_on_ch.id = vif->hif_drv->remain_on_ch.id;
+
+	result = wilc_enqueue_cmd(&msg);
+	if (result)
+		PRINT_ER(vif->ndev, "wilc_mq_send fail\n");
+}
+
+static void handle_power_management(struct wilc_vif *vif,
+				    struct power_mgmt_param *pm_param)
+{
+	s32 result = 0;
+	struct wid wid;
+	s8 power_mode;
+
+	wid.id = (u16)WID_POWER_MANAGEMENT;
+
+	if (pm_param->enabled)
+		power_mode = MIN_FAST_PS;
+	else
+		power_mode = NO_POWERSAVE;
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "Handling power mgmt to %d\n", power_mode);
+	wid.val = &power_mode;
+	wid.size = sizeof(char);
+
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "Handling Power Management\n");
+	result = wilc_send_config_pkt(vif, SET_CFG, &wid, 1,
+				      wilc_get_vif_idx(vif));
+	if (result) {
+		PRINT_ER(vif->ndev, "Failed to send power management\n");
+		return;
+	}
+	store_power_save_current_state(vif, power_mode);
+}
+
+static void handle_set_mcast_filter(struct wilc_vif *vif,
+				    struct set_multicast *hif_set_mc)
+{
+	s32 result = 0;
+	struct wid wid;
+	u8 *cur_byte;
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "Setup Multicast Filter\n");
+
+	wid.id = (u16)WID_SETUP_MULTICAST_FILTER;
+	wid.type = WID_BIN;
+	wid.size = sizeof(struct set_multicast) + (hif_set_mc->cnt * ETH_ALEN);
+	wid.val = kmalloc(wid.size, GFP_KERNEL);
+	if (!wid.val)
+		goto error;
+
+	cur_byte = wid.val;
+	*cur_byte++ = (hif_set_mc->enabled & 0xFF);
+	*cur_byte++ = 0;
+	*cur_byte++ = 0;
+	*cur_byte++ = 0;
+
+	*cur_byte++ = (hif_set_mc->cnt & 0xFF);
+	*cur_byte++ = ((hif_set_mc->cnt >> 8) & 0xFF);
+	*cur_byte++ = ((hif_set_mc->cnt >> 16) & 0xFF);
+	*cur_byte++ = ((hif_set_mc->cnt >> 24) & 0xFF);
+
+	if (hif_set_mc->cnt > 0)
+		memcpy(cur_byte, wilc_multicast_mac_addr_list,
+		       ((hif_set_mc->cnt) * ETH_ALEN));
+
+	result = wilc_send_config_pkt(vif, SET_CFG, &wid, 1,
+				      wilc_get_vif_idx(vif));
+	if (result)
+		PRINT_ER(vif->ndev, "Failed to send setup multicast\n");
+
+error:
+	kfree(wid.val);
+}
+
+static void handle_set_wowlan_trigger(struct wilc_vif *vif, u8 u8WowlanTrigger)
+{	
+	int ret = 0;
+	struct wid wid;
+
+	wid.id = (u16)WID_WOWLAN_TRIGGER;
+	wid.type = WID_CHAR;
+	wid.val = (s8*)&u8WowlanTrigger;
+	wid.size = sizeof(s8);
+
+	ret = wilc_send_config_pkt(vif, SET_CFG, &wid, 1,
+				   wilc_get_vif_idx(vif));
+
+	if (ret)
+		PRINT_ER(vif->ndev, "Failed to send wowlan trigger config packet\n");
+}
+
+static void handle_set_tx_pwr(struct wilc_vif *vif, u8 tx_pwr)
+{
+	int ret;
+	struct wid wid;
+
+	wid.id = (u16)WID_TX_POWER;
+	wid.type = WID_CHAR;
+	wid.val = &tx_pwr;
+	wid.size = sizeof(char);
+
+	ret = wilc_send_config_pkt(vif, SET_CFG, &wid, 1,
+				   wilc_get_vif_idx(vif));
+	if (ret)
+		PRINT_ER(vif->ndev, "Failed to set TX PWR\n");
+}
+
+static void handle_get_tx_pwr(struct wilc_vif *vif, u8 *tx_pwr)
+{
+	int ret = 0;
+	struct wid wid;
+
+	wid.id = (u16)WID_TX_POWER;
+	wid.type = WID_CHAR;
+	wid.val = (s8 *)tx_pwr;
+	wid.size = sizeof(char);
+
+	ret = wilc_send_config_pkt(vif, GET_CFG, &wid, 1,
+				   wilc_get_vif_idx(vif));
+	if (ret)
+		PRINT_ER(vif->ndev, "Failed to get TX PWR\n");
+
+	complete(&hif_wait_response);
+}
+
+static int handle_set_antenna_mode(struct wilc_vif *vif, struct host_if_set_ant
+				   *set_ant)
+{
+	int ret = 0;
+	struct wid wid;
+	sysfs_attr_group *attr_syfs_p = &vif->attr_sysfs;
+
+	wid.id = (u16)WID_ANTENNA_SELECTION;
+	wid.type = WID_BIN;
+	wid.val = (u8 *)set_ant;
+	wid.size = sizeof(struct host_if_set_ant);
+
+	if (attr_syfs_p->ant_swtch_mode == ANT_SWTCH_SNGL_GPIO_CTRL)
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "set antenna %d on GPIO %d\n",set_ant->mode,set_ant->antenna1);
+	else if (attr_syfs_p->ant_swtch_mode == ANT_SWTCH_DUAL_GPIO_CTRL)
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "set antenna %d on GPIOs %d and %d\n",set_ant->mode,set_ant->antenna1,set_ant->antenna2);
+
+	ret = wilc_send_config_pkt(vif, SET_CFG, &wid, 1,
+				   wilc_get_vif_idx(vif));
+	if(ret)
+		PRINT_ER(vif->ndev, "Failed to set antenna mode\n");
+
+	return ret;
+}
+
+static void host_if_work(struct work_struct *work)
+{
+	struct host_if_msg *msg;
+	struct wilc *wilc;
+	int ret = 0;
+
+	msg = container_of(work, struct host_if_msg, work);
+	wilc = msg->vif->wilc;
+
+	if (msg->id == HOST_IF_MSG_CONNECT &&
+	    msg->vif->hif_drv->usr_scan_req.scan_result) {
+		wilc_enqueue_cmd(msg);
+		usleep_range(2 * 1000, 2 * 1000);
+		goto free_msg;
+	}
+	switch (msg->id) {
+	case HOST_IF_MSG_SCAN:
+		handle_scan(msg->vif, &msg->body.scan_info);
+		break;
+
+	case HOST_IF_MSG_CONNECT:
+		handle_connect(msg->vif, &msg->body.con_info);
+		break;
+
+	case HOST_IF_MSG_RCVD_NTWRK_INFO:
+		handle_rcvd_ntwrk_info(msg->vif, &msg->body.net_info);
+		break;
+
+	case HOST_IF_MSG_RCVD_GNRL_ASYNC_INFO:
+		handle_rcvd_gnrl_async_info(msg->vif,
+					    &msg->body.async_info);
+		break;
+
+	case HOST_IF_MSG_KEY:
+		handle_key(msg->vif, &msg->body.key_info);
+		break;
+
+	case HOST_IF_MSG_CFG_PARAMS:
+		handle_cfg_param(msg->vif, &msg->body.cfg_info);
+		break;
+
+	case HOST_IF_MSG_SET_CHANNEL:
+		handle_set_channel(msg->vif, &msg->body.channel_info);
+		break;
+
+	case HOST_IF_MSG_DISCONNECT:
+		handle_disconnect(msg->vif);
+		break;
+
+	case HOST_IF_MSG_RCVD_SCAN_COMPLETE:
+		del_timer(&msg->vif->hif_drv->scan_timer);
+		PRINT_INFO(msg->vif->ndev, HOSTINF_DBG, "scan completed successfully\n");
+
+		handle_scan_done(msg->vif, SCAN_EVENT_DONE);
+
+		if (msg->vif->hif_drv->remain_on_ch_pending)
+			handle_remain_on_chan(msg->vif,
+					      &msg->body.remain_on_ch);
+
+		break;
+
+	case HOST_IF_MSG_GET_RSSI:
+		handle_get_rssi(msg->vif);
+		break;
+
+	case HOST_IF_MSG_GET_STATISTICS:
+		handle_get_statistics(msg->vif,
+				      (struct rf_info *)msg->body.data);
+		break;
+
+	case HOST_IF_MSG_ADD_BEACON:
+		handle_add_beacon(msg->vif, &msg->body.beacon_info);
+		break;
+
+	case HOST_IF_MSG_DEL_BEACON:
+		handle_del_beacon(msg->vif);
+		break;
+
+	case HOST_IF_MSG_ADD_STATION:
+		handle_add_station(msg->vif, &msg->body.add_sta_info);
+		break;
+
+	case HOST_IF_MSG_DEL_STATION:
+		handle_del_station(msg->vif, &msg->body.del_sta_info);
+		break;
+
+	case HOST_IF_MSG_EDIT_STATION:
+		handle_edit_station(msg->vif, &msg->body.edit_sta_info);
+		break;
+
+	case HOST_IF_MSG_GET_INACTIVETIME:
+		handle_get_inactive_time(msg->vif, &msg->body.mac_info);
+		break;
+
+	case HOST_IF_MSG_SCAN_TIMER_FIRED:
+		PRINT_D(msg->vif->ndev, HOSTINF_DBG, "Scan Timeout\n");
+		handle_scan_done(msg->vif, SCAN_EVENT_ABORTED);
+		break;
+
+	case HOST_IF_MSG_CONNECT_TIMER_FIRED:
+		PRINT_D(msg->vif->ndev, HOSTINF_DBG, "Connect Timeout\n");
+		handle_connect_timeout(msg->vif);
+		break;
+
+	case HOST_IF_MSG_POWER_MGMT:
+		handle_power_management(msg->vif,
+					&msg->body.pwr_mgmt_info);
+		break;
+
+	case HOST_IF_MSG_SET_WFIDRV_HANDLER:
+		ret = handle_set_wfi_drv_handler(msg->vif, &msg->body.drv);
+		break;
+
+	case HOST_IF_MSG_SET_OPERATION_MODE:
+		handle_set_operation_mode(msg->vif, &msg->body.mode);
+		break;
+
+	case HOST_IF_MSG_SET_MAC_ADDRESS:
+		handle_set_mac_address(msg->vif, &msg->body.dev_mac_info);
+		break;
+
+	case HOST_IF_MSG_GET_MAC_ADDRESS:
+		handle_get_mac_address(msg->vif, &msg->body.dev_mac_info);
+		break;
+
+	case HOST_IF_MSG_REMAIN_ON_CHAN:
+		PRINT_INFO(msg->vif->ndev, HOSTINF_DBG, "HOST_IF_MSG_REMAIN_ON_CHAN\n");
+		handle_remain_on_chan(msg->vif, &msg->body.remain_on_ch);
+		break;
+
+	case HOST_IF_MSG_REGISTER_FRAME:
+		PRINT_INFO(msg->vif->ndev, HOSTINF_DBG, "HOST_IF_MSG_REGISTER_FRAME\n");
+		handle_register_frame(msg->vif, &msg->body.reg_frame);
+		break;
+
+	case HOST_IF_MSG_LISTEN_TIMER_FIRED:
+		handle_listen_state_expired(msg->vif, &msg->body.remain_on_ch);
+		break;
+
+	case HOST_IF_MSG_SET_MULTICAST_FILTER:
+		PRINT_INFO(msg->vif->ndev, HOSTINF_DBG, "HOST_IF_MSG_SET_MULTICAST_FILTER\n");
+		handle_set_mcast_filter(msg->vif, &msg->body.multicast_info);
+		break;
+
+	case HOST_IF_MSG_DEL_ALL_STA:
+		handle_del_all_sta(msg->vif, &msg->body.del_all_sta_info);
+		break;
+
+	case HOST_IF_MSG_SET_TX_POWER:
+		handle_set_tx_pwr(msg->vif, msg->body.tx_power.tx_pwr);
+		break;
+
+	case HOST_IF_MSG_GET_TX_POWER:
+		handle_get_tx_pwr(msg->vif, &msg->body.tx_power.tx_pwr);
+		break;
+
+	case HOST_IF_MSG_SEND_BUFFERED_EAP:
+		handle_send_buffered_eap(msg->vif,
+					 &msg->body.send_buff_eap);
+		break;
+
+	case HOST_IF_MSG_SET_ANTENNA_MODE:
+		handle_set_antenna_mode(msg->vif, &msg->body.set_ant);
+		break;
+
+	case HOST_IF_MSG_SET_WOWLAN_TRIGGER:
+		handle_set_wowlan_trigger(msg->vif,msg->body.wow_trigger.wowlan_trigger);
+		break;
+
+	default:
+		PRINT_ER(msg->vif->ndev, "[Host Interface] undefined\n");
+		break;
+	}
+free_msg:
+	if (ret)
+		netdev_err(msg->vif->ndev, "Host cmd %d failed\n", msg->id);
+	kfree(msg);
+	PRINT_INFO(msg->vif->ndev, HOSTINF_DBG, "Releasing thread exit completion\n");
+	complete(&hif_thread_comp);
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,15,0)
+static void timer_scan_cb(struct timer_list *t)
+#else
+static void timer_scan_cb(unsigned long arg)
+#endif
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,15,0)
+	struct host_if_drv *hif_drv = from_timer(hif_drv, t, scan_timer);
+#else
+	struct host_if_drv *hif_drv = (struct host_if_drv *)arg;
+#endif
+	struct wilc_vif *vif = hif_drv->scan_timer_vif;
+	struct host_if_msg msg;
+
+	memset(&msg, 0, sizeof(struct host_if_msg));
+	msg.vif = vif;
+	msg.id = HOST_IF_MSG_SCAN_TIMER_FIRED;
+
+	wilc_enqueue_cmd(&msg);
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,15,0)
+static void timer_connect_cb(struct timer_list *t)
+#else
+static void timer_connect_cb(unsigned long arg)
+#endif
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,15,0)
+	struct host_if_drv *hif_drv = from_timer(hif_drv, t, connect_timer);
+#else
+	struct host_if_drv *hif_drv = (struct host_if_drv *)arg;
+#endif
+	struct wilc_vif *vif = hif_drv->connect_timer_vif;
+	struct host_if_msg msg;
+
+	memset(&msg, 0, sizeof(struct host_if_msg));
+	msg.vif = vif;
+	msg.id = HOST_IF_MSG_CONNECT_TIMER_FIRED;
+
+	wilc_enqueue_cmd(&msg);
+}
+
+signed int wilc_send_buffered_eap(struct wilc_vif *vif,
+				  wilc_frmw_to_linux_t frmw_to_linux,
+				  free_eap_buf_param eap_buf_param,
+				  u8 *buff, unsigned int size,
+				  unsigned int pkt_offset,
+				  void *user_arg)
+{
+	int result = 0;
+	struct host_if_msg msg;
+
+	if (!vif || !frmw_to_linux || !eap_buf_param ){
+		return -EFAULT;
+	}
+	memset(&msg, 0, sizeof(struct host_if_msg));
+	msg.id = HOST_IF_MSG_SEND_BUFFERED_EAP;
+	msg.vif = vif;
+	msg.body.send_buff_eap.frmw_to_linux = frmw_to_linux;
+	msg.body.send_buff_eap.eap_buf_param = eap_buf_param;
+	msg.body.send_buff_eap.size = size;
+	msg.body.send_buff_eap.pkt_offset = pkt_offset;
+	msg.body.send_buff_eap.buff = kmalloc(size + pkt_offset,
+						  GFP_ATOMIC);
+	memcpy(msg.body.send_buff_eap.buff, buff, size + pkt_offset);
+	msg.body.send_buff_eap.user_arg = user_arg;
+
+	result = wilc_enqueue_cmd(&msg);
+	if (result)
+		PRINT_ER(vif->ndev, "Coud not send EAP\n");
+	return result;
+}
+
+s32 wilc_remove_key(struct wilc_vif *vif, const u8 *sta_addr)
+{
+	struct wid wid;
+
+	wid.id = (u16)WID_REMOVE_KEY;
+	wid.type = WID_STR;
+	wid.val = (s8 *)sta_addr;
+	wid.size = 6;
+
+	return 0;
+}
+
+int wilc_remove_wep_key(struct wilc_vif *vif, u8 index)
+{
+	int result = 0;
+	struct host_if_msg msg;
+	struct host_if_drv *hif_drv = vif->hif_drv;
+
+	if (!hif_drv) {
+		result = -EFAULT;
+		PRINT_ER(vif->ndev, "Driver is null\n");
+		return result;
+	}
+
+	memset(&msg, 0, sizeof(struct host_if_msg));
+
+	msg.id = HOST_IF_MSG_KEY;
+	msg.body.key_info.type = WEP;
+	msg.body.key_info.action = REMOVEKEY;
+	msg.vif = vif;
+	msg.body.key_info.attr.wep.index = index;
+
+	result = wilc_enqueue_cmd(&msg);
+	if (result)
+		PRINT_ER(vif->ndev, "Request to remove WEP key\n");
+	else
+		wait_for_completion(&hif_drv->comp_test_key_block);
+
+	return result;
+}
+
+int wilc_set_wep_default_keyid(struct wilc_vif *vif, u8 index)
+{
+	int result = 0;
+	struct host_if_msg msg;
+	struct host_if_drv *hif_drv = vif->hif_drv;
+
+	if (!hif_drv) {
+		result = -EFAULT;
+		PRINT_ER(vif->ndev, "driver is null\n");
+		return result;
+	}
+
+	memset(&msg, 0, sizeof(struct host_if_msg));
+
+	msg.id = HOST_IF_MSG_KEY;
+	msg.body.key_info.type = WEP;
+	msg.body.key_info.action = DEFAULTKEY;
+	msg.vif = vif;
+	msg.body.key_info.attr.wep.index = index;
+
+	result = wilc_enqueue_cmd(&msg);
+	if (result)
+		PRINT_ER(vif->ndev, "Default key index\n");
+	else
+		wait_for_completion(&hif_drv->comp_test_key_block);
+
+	return result;
+}
+
+int wilc_add_wep_key_bss_sta(struct wilc_vif *vif, const u8 *key, u8 len,
+			     u8 index)
+{
+	int result;
+	struct host_if_msg msg;
+	struct host_if_drv *hif_drv = vif->hif_drv;
+
+	if (!hif_drv) {
+		PRINT_ER(vif->ndev, "driver is null\n");
+		return -EFAULT;
+	}
+
+	memset(&msg, 0, sizeof(struct host_if_msg));
+
+	msg.id = HOST_IF_MSG_KEY;
+	msg.body.key_info.type = WEP;
+	msg.body.key_info.action = ADDKEY;
+	msg.vif = vif;
+	msg.body.key_info.attr.wep.key = kmemdup(key, len, GFP_KERNEL);
+	if (!msg.body.key_info.attr.wep.key)
+		return -ENOMEM;
+
+	msg.body.key_info.attr.wep.key_len = len;
+	msg.body.key_info.attr.wep.index = index;
+
+	result = wilc_enqueue_cmd(&msg);
+	if (result) {
+		PRINT_ER(vif->ndev, "STA - WEP Key\n");
+		kfree(msg.body.key_info.attr.wep.key);
+		return result;
+	}
+
+	wait_for_completion(&hif_drv->comp_test_key_block);
+	return 0;
+}
+
+int wilc_add_wep_key_bss_ap(struct wilc_vif *vif, const u8 *key, u8 len,
+			    u8 index, u8 mode, enum AUTHTYPE auth_type)
+{
+	int result;
+	struct host_if_msg msg;
+	struct host_if_drv *hif_drv = vif->hif_drv;
+
+	if (!hif_drv) {
+		PRINT_ER(vif->ndev, "driver is null\n");
+		return -EFAULT;
+	}
+
+	memset(&msg, 0, sizeof(struct host_if_msg));
+
+	msg.id = HOST_IF_MSG_KEY;
+	msg.body.key_info.type = WEP;
+	msg.body.key_info.action = ADDKEY_AP;
+	msg.vif = vif;
+	msg.body.key_info.attr.wep.key = kmemdup(key, len, GFP_KERNEL);
+	if (!msg.body.key_info.attr.wep.key)
+		return -ENOMEM;
+
+	msg.body.key_info.attr.wep.key_len = len;
+	msg.body.key_info.attr.wep.index = index;
+	msg.body.key_info.attr.wep.mode = mode;
+	msg.body.key_info.attr.wep.auth_type = auth_type;
+
+	result = wilc_enqueue_cmd(&msg);
+	if (result) {
+		PRINT_ER(vif->ndev, "AP - WEP Key\n");
+		kfree(msg.body.key_info.attr.wep.key);
+		return result;
+	}
+
+	wait_for_completion(&hif_drv->comp_test_key_block);
+	return 0;
+}
+
+int wilc_add_ptk(struct wilc_vif *vif, const u8 *ptk, u8 ptk_key_len,
+		 const u8 *mac_addr, const u8 *rx_mic, const u8 *tx_mic,
+		 u8 mode, u8 cipher_mode, u8 index)
+{
+	int result;
+	struct host_if_msg msg;
+	struct host_if_drv *hif_drv = vif->hif_drv;
+	u8 key_len = ptk_key_len;
+
+	if (!hif_drv) {
+		PRINT_ER(vif->ndev, "driver is null\n");
+		return -EFAULT;
+	}
+
+	if (rx_mic)
+		key_len += RX_MIC_KEY_LEN;
+
+	if (tx_mic)
+		key_len += TX_MIC_KEY_LEN;
+
+	memset(&msg, 0, sizeof(struct host_if_msg));
+
+	msg.id = HOST_IF_MSG_KEY;
+	msg.body.key_info.type = WPA_PTK;
+	if (mode == AP_MODE) {
+		msg.body.key_info.action = ADDKEY_AP;
+		msg.body.key_info.attr.wpa.index = index;
+	}
+	if (mode == STATION_MODE)
+		msg.body.key_info.action = ADDKEY;
+
+	msg.body.key_info.attr.wpa.key = kmemdup(ptk, ptk_key_len, GFP_KERNEL);
+	if (!msg.body.key_info.attr.wpa.key)
+		return -ENOMEM;
+
+	if (rx_mic)
+		memcpy(msg.body.key_info.attr.wpa.key + 16, rx_mic,
+		       RX_MIC_KEY_LEN);
+
+	if (tx_mic)
+		memcpy(msg.body.key_info.attr.wpa.key + 24, tx_mic,
+		       TX_MIC_KEY_LEN);
+
+	msg.body.key_info.attr.wpa.key_len = key_len;
+	msg.body.key_info.attr.wpa.mac_addr = mac_addr;
+	msg.body.key_info.attr.wpa.mode = cipher_mode;
+	msg.vif = vif;
+
+	result = wilc_enqueue_cmd(&msg);
+	if (result) {
+		PRINT_ER(vif->ndev, "PTK Key\n");
+		kfree(msg.body.key_info.attr.wpa.key);
+		return result;
+	}
+
+	wait_for_completion(&hif_drv->comp_test_key_block);
+	return 0;
+}
+
+int wilc_add_rx_gtk(struct wilc_vif *vif, const u8 *rx_gtk, u8 gtk_key_len,
+		    u8 index, u32 key_rsc_len, const u8 *key_rsc,
+		    const u8 *rx_mic, const u8 *tx_mic, u8 mode,
+		    u8 cipher_mode)
+{
+	int result;
+	struct host_if_msg msg;
+	struct host_if_drv *hif_drv = vif->hif_drv;
+	u8 key_len = gtk_key_len;
+
+	if (!hif_drv) {
+		PRINT_ER(vif->ndev, "driver is null\n");
+		return -EFAULT;
+	}
+	memset(&msg, 0, sizeof(struct host_if_msg));
+
+	if (rx_mic)
+		key_len += RX_MIC_KEY_LEN;
+
+	if (tx_mic)
+		key_len += TX_MIC_KEY_LEN;
+
+	if (key_rsc) {
+		msg.body.key_info.attr.wpa.seq = kmemdup(key_rsc,
+							 key_rsc_len,
+							 GFP_KERNEL);
+		if (!msg.body.key_info.attr.wpa.seq)
+			return -ENOMEM;
+	}
+
+	msg.id = HOST_IF_MSG_KEY;
+	msg.body.key_info.type = WPA_RX_GTK;
+	msg.vif = vif;
+
+	if (mode == AP_MODE) {
+		msg.body.key_info.action = ADDKEY_AP;
+		msg.body.key_info.attr.wpa.mode = cipher_mode;
+	}
+	if (mode == STATION_MODE)
+		msg.body.key_info.action = ADDKEY;
+
+	msg.body.key_info.attr.wpa.key = kmemdup(rx_gtk,
+						 key_len,
+						 GFP_KERNEL);
+	if (!msg.body.key_info.attr.wpa.key) {
+		kfree(msg.body.key_info.attr.wpa.seq);
+		return -ENOMEM;
+	}
+
+	if (rx_mic)
+		memcpy(msg.body.key_info.attr.wpa.key + 16, rx_mic,
+		       RX_MIC_KEY_LEN);
+
+	if (tx_mic)
+		memcpy(msg.body.key_info.attr.wpa.key + 24, tx_mic,
+		       TX_MIC_KEY_LEN);
+
+	msg.body.key_info.attr.wpa.index = index;
+	msg.body.key_info.attr.wpa.key_len = key_len;
+	msg.body.key_info.attr.wpa.seq_len = key_rsc_len;
+
+	result = wilc_enqueue_cmd(&msg);
+	if (result) {
+		PRINT_ER(vif->ndev, "RX GTK\n");
+		kfree(msg.body.key_info.attr.wpa.seq);
+		kfree(msg.body.key_info.attr.wpa.key);
+		return result;
+	}
+
+	wait_for_completion(&hif_drv->comp_test_key_block);
+	return 0;
+}
+
+int wilc_set_pmkid_info(struct wilc_vif *vif,
+			struct host_if_pmkid_attr *pmkid)
+{
+	int result = 0;
+	struct host_if_msg msg;
+	int i;
+
+	memset(&msg, 0, sizeof(struct host_if_msg));
+
+	msg.id = HOST_IF_MSG_KEY;
+	msg.body.key_info.type = PMKSA;
+	msg.body.key_info.action = ADDKEY;
+	msg.vif = vif;
+
+	for (i = 0; i < pmkid->numpmkid; i++) {
+		memcpy(msg.body.key_info.attr.pmkid.pmkidlist[i].bssid,
+		       &pmkid->pmkidlist[i].bssid, ETH_ALEN);
+		memcpy(msg.body.key_info.attr.pmkid.pmkidlist[i].pmkid,
+		       &pmkid->pmkidlist[i].pmkid, PMKID_LEN);
+	}
+
+	result = wilc_enqueue_cmd(&msg);
+	if (result)
+		PRINT_ER(vif->ndev, "PMKID Info\n");
+
+	return result;
+}
+
+int wilc_get_mac_address(struct wilc_vif *vif, u8 *mac_addr)
+{
+	int result = 0;
+	struct host_if_msg msg;
+
+	memset(&msg, 0, sizeof(struct host_if_msg));
+
+	msg.id = HOST_IF_MSG_GET_MAC_ADDRESS;
+	msg.body.dev_mac_info.mac_addr = mac_addr;
+	msg.vif = vif;
+
+	result = wilc_enqueue_cmd(&msg);
+	if (result) {
+		PRINT_ER(vif->ndev, "Failed to send get mac address\n");
+		return -EFAULT;
+	}
+
+	wait_for_completion(&hif_wait_response);
+	return result;
+}
+
+int wilc_set_mac_address(struct wilc_vif *vif, u8 *mac_addr)
+{
+	int result;
+	struct host_if_msg msg;
+
+	memset(&msg, 0, sizeof(struct host_if_msg));
+
+	msg.id = HOST_IF_MSG_SET_MAC_ADDRESS;
+	msg.body.dev_mac_info.mac_addr = mac_addr;
+	msg.vif = vif;
+
+	result = wilc_enqueue_cmd(&msg);
+	if (result) {
+		PRINT_ER(vif->ndev, "Failed to send get mac address\n");
+		return -EFAULT;
+	}
+
+	wait_for_completion(&hif_wait_response);
+	return result;
+}
+
+int wilc_set_join_req(struct wilc_vif *vif, u8 *bssid, const u8 *ssid,
+		      size_t ssid_len, const u8 *ies, size_t ies_len,
+		      wilc_connect_result connect_result, void *user_arg,
+		      u8 security, enum AUTHTYPE auth_type,
+		      u8 channel, void *join_params)
+{
+	int result = 0;
+	struct host_if_msg msg;
+	struct host_if_drv *hif_drv = vif->hif_drv;
+
+	if (!hif_drv || !connect_result) {
+		PRINT_ER(vif->ndev, "Driver is null\n");
+		return -EFAULT;
+	}
+
+	if (!join_params) {
+		PRINT_ER(vif->ndev, "Unable to Join - JoinParams is NULL\n");
+		return -EFAULT;
+	}
+
+	memset(&msg, 0, sizeof(struct host_if_msg));
+
+	msg.id = HOST_IF_MSG_CONNECT;
+
+	msg.body.con_info.security = security;
+	msg.body.con_info.auth_type = auth_type;
+	msg.body.con_info.ch = channel;
+	msg.body.con_info.result = connect_result;
+	msg.body.con_info.arg = user_arg;
+	msg.body.con_info.params = join_params;
+	msg.vif = vif;
+
+	if (bssid) {
+		msg.body.con_info.bssid = kmemdup(bssid, 6, GFP_KERNEL);
+		if (!msg.body.con_info.bssid)
+			return -ENOMEM;
+	}
+
+	if (ssid) {
+		msg.body.con_info.ssid_len = ssid_len;
+		msg.body.con_info.ssid = kmemdup(ssid, ssid_len, GFP_KERNEL);
+		if (!msg.body.con_info.ssid)
+			return -ENOMEM;
+	}
+
+	if (ies) {
+		msg.body.con_info.ies_len = ies_len;
+		msg.body.con_info.ies = kmemdup(ies, ies_len, GFP_KERNEL);
+		if (!msg.body.con_info.ies)
+			return -ENOMEM;
+	}
+	if (hif_drv->hif_state < HOST_IF_CONNECTING)
+		hif_drv->hif_state = HOST_IF_CONNECTING;
+	else
+		PRINT_INFO(vif->ndev, GENERIC_DBG, "Don't set state to 'connecting' as state is %d\n", hif_drv->hif_state);
+
+	result = wilc_enqueue_cmd(&msg);
+	if (result) {
+		PRINT_ER(vif->ndev, "send message: Set join request\n");
+		return -EFAULT;
+	}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,15,0)
+	hif_drv->connect_timer.data = (unsigned long)hif_drv;
+#endif
+	hif_drv->connect_timer_vif = vif;
+	mod_timer(&hif_drv->connect_timer,
+		  jiffies + msecs_to_jiffies(HOST_IF_CONNECT_TIMEOUT));
+
+	return result;
+}
+
+int wilc_disconnect(struct wilc_vif *vif, u16 reason_code)
+{
+	int result = 0;
+	struct host_if_msg msg;
+	struct host_if_drv *hif_drv = vif->hif_drv;
+
+	if (!hif_drv) {
+		PRINT_ER(vif->ndev, "Driver is null\n");
+		return -EFAULT;
+	}
+
+	memset(&msg, 0, sizeof(struct host_if_msg));
+
+	msg.id = HOST_IF_MSG_DISCONNECT;
+	msg.vif = vif;
+
+	result = wilc_enqueue_cmd(&msg);
+	if (result)
+		PRINT_ER(vif->ndev, "Failed to send message: disconnect\n");
+	else
+		wait_for_completion(&hif_drv->comp_test_disconn_block);
+
+	return result;
+}
+
+static s32 host_int_get_assoc_res_info(struct wilc_vif *vif,
+				       u8 *assoc_resp_info,
+				       u32 max_assoc_resp_info_len,
+				       u32 *rcvd_assoc_resp_info_len)
+{
+	s32 result = 0;
+	struct wid wid;
+
+	wid.id = (u16)WID_ASSOC_RES_INFO;
+	wid.type = WID_STR;
+	wid.val = assoc_resp_info;
+	wid.size = max_assoc_resp_info_len;
+
+	result = wilc_send_config_pkt(vif, GET_CFG, &wid, 1,
+				      wilc_get_vif_idx(vif));
+	if (result) {
+		*rcvd_assoc_resp_info_len = 0;
+		PRINT_ER(vif->ndev, "Failed to send association response\n");
+		return -EINVAL;
+	}
+
+	*rcvd_assoc_resp_info_len = wid.size;
+	return result;
+}
+
+int wilc_set_mac_chnl_num(struct wilc_vif *vif, u8 channel)
+{
+	int result;
+	struct host_if_msg msg;
+
+	memset(&msg, 0, sizeof(struct host_if_msg));
+	msg.id = HOST_IF_MSG_SET_CHANNEL;
+	msg.body.channel_info.set_ch = channel;
+	msg.vif = vif;
+
+	result = wilc_enqueue_cmd(&msg);
+	if (result) {
+		PRINT_ER(vif->ndev, "wilc mq send fail\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+int wilc_set_wfi_drv_handler(struct wilc_vif *vif, int index, u8 mode,
+			     u8 ifc_id)
+{
+	int result = 0;
+	struct host_if_msg msg;
+
+	memset(&msg, 0, sizeof(struct host_if_msg));
+	msg.id = HOST_IF_MSG_SET_WFIDRV_HANDLER;
+	msg.body.drv.handler = index;
+	msg.body.drv.mode = mode;
+	msg.body.drv.ifc_id = ifc_id;
+	msg.vif = vif;
+
+	result = wilc_enqueue_cmd(&msg);
+	if (result) {
+		PRINT_ER(vif->ndev, "wilc mq send fail\n");
+		result = -EINVAL;
+	}
+
+	return result;
+}
+
+int wilc_set_operation_mode(struct wilc_vif *vif, u32 mode)
+{
+	int result = 0;
+	struct host_if_msg msg;
+
+	memset(&msg, 0, sizeof(struct host_if_msg));
+	msg.id = HOST_IF_MSG_SET_OPERATION_MODE;
+	msg.body.mode.mode = mode;
+	msg.vif = vif;
+
+	result = wilc_enqueue_cmd(&msg);
+	if (result) {
+		PRINT_ER(vif->ndev, "wilc mq send fail\n");
+		result = -EINVAL;
+	}
+
+	return result;
+}
+
+s32 wilc_get_inactive_time(struct wilc_vif *vif, const u8 *mac,
+			   u32 *out_val)
+{
+	s32 result = 0;
+	struct host_if_msg msg;
+	struct host_if_drv *hif_drv = vif->hif_drv;
+
+	if (!hif_drv) {
+		PRINT_ER(vif->ndev, "driver is null\n");
+		return -EFAULT;
+	}
+
+	memset(&msg, 0, sizeof(struct host_if_msg));
+	memcpy(msg.body.mac_info.mac, mac, ETH_ALEN);
+
+	msg.id = HOST_IF_MSG_GET_INACTIVETIME;
+	msg.vif = vif;
+
+	result = wilc_enqueue_cmd(&msg);
+	if (result)
+		PRINT_ER(vif->ndev, "Failed to send get host ch param\n");
+	else
+		wait_for_completion(&hif_drv->comp_inactive_time);
+
+	*out_val = inactive_time;
+
+	return result;
+}
+
+int wilc_get_rssi(struct wilc_vif *vif, s8 *rssi_level)
+{
+	int result = 0;
+	struct host_if_msg msg;
+	struct host_if_drv *hif_drv = vif->hif_drv;
+
+	memset(&msg, 0, sizeof(struct host_if_msg));
+	msg.id = HOST_IF_MSG_GET_RSSI;
+	msg.vif = vif;
+
+	result = wilc_enqueue_cmd(&msg);
+	if (result) {
+		PRINT_ER(vif->ndev, "Failed to send get host ch param\n");
+		return -EFAULT;
+	}
+
+	wait_for_completion(&hif_drv->comp_get_rssi);
+
+	if (!rssi_level) {
+		PRINT_ER(vif->ndev, "RSS pointer value is null\n");
+		return -EFAULT;
+	}
+
+	*rssi_level = rssi;
+
+	return result;
+}
+
+int wilc_get_statistics(struct wilc_vif *vif, struct rf_info *stats)
+{
+	int result = 0;
+	struct host_if_msg msg;
+
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, " wilc_get_statistics \n");
+	memset(&msg, 0, sizeof(struct host_if_msg));
+	msg.id = HOST_IF_MSG_GET_STATISTICS;
+	msg.body.data = (char *)stats;
+	msg.vif = vif;
+
+	result = wilc_enqueue_cmd(&msg);
+	if (result) {
+		PRINT_ER(vif->ndev, "Failed to send get host channel\n");
+		return -EFAULT;
+	}
+
+	if (stats != &vif->wilc->dummy_statistics)
+		wait_for_completion(&hif_wait_response);
+	return result;
+}
+
+int wilc_scan(struct wilc_vif *vif, u8 scan_source, u8 scan_type,
+	      u8 *ch_freq_list, u8 ch_list_len, const u8 *ies,
+	      size_t ies_len, wilc_scan_result scan_result, void *user_arg,
+	      struct hidden_network *hidden_network)
+{
+	int result = 0;
+	struct host_if_msg msg;
+	struct scan_attr *scan_info = &msg.body.scan_info;
+	struct host_if_drv *hif_drv = vif->hif_drv;
+
+	if (!hif_drv || !scan_result) {
+		PRINT_ER(vif->ndev, "hif_drv or scan_result = NULL\n");
+		return -EFAULT;
+	}
+
+	memset(&msg, 0, sizeof(struct host_if_msg));
+
+	msg.id = HOST_IF_MSG_SCAN;
+
+	if (hidden_network) {
+		scan_info->hidden_network.net_info = hidden_network->net_info;
+		scan_info->hidden_network.n_ssids = hidden_network->n_ssids;
+	} else {
+		PRINT_WRN(vif->ndev, HOSTINF_DBG, "hidden_network IS EQUAL TO NULL\n");
+	}
+
+	msg.vif = vif;
+	scan_info->src = scan_source;
+	scan_info->type = scan_type;
+	scan_info->result = scan_result;
+	scan_info->arg = user_arg;
+
+	scan_info->ch_list_len = ch_list_len;
+	scan_info->ch_freq_list = kmemdup(ch_freq_list,
+					  ch_list_len,
+					  GFP_KERNEL);
+	if (!scan_info->ch_freq_list)
+		return -ENOMEM;
+
+	scan_info->ies_len = ies_len;
+	scan_info->ies = kmemdup(ies, ies_len, GFP_KERNEL);
+	if (!scan_info->ies)
+		return -ENOMEM;
+
+	result = wilc_enqueue_cmd(&msg);
+	if (result) {
+		PRINT_ER(vif->ndev, "Error in sending message queue\n");
+		return -EINVAL;
+	}
+
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, ">> Starting the SCAN timer\n");
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,15,0)
+	hif_drv->scan_timer.data = (unsigned long)hif_drv;
+#endif
+	hif_drv->scan_timer_vif = vif;
+	mod_timer(&hif_drv->scan_timer,
+		  jiffies + msecs_to_jiffies(HOST_IF_SCAN_TIMEOUT));
+
+	return result;
+}
+
+int wilc_hif_set_cfg(struct wilc_vif *vif,
+		     struct cfg_param_attr *cfg_param)
+{
+	struct host_if_msg msg;
+	struct host_if_drv *hif_drv = vif->hif_drv;
+
+	if (!hif_drv) {
+		PRINT_ER(vif->ndev, "hif_drv NULL\n");
+		return -EFAULT;
+	}
+
+	memset(&msg, 0, sizeof(struct host_if_msg));
+	msg.id = HOST_IF_MSG_CFG_PARAMS;
+	msg.body.cfg_info = *cfg_param;
+	msg.vif = vif;
+
+	return wilc_enqueue_cmd(&msg);
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,15,0)
+static void get_periodic_rssi(struct timer_list *unused)
+#else
+static void get_periodic_rssi(unsigned long arg)
+#endif
+{
+	struct wilc_vif *vif = periodic_rssi_vif;
+
+	if (!vif->hif_drv) {
+		PRINT_ER(vif->ndev, "Driver handler is NULL\n");
+		return;
+	}
+
+	if (vif->hif_drv->hif_state == HOST_IF_CONNECTED)
+		wilc_get_statistics(vif, &vif->wilc->dummy_statistics);
+
+	mod_timer(&periodic_rssi, jiffies + msecs_to_jiffies(5000));
+}
+
+int wilc_init(struct net_device *dev, struct host_if_drv **hif_drv_handler)
+{
+	struct host_if_drv *hif_drv;
+	struct wilc_vif *vif;
+	struct wilc *wilc;
+	int i;
+
+	vif = netdev_priv(dev);
+	wilc = vif->wilc;
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "Initializing host interface for client %d\n",
+		   clients_count + 1);
+
+	hif_drv  = kzalloc(sizeof(*hif_drv), GFP_KERNEL);
+	if (!hif_drv) {
+		PRINT_ER(dev, "Driver is null\n");
+		return -ENOMEM;
+	}
+	*hif_drv_handler = hif_drv;
+	for (i = 0; i <= wilc->vif_num; i++)
+		if (dev == wilc->vif[i]->ndev) {
+			wilc->vif[i]->hif_drv = hif_drv;
+			hif_drv->driver_handler_id = i + 1;
+			break;
+		}
+	
+#ifdef DISABLE_PWRSAVE_AND_SCAN_DURING_IP
+
+	wilc_optaining_ip = false;
+#endif
+
+	if (clients_count == 0)	{
+		init_completion(&hif_thread_comp);
+		init_completion(&hif_driver_comp);
+		mutex_init(&hif_deinit_lock);
+	}
+
+	init_completion(&hif_wait_response);
+	init_completion(&hif_drv->comp_test_key_block);
+	init_completion(&hif_drv->comp_test_disconn_block);
+	init_completion(&hif_drv->comp_get_rssi);
+	init_completion(&hif_drv->comp_inactive_time);
+
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "INIT: CLIENT COUNT %d\n", 
+				clients_count);
+	if (clients_count == 0) {
+		hif_workqueue = create_singlethread_workqueue("WILC_wq");
+		if (!hif_workqueue) {
+			PRINT_ER(vif->ndev, "Failed to create workqueue\n");
+			return -ENOMEM;
+		}
+
+		periodic_rssi_vif = vif;
+	#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,15,0)
+		timer_setup(&periodic_rssi, get_periodic_rssi, 0);
+	#else
+		setup_timer(&periodic_rssi, get_periodic_rssi, (unsigned long)vif);
+	#endif
+		mod_timer(&periodic_rssi, jiffies + msecs_to_jiffies(5000));
+	}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,15,0)
+	timer_setup(&hif_drv->scan_timer, timer_scan_cb, 0);
+	timer_setup(&hif_drv->connect_timer, timer_connect_cb, 0);
+	timer_setup(&hif_drv->remain_on_ch_timer, listen_timer_cb, 0);
+#else
+	setup_timer(&hif_drv->scan_timer, timer_scan_cb, 0);
+	setup_timer(&hif_drv->connect_timer, timer_connect_cb, 0);
+	setup_timer(&hif_drv->remain_on_ch_timer, listen_timer_cb, 0);
+#endif
+
+	mutex_init(&hif_drv->cfg_values_lock);
+	mutex_lock(&hif_drv->cfg_values_lock);
+
+	hif_drv->hif_state = HOST_IF_IDLE;
+	hif_drv->cfg_values.site_survey_enabled = SITE_SURVEY_OFF;
+	hif_drv->cfg_values.scan_source = DEFAULT_SCAN;
+	hif_drv->cfg_values.active_scan_time = ACTIVE_SCAN_TIME;
+	hif_drv->cfg_values.passive_scan_time = PASSIVE_SCAN_TIME;
+	hif_drv->cfg_values.curr_tx_rate = AUTORATE;
+
+	hif_drv->p2p_timeout = 0;
+
+	PRINT_D(vif->ndev, HOSTINF_DBG,"Initialization values, Site survey value: %d\nScan source: %d\nActive scan time: %d\nPassive scan time: %d\nCurrent tx Rate = %d\n",
+		hif_drv->cfg_values.site_survey_enabled,
+		hif_drv->cfg_values.scan_source,
+		hif_drv->cfg_values.active_scan_time,
+		hif_drv->cfg_values.passive_scan_time,
+		hif_drv->cfg_values.curr_tx_rate);
+	mutex_unlock(&hif_drv->cfg_values_lock);
+
+	clients_count++;
+
+	return 0;
+}
+
+int wilc_deinit(struct wilc_vif *vif)
+{
+	int result = 0;
+	struct host_if_msg msg;
+	struct host_if_drv *hif_drv = vif->hif_drv;
+
+	if (!hif_drv)	{
+		PRINT_ER(vif->ndev, "hif_drv = NULL\n");
+		return -EFAULT;
+	}
+
+	mutex_lock(&hif_deinit_lock);
+
+	terminated_handle = hif_drv;
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, 
+		   "De-initializing host interface for client %d\n",
+		   clients_count);
+
+	del_timer_sync(&hif_drv->scan_timer);
+	del_timer_sync(&hif_drv->connect_timer);
+	del_timer_sync(&periodic_rssi);
+	del_timer_sync(&hif_drv->remain_on_ch_timer);
+
+	wilc_set_wfi_drv_handler(vif, 0, vif->iftype, vif->ifc_id);
+	wait_for_completion(&hif_driver_comp);
+
+	if (hif_drv->usr_scan_req.scan_result) {
+		hif_drv->usr_scan_req.scan_result(SCAN_EVENT_ABORTED, NULL,
+						  hif_drv->usr_scan_req.arg,
+						  NULL);
+		hif_drv->usr_scan_req.scan_result = NULL;
+	}
+
+	hif_drv->hif_state = HOST_IF_IDLE;
+
+	memset(wilc_connected_ssid, 0, ETH_ALEN);
+
+	memset(&msg, 0, sizeof(struct host_if_msg));
+
+	if (clients_count == 1)	{
+		msg.id = HOST_IF_MSG_EXIT;
+		msg.vif = vif;
+
+		result = wilc_enqueue_cmd(&msg);
+		if (result != 0)
+			PRINT_ER(vif->ndev, "deinit : Error(%d)\n", result);
+		else
+			wait_for_completion(&hif_thread_comp);
+		flush_workqueue(hif_workqueue);
+		destroy_workqueue(hif_workqueue);
+		hif_workqueue = NULL;
+	}
+
+	kfree(hif_drv);
+
+	clients_count--;
+	terminated_handle = NULL;
+	mutex_unlock(&hif_deinit_lock);
+	return result;
+}
+
+void wilc_network_info_received(struct wilc *wilc, u8 *buffer, u32 length)
+{
+	s32 result = 0;
+	struct host_if_msg msg;
+	int id;
+	struct host_if_drv *hif_drv = NULL;
+	struct wilc_vif *vif;
+
+	id = buffer[length - 4];
+	id |= (buffer[length - 3] << 8);
+	id |= (buffer[length - 2] << 16);
+	id |= (buffer[length - 1] << 24);
+	vif = wilc_get_vif_from_idx(wilc, id);
+	if (!vif)
+		return;
+	hif_drv = vif->hif_drv;
+
+	if (!hif_drv || hif_drv == terminated_handle)	{
+		PRINT_ER(vif->ndev, "driver not init[%p]\n", hif_drv);
+		return;
+	}
+
+	memset(&msg, 0, sizeof(struct host_if_msg));
+
+	msg.id = HOST_IF_MSG_RCVD_NTWRK_INFO;
+	msg.vif = vif;
+
+	msg.body.net_info.len = length;
+	msg.body.net_info.buffer = kmemdup(buffer, length, GFP_KERNEL);
+	if (!msg.body.net_info.buffer)
+		return;
+
+	result = wilc_enqueue_cmd(&msg);
+	if (result) {
+		PRINT_ER(vif->ndev, "message parameters (%d)\n", result);
+		kfree(msg.body.net_info.buffer);
+	}
+}
+
+void wilc_gnrl_async_info_received(struct wilc *wilc, u8 *buffer, u32 length)
+{
+	s32 result = 0;
+	struct host_if_msg msg;
+	int id;
+	struct host_if_drv *hif_drv = NULL;
+	struct wilc_vif *vif;
+
+	mutex_lock(&hif_deinit_lock);
+
+	id = buffer[length - 4];
+	id |= (buffer[length - 3] << 8);
+	id |= (buffer[length - 2] << 16);
+	id |= (buffer[length - 1] << 24);
+	vif = wilc_get_vif_from_idx(wilc, id);
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "General asynchronous info packet received\n");
+	if (!vif) {
+		mutex_unlock(&hif_deinit_lock);
+		return;
+	}
+
+	hif_drv = vif->hif_drv;
+
+	if (!hif_drv || hif_drv == terminated_handle) {
+		PRINT_ER(vif->ndev, "hif_drv = NULL\n");
+		mutex_unlock(&hif_deinit_lock);
+		return;
+	}
+
+	if (!hif_drv->usr_conn_req.conn_result) {
+		PRINT_ER(vif->ndev, "there is no current Connect Request\n");
+		mutex_unlock(&hif_deinit_lock);
+		return;
+	}
+
+	memset(&msg, 0, sizeof(struct host_if_msg));
+
+	msg.id = HOST_IF_MSG_RCVD_GNRL_ASYNC_INFO;
+	msg.vif = vif;
+
+	msg.body.async_info.len = length;
+	msg.body.async_info.buffer = kmemdup(buffer, length, GFP_KERNEL);
+	if (!msg.body.async_info.buffer) {
+		mutex_unlock(&hif_deinit_lock);
+		return;
+	}
+
+	result = wilc_enqueue_cmd(&msg);
+	if (result) {
+		PRINT_ER(vif->ndev, "synchronous info (%d)\n", result);
+		kfree(msg.body.async_info.buffer);
+	}
+
+	mutex_unlock(&hif_deinit_lock);
+}
+
+void wilc_scan_complete_received(struct wilc *wilc, u8 *buffer, u32 length)
+{
+	s32 result = 0;
+	struct host_if_msg msg;
+	int id;
+	struct host_if_drv *hif_drv = NULL;
+	struct wilc_vif *vif;
+
+	id = buffer[length - 4];
+	id |= buffer[length - 3] << 8;
+	id |= buffer[length - 2] << 16;
+	id |= buffer[length - 1] << 24;
+	vif = wilc_get_vif_from_idx(wilc, id);
+	if (!vif)
+		return;
+	hif_drv = vif->hif_drv;
+	PRINT_INFO(vif->ndev, GENERIC_DBG, "Scan notification received\n");
+
+	if (!hif_drv || hif_drv == terminated_handle) {
+		PRINT_ER(vif->ndev, "hif_drv = NULL\n");
+		return;
+	}
+
+	if (hif_drv->usr_scan_req.scan_result) {
+		memset(&msg, 0, sizeof(struct host_if_msg));
+
+		msg.id = HOST_IF_MSG_RCVD_SCAN_COMPLETE;
+		msg.vif = vif;
+
+		result = wilc_enqueue_cmd(&msg);
+		if (result)
+			PRINT_ER(vif->ndev, "complete param (%d)\n", result);
+	}
+}
+
+int wilc_remain_on_channel(struct wilc_vif *vif, u32 session_id,
+			   u32 duration, u16 chan,
+			   wilc_remain_on_chan_expired expired,
+			   wilc_remain_on_chan_ready ready,
+			   void *user_arg)
+{
+	int result = 0;
+	struct host_if_msg msg;
+
+	memset(&msg, 0, sizeof(struct host_if_msg));
+
+	msg.id = HOST_IF_MSG_REMAIN_ON_CHAN;
+	msg.body.remain_on_ch.ch = chan;
+	msg.body.remain_on_ch.expired = expired;
+	msg.body.remain_on_ch.ready = ready;
+	msg.body.remain_on_ch.arg = user_arg;
+	msg.body.remain_on_ch.duration = duration;
+	msg.body.remain_on_ch.id = session_id;
+	msg.vif = vif;
+
+	result = wilc_enqueue_cmd(&msg);
+	if (result)
+		PRINT_ER(vif->ndev, "wilc mq send fail\n");
+
+	return result;
+}
+
+int wilc_listen_state_expired(struct wilc_vif *vif, u32 session_id)
+{
+	int result = 0;
+	struct host_if_msg msg;
+	struct host_if_drv *hif_drv = vif->hif_drv;
+
+	if (!hif_drv) {
+		PRINT_ER(vif->ndev, "Driver is null\n");
+		return -EFAULT;
+	}
+
+	del_timer(&hif_drv->remain_on_ch_timer);
+
+	memset(&msg, 0, sizeof(struct host_if_msg));
+	msg.id = HOST_IF_MSG_LISTEN_TIMER_FIRED;
+	msg.vif = vif;
+	msg.body.remain_on_ch.id = session_id;
+
+	result = wilc_enqueue_cmd(&msg);
+	if (result)
+		PRINT_ER(vif->ndev, "wilc mq send fail\n");
+
+	return result;
+}
+
+int wilc_frame_register(struct wilc_vif *vif, u16 frame_type, bool reg)
+{
+	int result = 0;
+	struct host_if_msg msg;
+
+	memset(&msg, 0, sizeof(struct host_if_msg));
+
+	msg.id = HOST_IF_MSG_REGISTER_FRAME;
+	switch (frame_type) {
+	case ACTION:
+		PRINT_INFO(vif->ndev, HOSTINF_DBG, "ACTION\n");
+		msg.body.reg_frame.reg_id = ACTION_FRM_IDX;
+		break;
+
+	case PROBE_REQ:
+		PRINT_INFO(vif->ndev, HOSTINF_DBG, "PROBE REQ\n");
+		msg.body.reg_frame.reg_id = PROBE_REQ_IDX;
+		break;
+
+	default:
+		PRINT_INFO(vif->ndev, HOSTINF_DBG, "Not valid frame type\n");
+		break;
+	}
+	msg.body.reg_frame.frame_type = frame_type;
+	msg.body.reg_frame.reg = reg;
+	msg.vif = vif;
+
+	result = wilc_enqueue_cmd(&msg);
+	if (result)
+		PRINT_ER(vif->ndev, "wilc mq send fail\n");
+
+	return result;
+}
+
+int wilc_add_beacon(struct wilc_vif *vif, u32 interval, u32 dtim_period,
+		    u32 head_len, u8 *head, u32 tail_len, u8 *tail)
+{
+	int result = 0;
+	struct host_if_msg msg;
+	struct beacon_attr *beacon_info = &msg.body.beacon_info;
+
+	memset(&msg, 0, sizeof(struct host_if_msg));
+
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "Setting adding beacon message queue params\n");
+	msg.id = HOST_IF_MSG_ADD_BEACON;
+	msg.vif = vif;
+	beacon_info->interval = interval;
+	beacon_info->dtim_period = dtim_period;
+	beacon_info->head_len = head_len;
+	beacon_info->head = kmemdup(head, head_len, GFP_KERNEL);
+	if (!beacon_info->head) {
+		result = -ENOMEM;
+		goto error;
+	}
+	beacon_info->tail_len = tail_len;
+
+	if (tail_len > 0) {
+		beacon_info->tail = kmemdup(tail, tail_len, GFP_KERNEL);
+		if (!beacon_info->tail) {
+			result = -ENOMEM;
+			goto error;
+		}
+	} else {
+		beacon_info->tail = NULL;
+	}
+
+	result = wilc_enqueue_cmd(&msg);
+	if (result)
+		PRINT_ER(vif->ndev, "wilc mq send fail\n");
+
+error:
+	if (result) {
+		kfree(beacon_info->head);
+
+		kfree(beacon_info->tail);
+	}
+
+	return result;
+}
+
+int wilc_del_beacon(struct wilc_vif *vif)
+{
+	int result = 0;
+	struct host_if_msg msg;
+
+	msg.id = HOST_IF_MSG_DEL_BEACON;
+	msg.vif = vif;
+	PRINT_INFO(vif->ndev, HOSTINF_DBG,
+		   "Setting deleting beacon message queue params\n");
+
+	result = wilc_enqueue_cmd(&msg);
+	if (result)
+		PRINT_ER(vif->ndev, "wilc_mq_send fail\n");
+
+	return result;
+}
+
+int wilc_add_station(struct wilc_vif *vif, struct add_sta_param *sta_param)
+{
+	int result = 0;
+	struct host_if_msg msg;
+	struct add_sta_param *add_sta_info = &msg.body.add_sta_info;
+
+	memset(&msg, 0, sizeof(struct host_if_msg));
+
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "Setting adding station message queue params\n");
+	msg.id = HOST_IF_MSG_ADD_STATION;
+	msg.vif = vif;
+
+	memcpy(add_sta_info, sta_param, sizeof(struct add_sta_param));
+	if (add_sta_info->rates_len > 0) {
+		add_sta_info->rates = kmemdup(sta_param->rates,
+					      add_sta_info->rates_len,
+					      GFP_KERNEL);
+		if (!add_sta_info->rates)
+			return -ENOMEM;
+	}
+
+	result = wilc_enqueue_cmd(&msg);
+	if (result) {
+		PRINT_ER(vif->ndev, "wilc_mq_send fail\n");
+		kfree(add_sta_info->rates);
+	}
+	return result;
+}
+
+int wilc_del_station(struct wilc_vif *vif, const u8 *mac_addr)
+{
+	int result = 0;
+	struct host_if_msg msg;
+	struct del_sta *del_sta_info = &msg.body.del_sta_info;
+
+	memset(&msg, 0, sizeof(struct host_if_msg));
+
+	PRINT_INFO(vif->ndev, HOSTINF_DBG,
+		   "Setting deleting station message queue params\n");
+	msg.id = HOST_IF_MSG_DEL_STATION;
+	msg.vif = vif;
+
+	if (!mac_addr)
+		eth_broadcast_addr(del_sta_info->mac_addr);
+	else
+		memcpy(del_sta_info->mac_addr, mac_addr, ETH_ALEN);
+
+	result = wilc_enqueue_cmd(&msg);
+	if (result)
+		PRINT_ER(vif->ndev, "wilc_mq_send fail\n");
+	return result;
+}
+
+int wilc_del_allstation(struct wilc_vif *vif, u8 mac_addr[][ETH_ALEN])
+{
+	int result = 0;
+	struct host_if_msg msg;
+	struct del_all_sta *del_all_sta_info = &msg.body.del_all_sta_info;
+	u8 zero_addr[ETH_ALEN] = {0};
+	int i;
+	u8 assoc_sta = 0;
+
+	memset(&msg, 0, sizeof(struct host_if_msg));
+
+	PRINT_INFO(vif->ndev, HOSTINF_DBG,
+		   "Setting deauthenticating station message queue params\n");
+	msg.id = HOST_IF_MSG_DEL_ALL_STA;
+	msg.vif = vif;
+
+	for (i = 0; i < MAX_NUM_STA; i++) {
+		if (memcmp(mac_addr[i], zero_addr, ETH_ALEN)) {
+			memcpy(del_all_sta_info->del_all_sta[i], mac_addr[i],
+			       ETH_ALEN);
+			PRINT_INFO(vif->ndev,
+				   CFG80211_DBG, "BSSID = %x%x%x%x%x%x\n",
+				   del_all_sta_info->del_all_sta[i][0],
+				   del_all_sta_info->del_all_sta[i][1],
+				   del_all_sta_info->del_all_sta[i][2],
+				   del_all_sta_info->del_all_sta[i][3],
+				   del_all_sta_info->del_all_sta[i][4],
+				   del_all_sta_info->del_all_sta[i][5]);
+			assoc_sta++;
+		}
+	}
+	if (!assoc_sta) {
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "NO ASSOCIATED STAS\n");
+		return result;
+	}
+
+	del_all_sta_info->assoc_sta = assoc_sta;
+	result = wilc_enqueue_cmd(&msg);
+
+	if (result)
+		PRINT_ER(vif->ndev, "wilc_mq_send fail\n");
+	else
+		wait_for_completion(&hif_wait_response);
+
+	return result;
+}
+
+int wilc_edit_station(struct wilc_vif *vif,
+		      struct add_sta_param *sta_param)
+{
+	int result = 0;
+	struct host_if_msg msg;
+	struct add_sta_param *add_sta_info = &msg.body.add_sta_info;
+
+	PRINT_INFO(vif->ndev, HOSTINF_DBG,
+		   "Setting editing station message queue params\n");
+	memset(&msg, 0, sizeof(struct host_if_msg));
+
+	msg.id = HOST_IF_MSG_EDIT_STATION;
+	msg.vif = vif;
+
+	memcpy(add_sta_info, sta_param, sizeof(struct add_sta_param));
+	if (add_sta_info->rates_len > 0) {
+		add_sta_info->rates = kmemdup(sta_param->rates,
+					      add_sta_info->rates_len,
+					      GFP_KERNEL);
+		if (!add_sta_info->rates)
+			return -ENOMEM;
+	}
+
+	result = wilc_enqueue_cmd(&msg);
+	if (result) {
+		PRINT_ER(vif->ndev, "wilc_mq_send fail\n");
+		kfree(add_sta_info->rates);
+	}
+
+	return result;
+}
+
+int wilc_set_power_mgmt(struct wilc_vif *vif, bool enabled, u32 timeout)
+{
+	int result = 0;
+	struct host_if_msg msg;
+	struct power_mgmt_param *pwr_mgmt_info = &msg.body.pwr_mgmt_info;
+
+	if (wilc_wlan_get_num_conn_ifcs(vif->wilc) == 2 && enabled)
+		return 0;
+
+	PRINT_INFO(vif->ndev, HOSTINF_DBG, "\n\n>> Setting PS to %d <<\n\n",
+		   enabled);
+	memset(&msg, 0, sizeof(struct host_if_msg));
+
+	msg.id = HOST_IF_MSG_POWER_MGMT;
+	msg.vif = vif;
+
+	pwr_mgmt_info->enabled = enabled;
+	pwr_mgmt_info->timeout = timeout;
+
+	if(!hif_workqueue)
+		return 0;
+
+	result = wilc_enqueue_cmd(&msg);
+	if (result)
+		PRINT_ER(vif->ndev, "wilc_mq_send fail\n");
+	return result;
+}
+
+int wilc_setup_multicast_filter(struct wilc_vif *vif, bool enabled,
+				u32 count)
+{
+	int result = 0;
+	struct host_if_msg msg;
+	struct set_multicast *multicast_filter_param = &msg.body.multicast_info;
+
+	PRINT_INFO(vif->ndev, HOSTINF_DBG,
+		   "Setting Multicast Filter params\n");
+	memset(&msg, 0, sizeof(struct host_if_msg));
+
+	msg.id = HOST_IF_MSG_SET_MULTICAST_FILTER;
+	msg.vif = vif;
+
+	multicast_filter_param->enabled = enabled;
+	multicast_filter_param->cnt = count;
+
+	result = wilc_enqueue_cmd(&msg);
+	if (result)
+		PRINT_ER(vif->ndev, "wilc_mq_send fail\n");
+	return result;
+}
+
+static void *host_int_parse_join_bss_param(struct network_info *info)
+{
+	struct join_bss_param *param = NULL;
+	u8 *ies;
+	u16 ies_len;
+	u16 index = 0;
+	u8 rates_no = 0;
+	u8 ext_rates_no;
+	u16 offset;
+	u8 pcipher_cnt;
+	u8 auth_cnt;
+	u8 pcipher_total_cnt = 0;
+	u8 auth_total_cnt = 0;
+	u8 i, j;
+
+	ies = info->ies;
+	ies_len = info->ies_len;
+
+	param = kzalloc(sizeof(*param), GFP_KERNEL);
+	if (!param)
+		return NULL;
+
+	param->dtim_period = info->dtim_period;
+	param->beacon_period = info->beacon_period;
+	param->cap_info = info->cap_info;
+	memcpy(param->bssid, info->bssid, 6);
+	memcpy((u8 *)param->ssid, info->ssid, info->ssid_len + 1);
+	param->ssid_len = info->ssid_len;
+	memset(param->rsn_pcip_policy, 0xFF, 3);
+	memset(param->rsn_auth_policy, 0xFF, 3);
+
+	while (index < ies_len) {
+		if (ies[index] == SUPP_RATES_IE) {
+			rates_no = ies[index + 1];
+			param->supp_rates[0] = rates_no;
+			index += 2;
+
+			for (i = 0; i < rates_no; i++)
+				param->supp_rates[i + 1] = ies[index + i];
+
+			index += rates_no;
+		} else if (ies[index] == EXT_SUPP_RATES_IE) {
+			ext_rates_no = ies[index + 1];
+			if (ext_rates_no > (MAX_RATES_SUPPORTED - rates_no))
+				param->supp_rates[0] = MAX_RATES_SUPPORTED;
+			else
+				param->supp_rates[0] += ext_rates_no;
+			index += 2;
+			for (i = 0; i < (param->supp_rates[0] - rates_no); i++)
+				param->supp_rates[rates_no + i + 1] = ies[index + i];
+
+			index += ext_rates_no;
+		} else if (ies[index] == HT_CAPABILITY_IE) {
+			param->ht_capable = true;
+			index += ies[index + 1] + 2;
+		} else if ((ies[index] == WMM_IE) &&
+			   (ies[index + 2] == 0x00) && (ies[index + 3] == 0x50) &&
+			   (ies[index + 4] == 0xF2) &&
+			   (ies[index + 5] == 0x02) &&
+			   ((ies[index + 6] == 0x00) || (ies[index + 6] == 0x01)) &&
+			   (ies[index + 7] == 0x01)) {
+			param->wmm_cap = true;
+
+			if (ies[index + 8] & BIT(7))
+				param->uapsd_cap = true;
+			index += ies[index + 1] + 2;
+		} else if ((ies[index] == P2P_IE) &&
+			 (ies[index + 2] == 0x50) && (ies[index + 3] == 0x6f) &&
+			 (ies[index + 4] == 0x9a) &&
+			 (ies[index + 5] == 0x09) && (ies[index + 6] == 0x0c)) {
+			u16 p2p_cnt;
+
+			param->tsf = info->tsf_lo;
+			param->noa_enabled = 1;
+			param->idx = ies[index + 9];
+
+			if (ies[index + 10] & BIT(7)) {
+				param->opp_enabled = 1;
+				param->ct_window = ies[index + 10];
+			} else {
+				param->opp_enabled = 0;
+			}
+
+			param->cnt = ies[index + 11];
+			p2p_cnt = index + 12;
+
+			memcpy(param->duration, ies + p2p_cnt, 4);
+			p2p_cnt += 4;
+
+			memcpy(param->interval, ies + p2p_cnt, 4);
+			p2p_cnt += 4;
+
+			memcpy(param->start_time, ies + p2p_cnt, 4);
+
+			index += ies[index + 1] + 2;
+		} else if ((ies[index] == RSN_IE) ||
+			 ((ies[index] == WPA_IE) && (ies[index + 2] == 0x00) &&
+			  (ies[index + 3] == 0x50) && (ies[index + 4] == 0xF2) &&
+			  (ies[index + 5] == 0x01)))	{
+			u16 rsn_idx = index;
+
+			if (ies[rsn_idx] == RSN_IE)	{
+				param->mode_802_11i = 2;
+			} else {
+				if (param->mode_802_11i == 0)
+					param->mode_802_11i = 1;
+				rsn_idx += 4;
+			}
+
+			rsn_idx += 7;
+			param->rsn_grp_policy = ies[rsn_idx];
+			rsn_idx++;
+			offset = ies[rsn_idx] * 4;
+			pcipher_cnt = (ies[rsn_idx] > 3) ? 3 : ies[rsn_idx];
+			rsn_idx += 2;
+
+			for (i = pcipher_total_cnt, j = 0; i < pcipher_cnt + pcipher_total_cnt && i < 3; i++, j++)
+				param->rsn_pcip_policy[i] = ies[rsn_idx + ((j + 1) * 4) - 1];
+
+			pcipher_total_cnt += pcipher_cnt;
+			rsn_idx += offset;
+
+			offset = ies[rsn_idx] * 4;
+
+			auth_cnt = (ies[rsn_idx] > 3) ? 3 : ies[rsn_idx];
+			rsn_idx += 2;
+
+			for (i = auth_total_cnt, j = 0; i < auth_total_cnt + auth_cnt; i++, j++)
+				param->rsn_auth_policy[i] = ies[rsn_idx + ((j + 1) * 4) - 1];
+
+			auth_total_cnt += auth_cnt;
+			rsn_idx += offset;
+
+			if (ies[index] == RSN_IE) {
+				param->rsn_cap[0] = ies[rsn_idx];
+				param->rsn_cap[1] = ies[rsn_idx + 1];
+				rsn_idx += 2;
+			}
+			param->rsn_found = true;
+			index += ies[index + 1] + 2;
+		} else {
+			index += ies[index + 1] + 2;
+		}
+	}
+
+	return (void *)param;
+}
+
+int wilc_set_tx_power(struct wilc_vif *vif, u8 tx_power)
+{
+	int ret = 0;
+	struct host_if_msg msg;
+
+	memset(&msg, 0, sizeof(struct host_if_msg));
+
+	msg.id = HOST_IF_MSG_SET_TX_POWER;
+	msg.body.tx_power.tx_pwr = tx_power;
+	msg.vif = vif;
+
+	ret = wilc_enqueue_cmd(&msg);
+	if (ret)
+		PRINT_ER(vif->ndev, "wilc_mq_send fail\n");
+
+	return ret;
+}
+
+int wilc_get_tx_power(struct wilc_vif *vif, u8 *tx_power)
+{
+	int ret = 0;
+	struct host_if_msg msg;
+
+	memset(&msg, 0, sizeof(struct host_if_msg));
+
+	msg.id = HOST_IF_MSG_GET_TX_POWER;
+	msg.vif = vif;
+
+	ret = wilc_enqueue_cmd(&msg);
+	if (ret)
+		PRINT_ER(vif->ndev, "Failed to get TX PWR\n");
+
+	wait_for_completion(&hif_wait_response);
+	*tx_power = msg.body.tx_power.tx_pwr;
+
+	return ret;
+}
+
+bool is_valid_gpio(struct wilc_vif *vif, u8 gpio)
+{
+	switch(vif->wilc->chip) {
+	case WILC_1000:
+		if(gpio == 0 || gpio == 1 || gpio == 4 || gpio == 6)
+			return true;
+		else
+			return false;
+	case WILC_3000:
+		if(gpio == 0 || gpio == 3 || gpio == 4 ||
+			(gpio >= 17 && gpio <= 20))
+			return true;
+		else
+			return false;
+	default:
+		return false;
+	}
+}
+
+int wilc_set_antenna(struct wilc_vif *vif, u8 mode)
+{
+	int ret = 0;
+	struct host_if_msg msg;
+	sysfs_attr_group *attr_syfs_p;
+
+	memset(&msg, 0, sizeof(struct host_if_msg));
+
+	msg.id = HOST_IF_MSG_SET_ANTENNA_MODE;
+
+	msg.vif = vif;
+	msg.body.set_ant.mode = mode;
+	attr_syfs_p = &vif->attr_sysfs;
+
+	if(attr_syfs_p->ant_swtch_mode == ANT_SWTCH_INVALID_GPIO_CTRL) {
+		PRINT_ER(vif->ndev, "Ant switch GPIO mode is invalid.\n");
+		PRINT_ER(vif->ndev, "Set it using /sys/wilc/ant_swtch_mode\n");
+		return WILC_FAIL;
+	}
+
+	if (is_valid_gpio(vif, attr_syfs_p->antenna1)) { 
+		msg.body.set_ant.antenna1 = attr_syfs_p->antenna1;
+	} else {
+		PRINT_ER(vif->ndev, "Invalid GPIO%d\n", attr_syfs_p->antenna1);
+		return WILC_FAIL;
+	}
+
+	if (attr_syfs_p->ant_swtch_mode == ANT_SWTCH_DUAL_GPIO_CTRL) {
+		if ((attr_syfs_p->antenna2 != attr_syfs_p->antenna1) &&
+			is_valid_gpio(vif, attr_syfs_p->antenna2)) {
+			msg.body.set_ant.antenna2 = attr_syfs_p->antenna2;
+		} else {
+			PRINT_ER(vif->ndev, "Invalid GPIO %d\n", 
+				 attr_syfs_p->antenna2);
+			return WILC_FAIL;
+		}
+	}
+
+	msg.body.set_ant.gpio_mode = attr_syfs_p->ant_swtch_mode;
+	ret = wilc_enqueue_cmd(&msg);
+	if(ret) {
+		PRINT_ER(vif->ndev,
+			 "Failed to send get host channel param's message queue ");
+		return -EINVAL;
+	}	
+	return ret;
+}
+
+int host_int_set_wowlan_trigger(struct wilc_vif *vif, u8 wowlan_trigger)
+{
+	int result = 0;
+	struct host_if_msg msg;
+
+	memset(&msg, 0, sizeof(struct host_if_msg));
+	msg.id = HOST_IF_MSG_SET_WOWLAN_TRIGGER;
+	msg.body.wow_trigger.wowlan_trigger = wowlan_trigger;
+	msg.vif = vif;
+
+	result = wilc_enqueue_cmd(&msg);
+
+	if(result)
+		PRINT_ER(vif->ndev,
+			 "Failed to enq wowlan trigger req\n");
+	return result;
+}	
diff --git a/drivers/staging/wilc1000/host_interface.h b/drivers/staging/wilc/host_interface.h
similarity index 88%
rename from drivers/staging/wilc1000/host_interface.h
rename to drivers/staging/wilc/host_interface.h
index 44a2f4b..f63dc25 100644
--- a/drivers/staging/wilc1000/host_interface.h
+++ b/drivers/staging/wilc/host_interface.h
@@ -11,9 +11,13 @@
 #define STATION_MODE	0x02
 #define GO_MODE		0x03
 #define CLIENT_MODE	0x04
-#define ACTION		0xD0
-#define PROBE_REQ	0x40
-#define PROBE_RESP	0x50
+
+#define P2P_IFC		0x00
+#define WLAN_IFC	0x01
+#define DEFAULT_IFC	0x03
+
+#define IFC_0 "wlan0"
+#define IFC_1 "p2p0"
 
 #define ACTION_FRM_IDX				0
 #define PROBE_REQ_IDX				1
@@ -49,7 +53,6 @@
 #define PMKID_LEN				16
 #define WILC_MAX_NUM_PMKIDS			16
 #define WILC_ADD_STA_LENGTH			40
-#define SCAN_EVENT_DONE_ABORTED
 #define NUM_CONCURRENT_IFC			2
 #define DRV_HANDLER_SIZE			5
 #define DRV_HANDLER_MASK			0x000000FF
@@ -182,6 +185,10 @@ typedef void (*wilc_connect_result)(enum conn_event,
 typedef void (*wilc_remain_on_chan_expired)(void *, u32);
 typedef void (*wilc_remain_on_chan_ready)(void *);
 
+typedef void (*wilc_frmw_to_linux_t)(struct wilc *, u8 *, unsigned int,
+				     unsigned int, u8);
+typedef void (*free_eap_buf_param)(void *);
+
 struct rcvd_net_info {
 	u8 *buffer;
 	u32 len;
@@ -220,14 +227,14 @@ struct user_conn_req {
 struct drv_handler {
 	u32 handler;
 	u8 mode;
-	u8 name;
+	u8 ifc_id;
 };
 
 struct op_mode {
 	u32 mode;
 };
 
-struct get_mac_addr {
+struct dev_mac_addr {
 	u8 *mac_addr;
 };
 
@@ -253,13 +260,6 @@ struct reg_frame {
 	u8 reg_id;
 };
 
-enum p2p_listen_state {
-	P2P_IDLE,
-	P2P_LISTEN,
-	P2P_GRP_FORMATION
-};
-
-struct wilc;
 struct host_if_drv {
 	struct user_scan_req usr_scan_req;
 	struct user_conn_req usr_conn_req;
@@ -280,8 +280,13 @@ struct host_if_drv {
 	struct completion comp_inactive_time;
 
 	struct timer_list scan_timer;
+	struct wilc_vif *scan_timer_vif;
+
 	struct timer_list connect_timer;
+	struct wilc_vif *connect_timer_vif;
+
 	struct timer_list remain_on_ch_timer;
+	struct wilc_vif *remain_on_ch_timer_vif;
 
 	bool IFC_UP;
 	int driver_handler_id;
@@ -299,7 +304,14 @@ struct add_sta_param {
 };
 
 struct wilc_vif;
-s32 wilc_remove_key(struct host_if_drv *hWFIDrv, const u8 *pu8StaAddress);
+
+signed int wilc_send_buffered_eap(struct wilc_vif *vif,
+				  wilc_frmw_to_linux_t frmw_to_linux,
+				  free_eap_buf_param eap_buf_param,
+				  u8 *buff, unsigned int size,
+				  unsigned int pkt_offset,
+				  void *user_arg);
+s32 wilc_remove_key(struct wilc_vif *vif, const u8 *sta_addr);
 int wilc_remove_wep_key(struct wilc_vif *vif, u8 index);
 int wilc_set_wep_default_keyid(struct wilc_vif *vif, u8 index);
 int wilc_add_wep_key_bss_sta(struct wilc_vif *vif, const u8 *key, u8 len,
@@ -310,7 +322,7 @@ int wilc_add_ptk(struct wilc_vif *vif, const u8 *ptk, u8 ptk_key_len,
 		 const u8 *mac_addr, const u8 *rx_mic, const u8 *tx_mic,
 		 u8 mode, u8 cipher_mode, u8 index);
 s32 wilc_get_inactive_time(struct wilc_vif *vif, const u8 *mac,
-			   u32 *pu32InactiveTime);
+			   u32 *out_val);
 int wilc_add_rx_gtk(struct wilc_vif *vif, const u8 *rx_gtk, u8 gtk_key_len,
 		    u8 index, u32 key_rsc_len, const u8 *key_rsc,
 		    const u8 *rx_mic, const u8 *tx_mic, u8 mode,
@@ -318,6 +330,7 @@ int wilc_add_rx_gtk(struct wilc_vif *vif, const u8 *rx_gtk, u8 gtk_key_len,
 int wilc_set_pmkid_info(struct wilc_vif *vif,
 			struct host_if_pmkid_attr *pmkid);
 int wilc_get_mac_address(struct wilc_vif *vif, u8 *mac_addr);
+int wilc_set_mac_address(struct wilc_vif *vif, u8 *mac_addr);
 int wilc_set_join_req(struct wilc_vif *vif, u8 *bssid, const u8 *ssid,
 		      size_t ssid_len, const u8 *ies, size_t ies_len,
 		      wilc_connect_result connect_result, void *user_arg,
@@ -345,7 +358,6 @@ int wilc_edit_station(struct wilc_vif *vif,
 int wilc_set_power_mgmt(struct wilc_vif *vif, bool enabled, u32 timeout);
 int wilc_setup_multicast_filter(struct wilc_vif *vif, bool enabled,
 				u32 count);
-int wilc_setup_ipaddress(struct wilc_vif *vif, u8 *ip_addr, u8 idx);
 int wilc_remain_on_channel(struct wilc_vif *vif, u32 session_id,
 			   u32 duration, u16 chan,
 			   wilc_remain_on_chan_expired expired,
@@ -361,12 +373,16 @@ void wilc_resolve_disconnect_aberration(struct wilc_vif *vif);
 int wilc_get_vif_idx(struct wilc_vif *vif);
 int wilc_set_tx_power(struct wilc_vif *vif, u8 tx_power);
 int wilc_get_tx_power(struct wilc_vif *vif, u8 *tx_power);
+/*0 select antenna 1 , 2 select antenna mode , 2 allow the firmware to choose the best antenna*/
+int wilc_set_antenna(struct wilc_vif *vif, u8 mode);
 
+signed int host_int_set_wowlan_trigger(struct wilc_vif *vif, u8 wowlan_trigger);
 extern bool wilc_optaining_ip;
 extern u8 wilc_connected_ssid[6];
 extern u8 wilc_multicast_mac_addr_list[WILC_MULTICAST_TABLE_SIZE][ETH_ALEN];
 
 extern int wilc_connecting;
-extern struct timer_list wilc_during_ip_timer;
+extern u8 wilc_initialized;
+s32 handle_scan_done(struct wilc_vif *vif, enum scan_event evt);
 
 #endif
diff --git a/drivers/staging/wilc1000/linux_mon.c b/drivers/staging/wilc/linux_mon.c
similarity index 71%
rename from drivers/staging/wilc1000/linux_mon.c
rename to drivers/staging/wilc/linux_mon.c
index 91d49c4..5f6c7bb 100644
--- a/drivers/staging/wilc1000/linux_mon.c
+++ b/drivers/staging/wilc/linux_mon.c
@@ -27,7 +27,6 @@ static struct net_device *wilc_wfi_mon; /* global monitor netdev */
 
 static u8 srcadd[6];
 static u8 bssid[6];
-static u8 broadcast[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
 /**
  *  @brief      WILC_WFI_monitor_rx
  *  @details
@@ -40,23 +39,25 @@ static u8 broadcast[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
 
 #define IEEE80211_RADIOTAP_F_TX_RTS	0x0004  /* used rts/cts handshake */
 #define IEEE80211_RADIOTAP_F_TX_FAIL	0x0001  /* failed due to excessive*/
-#define IS_MANAGMEMENT				0x100
-#define IS_MANAGMEMENT_CALLBACK			0x080
-#define IS_MGMT_STATUS_SUCCES			0x040
 #define GET_PKT_OFFSET(a) (((a) >> 22) & 0x1ff)
 
-void WILC_WFI_monitor_rx(u8 *buff, u32 size)
+void WILC_WFI_monitor_rx(struct wilc_vif *vif, u8 *buff, u32 size)
 {
 	u32 header, pkt_offset;
 	struct sk_buff *skb = NULL;
 	struct wilc_wfi_radiotap_hdr *hdr;
 	struct wilc_wfi_radiotap_cb_hdr *cb_hdr;
 
+	PRINT_D(vif->ndev, HOSTAPD_DBG,
+		"In monitor interface receive function\n");
 	if (!wilc_wfi_mon)
 		return;
 
-	if (!netif_running(wilc_wfi_mon))
+	if (!netif_running(wilc_wfi_mon)) {
+		PRINT_D(vif->ndev, HOSTAPD_DBG,
+			"Monitor interface already RUNNING\n");
 		return;
+	}
 
 	/* Get WILC header */
 	memcpy(&header, (buff - HOST_HDR_OFFSET), HOST_HDR_OFFSET);
@@ -70,12 +71,19 @@ void WILC_WFI_monitor_rx(u8 *buff, u32 size)
 		/* hostapd callback mgmt frame */
 
 		skb = dev_alloc_skb(size + sizeof(struct wilc_wfi_radiotap_cb_hdr));
-		if (!skb)
+		if (!skb) {
+			PRINT_D(vif->ndev, HOSTAPD_DBG,
+				"Monitor if : No memory to allocate skb");
 			return;
-
+		}
+	#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,13,0)
 		skb_put_data(skb, buff, size);
 
 		cb_hdr = skb_push(skb, sizeof(*cb_hdr));
+	#else
+		memcpy(skb_put(skb, size), buff, size);
+		cb_hdr = (struct wilc_wfi_radiotap_cb_hdr *)skb_push(skb, sizeof(*cb_hdr));
+	#endif
 		memset(cb_hdr, 0, sizeof(struct wilc_wfi_radiotap_cb_hdr));
 
 		cb_hdr->hdr.it_version = 0; /* PKTHDR_RADIOTAP_VERSION; */
@@ -98,16 +106,28 @@ void WILC_WFI_monitor_rx(u8 *buff, u32 size)
 	} else {
 		skb = dev_alloc_skb(size + sizeof(struct wilc_wfi_radiotap_hdr));
 
-		if (!skb)
+		if (!skb) {
+			PRINT_D(vif->ndev, HOSTAPD_DBG,
+				"Monitor if : No memory to allocate skb");
 			return;
-
+		}
+	#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,13,0)
 		skb_put_data(skb, buff, size);
 		hdr = skb_push(skb, sizeof(*hdr));
+	#else
+		memcpy(skb_put(skb, size), buff, size);
+		hdr = (struct wilc_wfi_radiotap_hdr *)skb_push(skb, 
+							       sizeof(*hdr));
+	#endif	
 		memset(hdr, 0, sizeof(struct wilc_wfi_radiotap_hdr));
 		hdr->hdr.it_version = 0; /* PKTHDR_RADIOTAP_VERSION; */
 		hdr->hdr.it_len = cpu_to_le16(sizeof(struct wilc_wfi_radiotap_hdr));
+		PRINT_D(vif->ndev, HOSTAPD_DBG,
+			"Radiotap len %d\n", hdr->hdr.it_len);
 		hdr->hdr.it_present = cpu_to_le32
 				(1 << IEEE80211_RADIOTAP_RATE); /* | */
+		PRINT_D(vif->ndev, HOSTAPD_DBG,"Presentflags %d\n",
+			hdr->hdr.it_present);
 		hdr->rate = 5; /* txrate->bitrate / 5; */
 	}
 
@@ -129,6 +149,18 @@ struct tx_complete_mon_data {
 static void mgmt_tx_complete(void *priv, int status)
 {
 	struct tx_complete_mon_data *pv_data = priv;
+	u8 *buf =  pv_data->buff;
+
+	if (status == 1) {
+		if (buf[0] == 0x10 || buf[0] == 0xb0)
+		PRINT_INFO(wilc_wfi_mon, HOSTAPD_DBG, 
+			   "Packet sent Size = %d Add = %p.\n",
+			   pv_data->size, pv_data->buff);
+	} else {
+		PRINT_INFO(wilc_wfi_mon, HOSTAPD_DBG,
+			   "Couldn't send packet Size = %d Add = %p.\n",
+			   pv_data->size,pv_data->buff);
+	}
 	/*
 	 * in case of fully hosting mode, the freeing will be done
 	 * in response to the cfg packet
@@ -142,15 +174,20 @@ static int mon_mgmt_tx(struct net_device *dev, const u8 *buf, size_t len)
 {
 	struct tx_complete_mon_data *mgmt_tx = NULL;
 
-	if (!dev)
+	if (!dev) {
+		PRINT_ER(dev, "ERROR: dev == NULL\n");
 		return -EFAULT;
+	}
 
 	netif_stop_queue(dev);
 	mgmt_tx = kmalloc(sizeof(*mgmt_tx), GFP_ATOMIC);
-	if (!mgmt_tx)
+	if (!mgmt_tx) {
+		PRINT_ER(dev,
+			 "Failed to allocate memory for mgmt_tx structure\n");
 		return -ENOMEM;
+	}
 
-	mgmt_tx->buff = kmalloc(len, GFP_ATOMIC);
+	mgmt_tx->buff = kmemdup(buf, len, GFP_ATOMIC);
 	if (!mgmt_tx->buff) {
 		kfree(mgmt_tx);
 		return -ENOMEM;
@@ -158,7 +195,6 @@ static int mon_mgmt_tx(struct net_device *dev, const u8 *buf, size_t len)
 
 	mgmt_tx->size = len;
 
-	memcpy(mgmt_tx->buff, buf, len);
 	wilc_wlan_txq_add_mgmt_pkt(dev, mgmt_tx, mgmt_tx->buff, mgmt_tx->size,
 				   mgmt_tx_complete);
 
@@ -181,55 +217,28 @@ static netdev_tx_t WILC_WFI_mon_xmit(struct sk_buff *skb,
 	u32 rtap_len, ret = 0;
 	struct WILC_WFI_mon_priv  *mon_priv;
 
-	struct sk_buff *skb2;
-	struct wilc_wfi_radiotap_cb_hdr *cb_hdr;
-
 	if (!wilc_wfi_mon)
 		return -EFAULT;
 
 	mon_priv = netdev_priv(wilc_wfi_mon);
-	if (!mon_priv)
+	if (!mon_priv) {
+		PRINT_ER(dev, "Monitor interface private structure is NULL\n");
 		return -EFAULT;
+	}
 	rtap_len = ieee80211_get_radiotap_len(skb->data);
-	if (skb->len < rtap_len)
+	if (skb->len < rtap_len) {
+		PRINT_ER(dev, "Error in radiotap header\n");
 		return -1;
+	}
 
 	skb_pull(skb, rtap_len);
 
-	if (skb->data[0] == 0xc0 && (!(memcmp(broadcast, &skb->data[4], 6)))) {
-		skb2 = dev_alloc_skb(skb->len + sizeof(struct wilc_wfi_radiotap_cb_hdr));
-		if (!skb2)
-			return -ENOMEM;
-
-		skb_put_data(skb2, skb->data, skb->len);
-
-		cb_hdr = skb_push(skb2, sizeof(*cb_hdr));
-		memset(cb_hdr, 0, sizeof(struct wilc_wfi_radiotap_cb_hdr));
-
-		cb_hdr->hdr.it_version = 0; /* PKTHDR_RADIOTAP_VERSION; */
-
-		cb_hdr->hdr.it_len = cpu_to_le16(sizeof(struct wilc_wfi_radiotap_cb_hdr));
-
-		cb_hdr->hdr.it_present = cpu_to_le32(
-				(1 << IEEE80211_RADIOTAP_RATE) |
-				(1 << IEEE80211_RADIOTAP_TX_FLAGS));
-
-		cb_hdr->rate = 5; /* txrate->bitrate / 5; */
-		cb_hdr->tx_flags = 0x0004;
-
-		skb2->dev = wilc_wfi_mon;
-		skb_reset_mac_header(skb2);
-		skb2->ip_summed = CHECKSUM_UNNECESSARY;
-		skb2->pkt_type = PACKET_OTHERHOST;
-		skb2->protocol = htons(ETH_P_802_2);
-		memset(skb2->cb, 0, sizeof(skb2->cb));
-
-		netif_rx(skb2);
-
-		return 0;
-	}
 	skb->dev = mon_priv->real_ndev;
 
+	PRINT_D(dev, HOSTAPD_DBG,"Skipping the radiotap header\n");
+	PRINT_D(dev, HOSTAPD_DBG,"SKB netdevice name = %s\n", skb->dev->name);
+	PRINT_D(dev, HOSTAPD_DBG,"MONITOR real dev name = %s\n",
+		mon_priv->real_ndev->name);
 	/* Identify if Ethernet or MAC header (data or mgmt) */
 	memcpy(srcadd, &skb->data[10], 6);
 	memcpy(bssid, &skb->data[16], 6);
@@ -238,7 +247,7 @@ static netdev_tx_t WILC_WFI_mon_xmit(struct sk_buff *skb,
 	if (!(memcmp(srcadd, bssid, 6))) {
 		ret = mon_mgmt_tx(mon_priv->real_ndev, skb->data, skb->len);
 		if (ret)
-			netdev_err(dev, "fail to mgmt tx\n");
+			PRINT_ER(dev, "fail to mgmt tx\n");
 		dev_kfree_skb(skb);
 	} else {
 		ret = wilc_mac_xmit(skb, mon_priv->real_ndev);
@@ -256,7 +265,7 @@ static const struct net_device_ops wilc_wfi_netdev_ops = {
  *  @brief      WILC_WFI_init_mon_interface
  *  @details
  *  @param[in]
- *  @return     int : Return 0 on Success
+ *  @return     Pointer to net_device
  *  @author	mdaftedar
  *  @date	12 JUL 2012
  *  @version	1.0
@@ -264,7 +273,6 @@ static const struct net_device_ops wilc_wfi_netdev_ops = {
 struct net_device *WILC_WFI_init_mon_interface(const char *name,
 					       struct net_device *real_dev)
 {
-	u32 ret = 0;
 	struct WILC_WFI_mon_priv *priv;
 
 	/*If monitor interface is already initialized, return it*/
@@ -272,21 +280,24 @@ struct net_device *WILC_WFI_init_mon_interface(const char *name,
 		return wilc_wfi_mon;
 
 	wilc_wfi_mon = alloc_etherdev(sizeof(struct WILC_WFI_mon_priv));
-	if (!wilc_wfi_mon)
+	if (!wilc_wfi_mon) {
+		PRINT_ER(real_dev, "failed to allocate memory\n");
 		return NULL;
+	}
 	wilc_wfi_mon->type = ARPHRD_IEEE80211_RADIOTAP;
 	strncpy(wilc_wfi_mon->name, name, IFNAMSIZ);
 	wilc_wfi_mon->name[IFNAMSIZ - 1] = 0;
 	wilc_wfi_mon->netdev_ops = &wilc_wfi_netdev_ops;
 
-	ret = register_netdevice(wilc_wfi_mon);
-	if (ret) {
-		netdev_err(real_dev, "register_netdevice failed\n");
+	if (register_netdevice(wilc_wfi_mon)) {
+		PRINT_ER(real_dev, "register_netdevice failed \n");
 		return NULL;
 	}
 	priv = netdev_priv(wilc_wfi_mon);
-	if (!priv)
+	if (!priv) {
+		PRINT_ER(real_dev, "private structure is NULL\n");
 		return NULL;
+	}
 
 	priv->real_ndev = real_dev;
 
@@ -307,10 +318,14 @@ int WILC_WFI_deinit_mon_interface(void)
 	bool rollback_lock = false;
 
 	if (wilc_wfi_mon) {
+		PRINT_INFO(wilc_wfi_mon, HOSTAPD_DBG,
+			   "In Deinit monitor interface\n");
+		PRINT_INFO(wilc_wfi_mon, HOSTAPD_DBG, "Locking RTNL\n");
 		if (rtnl_is_locked()) {
 			rtnl_unlock();
 			rollback_lock = true;
 		}
+		PRINT_INFO(wilc_wfi_mon, HOSTAPD_DBG, "Unregister netdev\n");
 		unregister_netdev(wilc_wfi_mon);
 
 		if (rollback_lock) {
diff --git a/drivers/staging/wilc/linux_wlan.c b/drivers/staging/wilc/linux_wlan.c
new file mode 100644
index 0000000..78254cb
--- /dev/null
+++ b/drivers/staging/wilc/linux_wlan.c
@@ -0,0 +1,1833 @@
+// SPDX-License-Identifier: GPL-2.0
+#include "wilc_wfi_cfgoperations.h"
+#include "wilc_wlan_if.h"
+#include "wilc_wlan.h"
+
+#include <linux/slab.h>
+#include <linux/sched.h>
+#include <linux/delay.h>
+#include <linux/workqueue.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/gpio.h>
+
+#include <linux/kthread.h>
+#include <linux/firmware.h>
+
+#include <linux/init.h>
+#include <linux/netdevice.h>
+#ifdef DISABLE_PWRSAVE_AND_SCAN_DURING_IP
+#include <linux/inetdevice.h>
+#endif /* DISABLE_PWRSAVE_AND_SCAN_DURING_IP */
+#include <linux/etherdevice.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/skbuff.h>
+#include <linux/mutex.h>
+#include <linux/completion.h>
+
+#include <linux/mmc/host.h>
+#include <linux/mmc/sdio_func.h>
+#include <linux/pm_runtime.h>
+
+#include <linux/of_gpio.h>
+#include <linux/version.h>
+
+#include "linux_wlan.h"
+
+#ifdef DISABLE_PWRSAVE_AND_SCAN_DURING_IP
+bool g_ignore_PS_state = false;
+#define duringIP_TIME		15000
+
+void handle_pwrsave_during_obtainingIP(struct wilc_vif *vif, uint8_t state)
+{
+	struct wilc_priv *priv;
+
+	priv = wdev_priv(vif->ndev->ieee80211_ptr);
+
+	switch(state)
+	{
+	case IP_STATE_OBTAINING:
+
+		PRINT_INFO(vif->ndev, GENERIC_DBG, "Obtaining an IP, Disable (Scan-Set PowerSave)\n");
+		PRINT_INFO(vif->ndev, GENERIC_DBG, "Save the Current state of the PS = %d\n", vif->pwrsave_current_state);
+
+		wilc_optaining_ip = true;
+
+		/* Set this flag to avoid storing the disabled case of PS which occurs duringIP */
+		g_ignore_PS_state = true;
+
+		wilc_set_power_mgmt(vif, 0, 0);
+
+		/* Start the DuringIPTimer */
+	#if LINUX_VERSION_CODE < KERNEL_VERSION(4,15,0)
+		priv->during_ip_timer.data = (uint32_t)priv;
+	#endif
+		mod_timer(&priv->during_ip_timer, (jiffies + msecs_to_jiffies(20000)));
+
+		break;
+
+	case IP_STATE_OBTAINED:
+
+		PRINT_INFO(vif->ndev, GENERIC_DBG, "IP obtained , Enable (Scan-Set PowerSave)\n");
+		PRINT_INFO(vif->ndev, GENERIC_DBG, "Recover the state of the PS = %d\n", vif->pwrsave_current_state);
+
+		wilc_optaining_ip = false;
+
+		/* Recover PS previous state */
+		if(wilc_enable_ps == true)
+		{
+			wilc_set_power_mgmt(vif, vif->pwrsave_current_state, 0);
+		}
+
+		del_timer(&priv->during_ip_timer);
+
+		break;
+
+	case IP_STATE_GO_ASSIGNING:
+
+		/* Set the wilc_optaining_ip flag */
+		wilc_optaining_ip = true;
+
+		/* Start the DuringIPTimer */
+	#if LINUX_VERSION_CODE < KERNEL_VERSION(4,15,0)
+		priv->during_ip_timer.data = (uint32_t)priv;
+	#endif
+		mod_timer(&priv->during_ip_timer, (jiffies + msecs_to_jiffies(duringIP_TIME)));
+
+		break;
+
+	default: //IP_STATE_DEFAULT
+
+		/* Clear the wilc_optaining_ip flag */
+		wilc_optaining_ip = false;
+
+		/* Stop the DuringIPTimer */
+		del_timer(&priv->during_ip_timer);
+
+		break;
+	}
+}
+
+void set_obtaining_IP_flag(bool val)
+{
+	wilc_optaining_ip = val;
+}
+
+void store_power_save_current_state(struct wilc_vif *vif, bool val)
+{
+	if(g_ignore_PS_state)
+	{
+		g_ignore_PS_state = false;
+		return;
+	}
+	vif->pwrsave_current_state = val;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,15,0)
+void clear_duringIP(struct timer_list *t)
+#else
+void clear_duringIP(unsigned long arg)
+#endif
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,15,0)
+	struct wilc_priv *priv = from_timer(priv, t, during_ip_timer);
+#else
+	struct wilc_priv *priv = (struct wilc_priv *)arg;
+#endif
+	struct wilc_vif *vif = netdev_priv(priv->dev);
+
+	PRINT_ER(vif->ndev, "Unable to Obtain IP\n");
+
+	/* Clear the wilc_optaining_ip flag */
+	wilc_optaining_ip = false;
+
+	PRINT_INFO(vif->ndev, GENERIC_DBG, "Recover the state of the PS = %d\n", vif->pwrsave_current_state);
+
+	/* Recover PS previous state */
+	if(wilc_enable_ps == true)
+	{
+		wilc_set_power_mgmt(vif, vif->pwrsave_current_state, 0);
+	}
+}
+#endif /* DISABLE_PWRSAVE_AND_SCAN_DURING_IP */
+
+void wilc_frmw_to_linux(struct wilc *wilc, u8 *buff, u32 size, u32 pkt_offset,
+			u8 status);
+static int wilc_mac_open(struct net_device *ndev);
+static int wilc_mac_close(struct net_device *ndev);
+
+bool wilc_enable_ps = true;
+
+int debug_running = false;
+int recovery_on = 0;
+int wait_for_recovery = 0;
+static int debug_thread(void *arg)
+{
+	struct wilc_vif *vif;
+	struct wilc *wl;
+	struct wilc_priv *priv;
+	struct net_device *dev = arg;
+	signed long timeout;
+	struct host_if_drv *hif_drv;
+	int i = 0;
+
+	vif = netdev_priv(dev);
+
+	priv = wiphy_priv(vif->ndev->ieee80211_ptr->wiphy);
+	hif_drv = (struct host_if_drv *)priv->hif_drv;
+
+	if(!vif)
+		return -1;
+
+	wl = vif->wilc;
+	if(!wl)
+		return -1;
+
+	complete(&wl->debug_thread_started);
+
+	while(1){
+		if (wl->initialized) {
+			if (wait_for_completion_timeout(&wl->debug_thread_started,
+							msecs_to_jiffies(6000))) {
+				while (!kthread_should_stop())
+					schedule();
+				PRINT_INFO(vif->ndev, GENERIC_DBG, "Exit debug thread\n");
+				return 0;
+			}
+
+			if (debug_running) {
+				PRINT_INFO(dev, GENERIC_DBG,
+					   "*** Debug Thread Running ***\n");
+				if(cfg_packet_timeout >= 5){
+					PRINT_INFO(dev, GENERIC_DBG,
+						   "<Recover>\n");
+					cfg_packet_timeout = 0;
+					timeout = 10;
+					recovery_on = 1;
+					wait_for_recovery = 1;
+					for (i = 0; i < NUM_CONCURRENT_IFC; i++)
+						wilc_mac_close(wl->vif[i]->ndev);
+					for (i = NUM_CONCURRENT_IFC; i > 0; i--) {
+						while (wilc_mac_open(wl->vif[i-1]->ndev) && --timeout)
+							msleep(100);
+
+						if (timeout == 0)
+							PRINT_WRN(vif->ndev, GENERIC_DBG,
+								  "Couldn't restart interface %d again\n", i);
+					}
+					if(hif_drv->hif_state == HOST_IF_CONNECTED) {
+						struct disconnect_info strDisconnectNotifInfo;
+
+						PRINT_INFO(vif->ndev, GENERIC_DBG, "notify the upper layer with the wlan Disconnection\n");
+						memset(&strDisconnectNotifInfo, 0, sizeof(struct disconnect_info));
+						if (hif_drv->usr_scan_req.scan_result) {
+							PRINT_INFO(vif->ndev, GENERIC_DBG, "\n\n<< Abort the running OBSS Scan >>\n\n");
+							del_timer(&hif_drv->scan_timer);
+							handle_scan_done(vif, SCAN_EVENT_ABORTED);
+						}
+						strDisconnectNotifInfo.reason = 0;
+						strDisconnectNotifInfo.ie = NULL;
+						strDisconnectNotifInfo.ie_len = 0;
+
+						if (hif_drv->usr_conn_req.conn_result) {
+#ifdef DISABLE_PWRSAVE_AND_SCAN_DURING_IP
+
+							handle_pwrsave_during_obtainingIP(vif, IP_STATE_DEFAULT);
+#endif
+
+							hif_drv->usr_conn_req.conn_result(CONN_DISCONN_EVENT_DISCONN_NOTIF,
+											  NULL,
+											  0,
+											  &strDisconnectNotifInfo,
+											  hif_drv->usr_conn_req.arg);
+						} else {
+							PRINT_ER(vif->ndev, "Connect result NULL\n");
+						}
+						eth_zero_addr(hif_drv->assoc_bssid);
+
+						hif_drv->usr_conn_req.ssid_len = 0;
+						kfree(hif_drv->usr_conn_req.ssid);
+						hif_drv->usr_conn_req.ssid = NULL;
+						kfree(hif_drv->usr_conn_req.bssid);
+						hif_drv->usr_conn_req.bssid = NULL;
+						hif_drv->usr_conn_req.ies_len = 0;
+						kfree(hif_drv->usr_conn_req.ies);
+						hif_drv->usr_conn_req.ies = NULL;
+
+						hif_drv->hif_state = HOST_IF_IDLE;
+					}
+					recovery_on = 0;
+				}
+			}
+		} else if (kthread_should_stop()) {
+			break;
+		} else {
+			msleep(1000);
+		}
+	}
+	return 0;
+}
+
+#ifdef DISABLE_PWRSAVE_AND_SCAN_DURING_IP
+static int dev_state_ev_handler(struct notifier_block *this,
+				unsigned long event, void *ptr)
+{
+	struct in_ifaddr *dev_iface = ptr;
+	struct wilc_priv *priv;
+	struct host_if_drv *hif_drv;
+	struct net_device *dev;
+	u8 *ip_addr_buf;
+	struct wilc_vif *vif;
+	u8 null_ip[4] = {0};
+
+	if (!dev_iface || !dev_iface->ifa_dev ||!dev_iface->ifa_dev->dev) {
+		pr_err("dev_iface = NULL\n");
+		return NOTIFY_DONE;
+	}
+
+	dev  = (struct net_device *)dev_iface->ifa_dev->dev;
+	vif = netdev_priv(dev);
+	if (memcmp(dev_iface->ifa_label, IFC_0, 5) &&
+	    memcmp(dev_iface->ifa_label, IFC_1, 4)) {
+		PRINT_INFO(vif->ndev, GENERIC_DBG,
+			   "Interface is neither WLAN0 nor P2P0\n");
+		return NOTIFY_DONE;
+	}
+
+	if (!dev->ieee80211_ptr|| !dev->ieee80211_ptr->wiphy) {
+		pr_err("No Wireless registerd\n");
+		return NOTIFY_DONE;
+	}
+
+	priv = wiphy_priv(dev->ieee80211_ptr->wiphy);
+	if (!priv) {
+		pr_err("No Wireless Priv\n");
+		return NOTIFY_DONE;
+	}
+	hif_drv = (struct host_if_drv *)priv->hif_drv;
+	if (!vif || !hif_drv) {
+		PRINT_WRN(vif->ndev, GENERIC_DBG, "No Wireless Priv\n");
+		return NOTIFY_DONE;
+	}
+	PRINT_INFO(vif->ndev, GENERIC_DBG, "dev_state_ev_handler +++\n");
+
+	switch (event) {
+	case NETDEV_UP:
+		PRINT_INFO(vif->ndev, GENERIC_DBG,
+			   "dev_state_ev_handler event=NETDEV_UP %p\n",dev);
+		PRINT_D(vif->ndev, GENERIC_DBG,
+			"\n =========== IP Address Obtained ============\n\n");
+		if (vif->iftype == STATION_MODE || vif->iftype == CLIENT_MODE) {
+			hif_drv->IFC_UP = 1;
+
+			handle_pwrsave_during_obtainingIP(vif,
+							  IP_STATE_OBTAINED);
+		}
+		PRINT_INFO(vif->ndev, GENERIC_DBG, "[%s] Up IP\n", dev_iface->ifa_label);
+
+		ip_addr_buf = (char *)&dev_iface->ifa_address;
+		PRINT_INFO(vif->ndev, GENERIC_DBG, "IP add=%d:%d:%d:%d\n",
+			   ip_addr_buf[0], ip_addr_buf[1],
+			   ip_addr_buf[2], ip_addr_buf[3]);
+
+		break;
+
+	case NETDEV_DOWN:
+		PRINT_INFO(vif->ndev, GENERIC_DBG,
+			   "dev_state_ev_handler event=NETDEV_DOWN %p\n",dev);
+		PRINT_D(vif->ndev, GENERIC_DBG,
+			"\n =========== IP Address Released ============\n\n");
+		if (vif->iftype == STATION_MODE || vif->iftype == CLIENT_MODE) {
+			hif_drv->IFC_UP = 0;
+			handle_pwrsave_during_obtainingIP(vif, IP_STATE_DEFAULT);
+		}
+
+
+		wilc_resolve_disconnect_aberration(vif);
+
+		PRINT_INFO(vif->ndev, GENERIC_DBG, "[%s] Down IP\n", dev_iface->ifa_label);
+
+		ip_addr_buf = null_ip;
+		PRINT_INFO(vif->ndev, GENERIC_DBG, "IP add=%d:%d:%d:%d\n",
+			   ip_addr_buf[0], ip_addr_buf[1],
+			   ip_addr_buf[2], ip_addr_buf[3]);
+		break;
+
+	default:
+		PRINT_INFO(vif->ndev, GENERIC_DBG,
+			   "dev_state_ev_handler [%s] unknown dev event %lu\n",
+			   dev_iface->ifa_label, event);
+		break;
+	}
+
+	return NOTIFY_DONE;
+}
+#endif /* DISABLE_PWRSAVE_AND_SCAN_DURING_IP */
+
+void linux_wlan_disable_irq(struct wilc* wilc, int wait)
+{
+	if (wait) {
+		PRINT_INFO(wilc->vif[0]->ndev, INT_DBG, "Disabling IRQ ...\n");
+		disable_irq(wilc->dev_irq_num);
+	} else {
+		PRINT_INFO(wilc->vif[0]->ndev, INT_DBG, "Disabling IRQ ...\n");
+		disable_irq_nosync(wilc->dev_irq_num);
+	}
+}
+
+static irqreturn_t host_wakeup_isr(int irq, void *user_data)
+{
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t isr_uh_routine(int irq, void *user_data)
+{
+	struct wilc *wilc;
+	struct net_device *dev;
+
+	wilc = (struct wilc *)user_data;
+	dev = wilc->vif[0]->ndev;
+
+	PRINT_INFO(dev, INT_DBG, "Interrupt received UH\n");
+
+	if (wilc->close) {
+		PRINT_ER(dev, "Can't handle UH interrupt\n");
+		return IRQ_HANDLED;
+	}
+	return IRQ_WAKE_THREAD;
+}
+
+static irqreturn_t isr_bh_routine(int irq, void *userdata)
+{
+	struct wilc *wilc;
+	struct net_device *dev;
+
+	wilc = (struct wilc *)userdata;
+	dev = wilc->vif[0]->ndev;
+
+	if (wilc->close) {
+		PRINT_ER(dev, "Can't handle BH interrupt\n");
+		return IRQ_HANDLED;
+	}
+
+	PRINT_INFO(dev, INT_DBG, "Interrupt received BH\n");
+	wilc_handle_isr(wilc);
+
+	return IRQ_HANDLED;
+}
+
+static int init_irq(struct net_device *dev)
+{
+	int ret = 0;
+	struct wilc_vif *vif;
+	struct wilc *wl;
+
+	vif = netdev_priv(dev);
+	wl = vif->wilc;
+
+	if ((gpio_request(wl->gpio_irq, "WILC_INTR") == 0) &&
+	    (gpio_direction_input(wl->gpio_irq) == 0)) {
+		wl->dev_irq_num = gpio_to_irq(wl->gpio_irq);
+	} else {
+		ret = -1;
+		PRINT_ER(dev, "could not obtain gpio for WILC_INTR\n");
+	}
+
+	if (wl->io_type == HIF_SPI || 
+		wl->io_type == HIF_SDIO_GPIO_IRQ) {
+		if (ret != -1 && request_threaded_irq(wl->dev_irq_num,
+						      isr_uh_routine,
+						      isr_bh_routine,
+						      IRQF_TRIGGER_LOW | IRQF_ONESHOT|IRQF_NO_SUSPEND,
+						      "WILC_IRQ", wl) < 0) {
+			PRINT_ER(dev, "Failed to request IRQ GPIO: %d\n", wl->gpio_irq);
+			gpio_free(wl->gpio_irq);
+			ret = -1;
+		}
+	} else {
+		if (ret != -1 && request_irq(wl->dev_irq_num,
+					     host_wakeup_isr,
+					     IRQF_TRIGGER_FALLING |
+					     IRQF_NO_SUSPEND,
+					     "WILC_IRQ", wl) < 0) {
+			PRINT_ER(dev, "Failed to request IRQ GPIO: %d\n",
+				 wl->gpio_irq);
+			gpio_free(wl->gpio_irq);
+			ret = -1;
+		}
+	}
+
+	if(ret >=0) {
+		PRINT_INFO(dev, GENERIC_DBG,
+			   "IRQ request succeeded IRQ-NUM= %d on GPIO: %d\n",
+			   wl->dev_irq_num, wl->gpio_irq);
+		enable_irq_wake(wl->dev_irq_num);
+	}
+
+	return ret;
+}
+
+static void deinit_irq(struct net_device *dev)
+{
+	struct wilc_vif *vif;
+	struct wilc *wilc;
+
+	vif = netdev_priv(dev);
+	wilc = vif->wilc;
+
+	/* Deinitialize IRQ */
+	if (wilc->dev_irq_num) {
+		free_irq(wilc->dev_irq_num, wilc);
+		gpio_free(wilc->gpio_irq);
+	}
+}
+
+void wilc_mac_indicate(struct wilc *wilc, int flag)
+{
+	int status;
+
+	if (flag == WILC_MAC_INDICATE_STATUS) {
+		wilc_wlan_cfg_get_val(wilc->vif[0], WID_STATUS,
+				      (unsigned char *)&status, 4);
+		if (wilc->mac_status == MAC_STATUS_INIT) {
+			wilc->mac_status = status;
+			complete(&wilc->sync_event);
+		} else {
+			wilc->mac_status = status;
+		}
+	} else if (flag == WILC_MAC_INDICATE_SCAN) {
+		PRINT_INFO(wilc->vif[0]->ndev, GENERIC_DBG, "Scanning ...\n");
+	}
+}
+
+void free_eap_buff_params(void *vp)
+{
+	struct wilc_priv *priv;
+
+	priv = (struct wilc_priv *)vp;
+
+	if(priv->buffered_eap) {
+		if(priv->buffered_eap->buff) {
+			kfree(priv->buffered_eap->buff);
+			priv->buffered_eap->buff = NULL;
+		}
+		kfree(priv->buffered_eap);
+		priv->buffered_eap = NULL;
+	}
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,15,0)
+void eap_buff_timeout(struct timer_list *t)
+#else
+void eap_buff_timeout(unsigned long user)
+#endif
+{
+    u8 null_bssid[ETH_ALEN] = {0};
+    static u8 timeout = 5;
+    int status = -1;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,15,0)
+    struct wilc_priv *priv = from_timer(priv, t, eap_buff_timer);
+#else
+	struct wilc_priv *priv = (struct wilc_priv *)user;
+#endif
+    struct wilc_vif *vif = netdev_priv(priv->dev);
+
+    if (!(memcmp(priv->associated_bss, null_bssid, ETH_ALEN)) && (timeout-- > 0)) {
+            mod_timer(&priv->eap_buff_timer,(jiffies + msecs_to_jiffies(10)));
+            return;
+    }
+    del_timer(&priv->eap_buff_timer);
+    timeout = 5;
+
+    status = wilc_send_buffered_eap(vif,
+                                    wilc_frmw_to_linux,
+                                    free_eap_buff_params,
+                                    priv->buffered_eap->buff,
+                                    priv->buffered_eap->size,
+                                    priv->buffered_eap->pkt_offset,
+                                    (void *)priv);
+	if (status)
+		PRINT_ER(vif->ndev, "Failed so send buffered eap\n");
+}
+
+static struct net_device *get_if_handler(struct wilc *wilc, u8 *mac_header)
+{
+	u8 *bssid, *bssid1;
+	int i = 0;
+
+	bssid = mac_header + 10;
+	bssid1 = mac_header + 4;
+	for (i = 0; i <= wilc->vif_num; i++) {
+		if (wilc->vif[i]->iftype == STATION_MODE)
+			if (ether_addr_equal_unaligned(bssid,
+						       wilc->vif[i]->bssid))
+				return wilc->vif[i]->ndev;
+		if (wilc->vif[i]->iftype == AP_MODE)
+			if (ether_addr_equal_unaligned(bssid1,
+						       wilc->vif[i]->bssid))
+				return wilc->vif[i]->ndev;
+	}
+
+	PRINT_WRN(wilc->vif[0]->ndev, GENERIC_DBG, "Invalid handle\n");
+	return NULL;
+}
+
+int wilc_wlan_set_bssid(struct net_device *wilc_netdev, u8 *bssid, u8 mode)
+{
+	struct wilc_vif *vif = netdev_priv(wilc_netdev);
+	struct wilc *wilc;
+	u8 i = 0;
+
+	wilc = vif->wilc;
+
+	PRINT_INFO(vif->ndev, GENERIC_DBG, "set bssid on[%p]\n", wilc_netdev);
+	for (i = 0; i <= wilc->vif_num; i++){
+		if (wilc_netdev == wilc->vif[i]->ndev) {
+			PRINT_INFO(vif->ndev, GENERIC_DBG,
+				   "set bssid [%x][%x][%x]\n", bssid[0],
+				   bssid[1], bssid[2]);
+			memcpy(wilc->vif[i]->bssid, bssid, 6);
+			wilc->vif[i]->iftype = mode;
+		}
+	}
+	return 0;
+}
+
+int wilc_wlan_get_num_conn_ifcs(struct wilc *wilc)
+{
+	u8 i = 0;
+	u8 null_bssid[6] = {0};
+	u8 ret_val = 0;
+
+	for (i = 0; i <= wilc->vif_num; i++)
+		if (memcmp(wilc->vif[i]->bssid, null_bssid, 6))
+			ret_val++;
+
+	return ret_val;
+}
+
+struct net_device* wilc_get_if_netdev(struct wilc *wilc, uint8_t ifc)
+{
+	return wilc->vif[ifc]->ndev;
+}
+
+struct host_if_drv * wilc_get_drv_handler_by_ifc(struct wilc *wilc, uint8_t ifc)
+{
+	return wilc->vif[ifc]->hif_drv;
+}
+
+#define TX_BACKOFF_WEIGHT_INCR_STEP (1)
+#define TX_BACKOFF_WEIGHT_DECR_STEP (1)
+#define TX_BACKOFF_WEIGHT_MAX (0)
+#define TX_BACKOFF_WEIGHT_MIN (0)
+#define TX_BACKOFF_WEIGHT_UNIT_MS (1)
+
+
+static int linux_wlan_txq_task(void *vp)
+{
+	int ret;
+	u32 txq_count;
+	struct wilc_vif *vif;
+	struct wilc *wl;
+	struct net_device *dev = vp;
+	int backoff_weight = TX_BACKOFF_WEIGHT_MIN;
+	signed long timeout;
+
+	vif = netdev_priv(dev);
+	wl = vif->wilc;
+
+	complete(&wl->txq_thread_started);
+	while (1) {
+		PRINT_INFO(vif->ndev, TX_DBG, "txq_task Taking a nap\n");
+		wait_for_completion(&wl->txq_event);
+		PRINT_INFO(vif->ndev, TX_DBG, "txq_task Who waked me up\n");
+		if (wl->close) {
+			complete(&wl->txq_thread_started);
+
+			while (!kthread_should_stop())
+				schedule();
+			PRINT_INFO(vif->ndev, TX_DBG, "TX thread stopped\n");
+			break;
+		}
+		PRINT_INFO(vif->ndev, TX_DBG, "txq_task handle the sending packet and let me go to sleep.\n");
+		do {
+			ret = wilc_wlan_handle_txq(dev, &txq_count);
+			if (txq_count < FLOW_CONTROL_LOWER_THRESHOLD) {
+				PRINT_INFO(vif->ndev, TX_DBG, "Waking up queue\n");
+				if (netif_queue_stopped(wl->vif[0]->ndev))
+					netif_wake_queue(wl->vif[0]->ndev);
+				if (netif_queue_stopped(wl->vif[1]->ndev))
+					netif_wake_queue(wl->vif[1]->ndev);
+			}
+
+			if (ret == WILC_TX_ERR_NO_BUF) {
+				timeout = msecs_to_jiffies(TX_BACKOFF_WEIGHT_UNIT_MS << backoff_weight);
+				do {
+					/* Back off from sending packets for some time. */
+					/* schedule_timeout will allow RX task to run and free buffers.*/
+					/*Setting state to TASK_INTERRUPTIBLE will put the thread back to CPU*/
+					/*running queue when it's signaled even if 'timeout' isn't elapsed.*/
+					/*This gives faster chance for reserved SK buffers to be freed*/
+					set_current_state(TASK_INTERRUPTIBLE);
+					timeout = schedule_timeout(timeout);
+					} while(/*timeout*/0);
+				backoff_weight += TX_BACKOFF_WEIGHT_INCR_STEP;
+				if (backoff_weight > TX_BACKOFF_WEIGHT_MAX)
+					backoff_weight = TX_BACKOFF_WEIGHT_MAX;
+			} else if (backoff_weight > TX_BACKOFF_WEIGHT_MIN) {
+				backoff_weight -= TX_BACKOFF_WEIGHT_DECR_STEP;
+				if (backoff_weight < TX_BACKOFF_WEIGHT_MIN)
+					backoff_weight = TX_BACKOFF_WEIGHT_MIN;
+			}
+		} while (ret == WILC_TX_ERR_NO_BUF && !wl->close);
+	}
+	return 0;
+}
+
+static int wilc_wlan_get_firmware(struct net_device *dev)
+{
+	struct wilc_vif *vif;
+	struct wilc *wilc;
+	int ret = 0;
+	const struct firmware *wilc_firmware;
+	char *firmware;
+
+	vif = netdev_priv(dev);
+	wilc = vif->wilc;
+
+	if (wilc->chip == WILC_3000) {
+		PRINT_INFO(dev, INIT_DBG, "Detect chip WILC3000\n");
+		firmware = FIRMWARE_WILC3000_WIFI;
+	} else if (wilc->chip == WILC_1000) {
+		PRINT_INFO(dev, INIT_DBG, "Detect chip WILC1000\n");
+		firmware = FIRMWARE_WILC1000_WIFi;
+	} else {
+		return -1;
+	}
+
+	PRINT_INFO(dev, INIT_DBG, "loading firmware %s\n", firmware);
+
+	if (!(&vif->ndev->dev)) {
+		PRINT_ER(dev, "Dev  is NULL\n");
+		goto fail;
+	}
+
+	PRINT_INFO (vif->ndev, INIT_DBG, "WLAN firmware: %s\n", firmware);
+	if (request_firmware(&wilc_firmware, firmware, wilc->dev) != 0) {
+		PRINT_ER(dev, "%s - firmware not available\n", firmware);
+		ret = -1;
+		goto fail;
+	}
+	wilc->firmware = wilc_firmware;
+
+fail:
+
+	return ret;
+}
+
+static int linux_wlan_start_firmware(struct net_device *dev)
+{
+	struct wilc_vif *vif;
+	struct wilc *wilc;
+	int ret = 0;
+
+	vif = netdev_priv(dev);
+	wilc = vif->wilc;
+
+	PRINT_INFO(vif->ndev, INIT_DBG, "Starting Firmware ...\n");
+
+	ret = wilc_wlan_start(wilc);
+	if (ret < 0) {
+		PRINT_ER(dev, "Failed to start Firmware\n");
+		return ret;
+	}
+	PRINT_INFO(vif->ndev, INIT_DBG, "Waiting for FW to get ready ...\n");
+
+	if (!wait_for_completion_timeout(&wilc->sync_event,
+					 msecs_to_jiffies(1000))) {
+		PRINT_INFO(vif->ndev, INIT_DBG, "Firmware start timed out\n");
+		return -ETIME;
+	}
+	PRINT_INFO(vif->ndev, INIT_DBG, "Firmware successfully started\n");
+
+	return 0;
+}
+
+static int wilc_firmware_download(struct net_device *dev)
+{
+	struct wilc_vif *vif;
+	struct wilc *wilc;
+	int ret = 0;
+
+	vif = netdev_priv(dev);
+	wilc = vif->wilc;
+
+	if (!wilc->firmware) {
+		PRINT_ER(dev, "Firmware buffer is NULL\n");
+		ret = -ENOBUFS;
+	}
+	PRINT_INFO(vif->ndev, INIT_DBG, "Downloading Firmware ...\n");
+	ret = wilc_wlan_firmware_download(wilc, wilc->firmware->data,
+					  wilc->firmware->size);
+	if (ret < 0)
+		goto fail;
+
+	PRINT_INFO(vif->ndev, INIT_DBG, "Download Succeeded\n");
+
+fail:
+	release_firmware(wilc->firmware);
+	wilc->firmware = NULL;
+
+	return ret;
+}
+
+static int linux_wlan_init_test_config(struct net_device *dev,
+				       struct wilc_vif *vif)
+{
+	unsigned char c_val[64];
+	struct wilc_priv *priv;
+	struct host_if_drv *hif_drv;
+
+	PRINT_INFO(vif->ndev, INIT_DBG, "Start configuring Firmware\n");
+	priv = wiphy_priv(dev->ieee80211_ptr->wiphy);
+	hif_drv = (struct host_if_drv *)priv->hif_drv;
+	PRINT_D(vif->ndev, INIT_DBG, "Host = %p\n", hif_drv);
+
+	*(int *)c_val = (unsigned int)vif->iftype;
+
+	if (!wilc_wlan_cfg_set(vif, 1, WID_SET_OPERATION_MODE, c_val, 4, 0, 0))
+		goto fail;
+
+	c_val[0] = 0;
+	if (!wilc_wlan_cfg_set(vif, 0, WID_PC_TEST_MODE, c_val, 1, 0, 0))
+		goto fail;
+
+	c_val[0] = INFRASTRUCTURE;
+	if (!wilc_wlan_cfg_set(vif, 0, WID_BSS_TYPE, c_val, 1, 0, 0))
+		goto fail;
+
+	c_val[0] = RATE_AUTO;
+	if (!wilc_wlan_cfg_set(vif, 0, WID_CURRENT_TX_RATE, c_val, 1, 0, 0))
+		goto fail;
+
+	c_val[0] = G_MIXED_11B_2_MODE;
+	if (!wilc_wlan_cfg_set(vif, 0, WID_11G_OPERATING_MODE, c_val, 1, 0,
+			       0))
+		goto fail;
+
+	c_val[0] = G_AUTO_PREAMBLE;
+	if (!wilc_wlan_cfg_set(vif, 0, WID_PREAMBLE, c_val, 1, 0, 0))
+		goto fail;
+
+	c_val[0] = AUTO_PROT;
+	if (!wilc_wlan_cfg_set(vif, 0, WID_11N_PROT_MECH, c_val, 1, 0, 0))
+		goto fail;
+
+	c_val[0] = ACTIVE_SCAN;
+	if (!wilc_wlan_cfg_set(vif, 0, WID_SCAN_TYPE, c_val, 1, 0, 0))
+		goto fail;
+
+	c_val[0] = SITE_SURVEY_OFF;
+	if (!wilc_wlan_cfg_set(vif, 0, WID_SITE_SURVEY, c_val, 1, 0, 0))
+		goto fail;
+
+	*((int *)c_val) = 0xffff;
+	if (!wilc_wlan_cfg_set(vif, 0, WID_RTS_THRESHOLD, c_val, 2, 0, 0))
+		goto fail;
+
+	*((int *)c_val) = 2346;
+	if (!wilc_wlan_cfg_set(vif, 0, WID_FRAG_THRESHOLD, c_val, 2, 0, 0))
+		goto fail;
+
+	c_val[0] = 0;
+	if (!wilc_wlan_cfg_set(vif, 0, WID_BCAST_SSID, c_val, 1, 0, 0))
+		goto fail;
+
+	c_val[0] = 1;
+	if (!wilc_wlan_cfg_set(vif, 0, WID_QOS_ENABLE, c_val, 1, 0, 0))
+		goto fail;
+
+	c_val[0] = NO_POWERSAVE;
+	if (!wilc_wlan_cfg_set(vif, 0, WID_POWER_MANAGEMENT, c_val, 1, 0, 0))
+		goto fail;
+
+	c_val[0] = NO_ENCRYPT;
+	if (!wilc_wlan_cfg_set(vif, 0, WID_11I_MODE, c_val, 1, 0, 0))
+		goto fail;
+
+	c_val[0] = OPEN_SYSTEM;
+	if (!wilc_wlan_cfg_set(vif, 0, WID_AUTH_TYPE, c_val, 1, 0, 0))
+		goto fail;
+
+	strcpy(c_val, "123456790abcdef1234567890");
+	if (!wilc_wlan_cfg_set(vif, 0, WID_WEP_KEY_VALUE, c_val,
+			       (strlen(c_val) + 1), 0, 0))
+		goto fail;
+
+	strcpy(c_val, "12345678");
+	if (!wilc_wlan_cfg_set(vif, 0, WID_11I_PSK, c_val, (strlen(c_val)), 0,
+			       0))
+		goto fail;
+
+	strcpy(c_val, "password");
+	if (!wilc_wlan_cfg_set(vif, 0, WID_1X_KEY, c_val, (strlen(c_val) + 1),
+			       0, 0))
+		goto fail;
+
+	c_val[0] = 192;
+	c_val[1] = 168;
+	c_val[2] = 1;
+	c_val[3] = 112;
+	if (!wilc_wlan_cfg_set(vif, 0, WID_1X_SERV_ADDR, c_val, 4, 0, 0))
+		goto fail;
+
+	c_val[0] = 3;
+	if (!wilc_wlan_cfg_set(vif, 0, WID_LISTEN_INTERVAL, c_val, 1, 0, 0))
+		goto fail;
+
+	c_val[0] = 3;
+	if (!wilc_wlan_cfg_set(vif, 0, WID_DTIM_PERIOD, c_val, 1, 0, 0))
+		goto fail;
+
+	c_val[0] = NORMAL_ACK;
+	if (!wilc_wlan_cfg_set(vif, 0, WID_ACK_POLICY, c_val, 1, 0, 0))
+		goto fail;
+
+	c_val[0] = 0;
+	if (!wilc_wlan_cfg_set(vif, 0, WID_USER_CONTROL_ON_TX_POWER, c_val, 1,
+			       0, 0))
+		goto fail;
+
+	c_val[0] = 48;
+	if (!wilc_wlan_cfg_set(vif, 0, WID_TX_POWER_LEVEL_11A, c_val, 1, 0,
+			       0))
+		goto fail;
+
+	c_val[0] = 28;
+	if (!wilc_wlan_cfg_set(vif, 0, WID_TX_POWER_LEVEL_11B, c_val, 1, 0,
+			       0))
+		goto fail;
+
+	*((int *)c_val) = 100;
+	if (!wilc_wlan_cfg_set(vif, 0, WID_BEACON_INTERVAL, c_val, 2, 0, 0))
+		goto fail;
+
+	c_val[0] = REKEY_DISABLE;
+	if (!wilc_wlan_cfg_set(vif, 0, WID_REKEY_POLICY, c_val, 1, 0, 0))
+		goto fail;
+
+	*((int *)c_val) = 84600;
+	if (!wilc_wlan_cfg_set(vif, 0, WID_REKEY_PERIOD, c_val, 4, 0, 0))
+		goto fail;
+
+	*((int *)c_val) = 500;
+	if (!wilc_wlan_cfg_set(vif, 0, WID_REKEY_PACKET_COUNT, c_val, 4, 0,
+			       0))
+		goto fail;
+
+	c_val[0] = 1;
+	if (!wilc_wlan_cfg_set(vif, 0, WID_SHORT_SLOT_ALLOWED, c_val, 1, 0,
+			       0))
+		goto fail;
+
+	c_val[0] = G_SELF_CTS_PROT;
+	if (!wilc_wlan_cfg_set(vif, 0, WID_11N_ERP_PROT_TYPE, c_val, 1, 0, 0))
+		goto fail;
+
+	c_val[0] = 1;
+	if (!wilc_wlan_cfg_set(vif, 0, WID_11N_ENABLE, c_val, 1, 0, 0))
+		goto fail;
+
+	c_val[0] = HT_MIXED_MODE;
+	if (!wilc_wlan_cfg_set(vif, 0, WID_11N_OPERATING_MODE, c_val, 1, 0,
+			       0))
+		goto fail;
+
+	c_val[0] = 1;
+	if (!wilc_wlan_cfg_set(vif, 0, WID_11N_TXOP_PROT_DISABLE, c_val, 1, 0,
+			       0))
+		goto fail;
+
+	c_val[0] = DETECT_PROTECT_REPORT;
+	if (!wilc_wlan_cfg_set(vif, 0, WID_11N_OBSS_NONHT_DETECTION, c_val, 1,
+			       0, 0))
+		goto fail;
+
+	c_val[0] = RTS_CTS_NONHT_PROT;
+	if (!wilc_wlan_cfg_set(vif, 0, WID_11N_HT_PROT_TYPE, c_val, 1, 0, 0))
+		goto fail;
+
+	c_val[0] = 0;
+	if (!wilc_wlan_cfg_set(vif, 0, WID_11N_RIFS_PROT_ENABLE, c_val, 1, 0,
+			       0))
+		goto fail;
+
+	c_val[0] = 7;
+	if (!wilc_wlan_cfg_set(vif, 0, WID_11N_CURRENT_TX_MCS, c_val, 1, 0,
+			       0))
+		goto fail;
+
+	c_val[0] = 1;
+	if (!wilc_wlan_cfg_set(vif, 0, WID_11N_IMMEDIATE_BA_ENABLED, c_val, 1,
+			       1, 0))
+		goto fail;
+
+	return 0;
+
+fail:
+	return -1;
+}
+
+static int wlan_deinit_locks(struct net_device *dev)
+{
+	struct wilc_vif *vif;
+	struct wilc *wilc;
+
+	vif = netdev_priv(dev);
+	wilc = vif->wilc;
+
+	PRINT_INFO(vif->ndev, INIT_DBG, "De-Initializing Locks\n");
+
+	mutex_destroy(&wilc->hif_cs);
+	mutex_destroy(&wilc->rxq_cs);
+	mutex_destroy(&wilc->txq_add_to_head_cs);
+	mutex_destroy(&wilc->cs);
+
+	return 0;
+}
+static void wlan_deinitialize_threads(struct net_device *dev)
+{
+	struct wilc_vif *vif;
+	struct wilc *wl;
+
+	vif = netdev_priv(dev);
+	wl = vif->wilc;
+
+	PRINT_INFO(vif->ndev, INIT_DBG, "Deinitializing Threads\n");
+	if (!recovery_on) {
+		PRINT_INFO(vif->ndev, INIT_DBG, "Deinit debug Thread\n");
+		debug_running = false;
+		if (&wl->debug_thread_started)
+			complete(&wl->debug_thread_started);
+		if (wl->debug_thread) {
+			kthread_stop(wl->debug_thread);
+			wl->debug_thread = NULL;
+		}
+	}
+
+	wl->close = 1;
+	PRINT_INFO(vif->ndev, INIT_DBG,"Deinitializing Threads\n");
+
+	complete(&wl->txq_event);
+
+	if (wl->txq_thread) {
+		kthread_stop(wl->txq_thread);
+		wl->txq_thread = NULL;
+	}
+}
+
+static void wilc_wlan_deinitialize(struct net_device *dev)
+{
+	int ret;
+	struct wilc_vif *vif;
+	struct wilc *wl;
+
+	vif = netdev_priv(dev);
+	wl = vif->wilc;
+
+	if (wl->initialized) {
+		PRINT_INFO(vif->ndev, INIT_DBG, "Deinitializing wilc  ...\n");
+
+		if (!wl) {
+			PRINT_ER(dev, "wl is NULL\n");
+			return;
+		}
+
+		PRINT_INFO(vif->ndev, INIT_DBG, "Disabling IRQ\n");
+		if (wl->io_type == HIF_SPI ||
+			wl->io_type == HIF_SDIO_GPIO_IRQ) {
+			linux_wlan_disable_irq(wl, 1);
+		} else {
+			if (wl->hif_func->disable_interrupt) {
+				mutex_lock(&wl->hif_cs);
+				wl->hif_func->disable_interrupt(wl);
+				mutex_unlock(&wl->hif_cs);
+			}
+		}
+		complete(&wl->txq_event);
+
+		PRINT_INFO(vif->ndev, INIT_DBG, "Deinitializing Threads\n");
+		wlan_deinitialize_threads(dev);
+		PRINT_INFO(vif->ndev, INIT_DBG, "Deinitializing IRQ\n");
+		deinit_irq(dev);
+
+		ret = wilc_wlan_stop(wl);
+		if(ret == 0)
+			PRINT_ER(dev, "failed in wlan_stop\n");
+
+		PRINT_INFO(vif->ndev, INIT_DBG, "Deinitializing WILC Wlan\n");
+		wilc_wlan_cleanup(dev);
+
+		PRINT_INFO(vif->ndev, INIT_DBG, "Deinitializing Locks\n");
+		wlan_deinit_locks(dev);
+
+		wl->initialized = false;
+
+		PRINT_INFO(dev, INIT_DBG, "wilc deinitialization Done\n");
+	} else {
+		PRINT_INFO(dev, INIT_DBG, "wilc is not initialized\n");
+	}
+}
+
+static int wlan_init_locks(struct net_device *dev)
+{
+	struct wilc_vif *vif;
+	struct wilc *wl;
+
+	vif = netdev_priv(dev);
+	wl = vif->wilc;
+	PRINT_INFO(vif->ndev, INIT_DBG, "Initializing Locks ...\n");
+
+	mutex_init(&wl->rxq_cs);
+
+	spin_lock_init(&wl->txq_spinlock);
+	mutex_init(&wl->txq_add_to_head_cs);
+
+	init_completion(&wl->txq_event);
+	init_completion(&wl->cfg_event);
+	init_completion(&wl->sync_event);
+	init_completion(&wl->txq_thread_started);
+	init_completion(&wl->debug_thread_started);
+
+	return 0;
+}
+
+static int wlan_initialize_threads(struct net_device *dev)
+{
+	struct wilc_vif *vif;
+	struct wilc *wilc;
+
+	vif = netdev_priv(dev);
+	wilc = vif->wilc;
+
+	PRINT_INFO(vif->ndev, INIT_DBG, "Initializing Threads ...\n");
+	PRINT_INFO(vif->ndev, INIT_DBG, "Creating kthread for transmission\n");
+	wilc->txq_thread = kthread_run(linux_wlan_txq_task, (void *)dev,
+				       "K_TXQ_TASK");
+	if (IS_ERR(wilc->txq_thread)) {
+		PRINT_ER(dev, "couldn't create TXQ thread\n");
+		wilc->close = 1;
+		return PTR_ERR(wilc->txq_thread);
+	}
+	wait_for_completion(&wilc->txq_thread_started);
+
+	if (!debug_running) {
+		PRINT_INFO(vif->ndev, INIT_DBG,
+			   "Creating kthread for Debugging\n");
+		wilc->debug_thread = kthread_run(debug_thread,(void *)dev,
+						 "WILC_DEBUG");
+		if(IS_ERR(wilc->debug_thread)) {
+			PRINT_ER(dev, "couldn't create debug thread\n");
+			wilc->close = 1;
+			kthread_stop(wilc->txq_thread);
+			return PTR_ERR(wilc->debug_thread);
+		}
+		debug_running = true;
+		wait_for_completion(&wilc->debug_thread_started);
+	}
+
+	return 0;
+}
+
+static int wilc_wlan_initialize(struct net_device *dev, struct wilc_vif *vif)
+{
+	int ret = 0;
+	struct wilc *wl = vif->wilc;
+
+	if (!wl->initialized) {
+		wl->mac_status = MAC_STATUS_INIT;
+		wl->close = 0;
+		wl->initialized = 0;
+
+		wlan_init_locks(dev);
+
+		ret = wilc_wlan_init(dev);
+		if (ret < 0) {
+			PRINT_ER(dev, "Initializing WILC_Wlan FAILED\n");
+			ret = -EIO;
+			goto fail_locks;
+		}
+		PRINT_INFO(vif->ndev, GENERIC_DBG, "WILC Initialization done\n");
+		if (wl->gpio_irq >= 0 && init_irq(dev)) {
+			ret = -EIO;
+			goto fail_locks;
+		}
+
+		ret = wlan_initialize_threads(dev);
+		if (ret < 0) {
+			PRINT_ER(dev, "Initializing Threads FAILED\n");
+			ret = -EIO;
+			goto fail_wilc_wlan;
+		}
+
+		if (wl->io_type == HIF_SDIO &&
+		    wl->hif_func->enable_interrupt(wl)) {
+			PRINT_ER(dev, "couldn't initialize IRQ\n");
+			ret = -EIO;
+			goto fail_irq_init;
+		}
+
+		if (wilc_wlan_get_firmware(dev)) {
+			PRINT_ER(dev, "Can't get firmware\n");
+			ret = -EIO;
+			goto fail_irq_enable;
+		}
+
+		ret = wilc_firmware_download(dev);
+		if (ret < 0) {
+			PRINT_ER(dev, "Failed to download firmware\n");
+			ret = -EIO;
+			goto fail_irq_enable;
+		}
+
+		ret = linux_wlan_start_firmware(dev);
+		if (ret < 0) {
+			PRINT_ER(dev, "Failed to start firmware\n");
+			ret = -EIO;
+			goto fail_irq_enable;
+		}
+
+		if (wilc_wlan_cfg_get(vif, 1, WID_FIRMWARE_VERSION, 1, 0)) {
+			int size;
+			char firmware_ver[50];
+
+			size = wilc_wlan_cfg_get_val(vif, WID_FIRMWARE_VERSION,
+						     firmware_ver,
+						     sizeof(firmware_ver));
+			firmware_ver[size] = '\0';
+			PRINT_INFO(dev, INIT_DBG, "WILC Firmware Ver = %s\n", firmware_ver);
+		}
+		ret = linux_wlan_init_test_config(dev, vif);
+
+		if (ret < 0) {
+			PRINT_ER(dev, "Failed to configure firmware\n");
+			ret = -EIO;
+			goto fail_fw_start;
+		}
+	#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,15,0)
+		timer_setup(&wl->aging_timer, remove_network_from_shadow,
+		    (unsigned long)wl);
+	#else
+		setup_timer(&wl->aging_timer, remove_network_from_shadow,
+		    (unsigned long)wl);
+	#endif
+
+		wl->initialized = true;
+		return 0;
+
+fail_fw_start:
+		wilc_wlan_stop(wl);
+
+fail_irq_enable:
+		if (wl->io_type == HIF_SDIO)
+			wl->hif_func->disable_interrupt(wl);
+fail_irq_init:
+		if (wl->dev_irq_num)
+			deinit_irq(dev);
+
+		wlan_deinitialize_threads(dev);
+fail_wilc_wlan:
+		wilc_wlan_cleanup(dev);
+fail_locks:
+		wlan_deinit_locks(dev);
+		PRINT_ER(dev, "WLAN initialization FAILED\n");
+	} else {
+		PRINT_WRN(vif->ndev, INIT_DBG, "wilc already initialized\n");
+	}
+	return ret;
+}
+
+static int mac_init_fn(struct net_device *ndev)
+{
+	netif_start_queue(ndev);
+	netif_stop_queue(ndev);
+
+	return 0;
+}
+
+int wilc_bt_power_up(struct wilc *wilc, int source);
+int wilc_bt_power_down(struct wilc *wilc, int source);
+
+static int wilc_mac_open(struct net_device *ndev)
+{
+	struct wilc_vif *vif;
+
+	unsigned char mac_add[ETH_ALEN] = {0};
+	int ret = 0;
+	struct wilc *wl;
+
+	vif = netdev_priv(ndev);
+	wl = vif->wilc;
+
+	if (!wl || !wl->dev) {
+		PRINT_ER(ndev, "device not ready\n");
+		return -ENODEV;
+	}
+
+	PRINT_INFO(ndev, INIT_DBG, "MAC OPEN[%p] %s\n",ndev, ndev->name);
+
+	if(wl->open_ifcs == 0)
+		wilc_bt_power_up(wl, PWR_DEV_SRC_WIFI);
+
+	if(!recovery_on){
+		ret = wilc_init_host_int(ndev);
+		if (ret < 0) {
+			PRINT_ER(ndev, "Failed to initialize host interface\n");
+			return ret;
+		}
+	}
+
+	PRINT_INFO(vif->ndev, INIT_DBG,"*** re-init ***\n");
+	ret = wilc_wlan_initialize(ndev, vif);
+	if (ret < 0) {
+		PRINT_ER(ndev, "Failed to initialize wilc\n");
+		if(!recovery_on)
+			wilc_deinit_host_int(ndev);
+		return ret;
+	}
+
+	wait_for_recovery = 0;
+	if(!(memcmp(ndev->name, IFC_0, 5)))
+		vif->ifc_id = WLAN_IFC;
+	else if(!(memcmp(ndev->name, IFC_1, 4)))
+		vif->ifc_id = P2P_IFC;
+	else
+	{
+		PRINT_ER(vif->ndev, "Unknown interface name\n");
+		wilc_deinit_host_int(ndev);
+		wilc_wlan_deinitialize(ndev);
+		return -ENODEV;
+	}
+	wilc_set_wfi_drv_handler(vif, wilc_get_vif_idx(vif),
+				 vif->iftype, vif->ifc_id);
+	wilc_set_operation_mode(vif, vif->iftype);
+	wilc_get_mac_address(vif, mac_add);
+	PRINT_INFO(vif->ndev, INIT_DBG, "Mac address: %pM\n", mac_add);
+	memcpy(vif->src_addr, mac_add, ETH_ALEN);
+
+	memcpy(ndev->dev_addr, vif->src_addr, ETH_ALEN);
+
+	if (!is_valid_ether_addr(ndev->dev_addr)) {
+		PRINT_ER(ndev, "Wrong MAC address\n");
+		wilc_deinit_host_int(ndev);
+		wilc_wlan_deinitialize(ndev);
+		return -EINVAL;
+	}
+
+	wilc_mgmt_frame_register(vif->ndev->ieee80211_ptr->wiphy,
+				 vif->ndev->ieee80211_ptr,
+				 vif->frame_reg[0].type,
+				 vif->frame_reg[0].reg);
+	wilc_mgmt_frame_register(vif->ndev->ieee80211_ptr->wiphy,
+				 vif->ndev->ieee80211_ptr,
+				 vif->frame_reg[1].type,
+				 vif->frame_reg[1].reg);
+	netif_wake_queue(ndev);
+	wl->open_ifcs++;
+	vif->mac_opened = 1;
+	return 0;
+}
+
+static struct net_device_stats *mac_stats(struct net_device *dev)
+{
+	struct wilc_vif *vif = netdev_priv(dev);
+
+	return &vif->netstats;
+}
+
+static int wilc_set_mac_addr(struct net_device *dev, void *p)
+{
+	int result;
+	struct wilc_vif *vif = netdev_priv(dev);
+	struct sockaddr *addr = (struct sockaddr *)p;
+
+	/* configure new MAC address */
+	if (!is_valid_ether_addr(addr->sa_data)) {
+		PRINT_INFO(vif->ndev, INIT_DBG,"Invalid MAC address \n");
+		return -EINVAL;
+	}
+	
+	result = wilc_set_mac_address(vif,(u8 *)addr->sa_data);
+	ether_addr_copy(vif->bssid, addr->sa_data);
+	ether_addr_copy(vif->ndev->dev_addr, vif->bssid);
+
+	return result;
+}
+	
+static void wilc_set_multicast_list(struct net_device *dev)
+{
+	struct netdev_hw_addr *ha;
+	struct wilc_vif *vif;
+	int i = 0;
+
+	vif = netdev_priv(dev);
+
+	PRINT_INFO(vif->ndev, INIT_DBG,
+		   "Setting mcast List with count = %d. \n",dev->mc.count);
+	if (dev->flags & IFF_PROMISC) {
+		PRINT_INFO(vif->ndev, INIT_DBG,
+			   "Set promiscuous mode ON retrive all pkts\n");
+		return;
+	}
+
+	if (dev->flags & IFF_ALLMULTI ||
+	    dev->mc.count > WILC_MULTICAST_TABLE_SIZE) {
+		PRINT_INFO(vif->ndev, INIT_DBG,
+			   "Disable mcast filter retrive multicast pkts\n");
+		wilc_setup_multicast_filter(vif, false, 0);
+		return;
+	}
+
+	if (dev->mc.count == 0) {
+		PRINT_INFO(vif->ndev, INIT_DBG,
+			   "Enable mcast filter retrive directed pkts only\n");
+		wilc_setup_multicast_filter(vif, true, 0);
+		return;
+	}
+
+	netdev_for_each_mc_addr(ha, dev) {
+		memcpy(wilc_multicast_mac_addr_list[i], ha->addr, ETH_ALEN);
+		PRINT_INFO(vif->ndev, INIT_DBG, "Entry[%d]: %x:%x:%x:%x:%x:%x\n", i,
+			   wilc_multicast_mac_addr_list[i][0],
+			   wilc_multicast_mac_addr_list[i][1],
+			   wilc_multicast_mac_addr_list[i][2],
+			   wilc_multicast_mac_addr_list[i][3],
+			   wilc_multicast_mac_addr_list[i][4],
+			   wilc_multicast_mac_addr_list[i][5]);
+		i++;
+	}
+
+	wilc_setup_multicast_filter(vif, true, (dev->mc.count));
+}
+
+static void linux_wlan_tx_complete(void *priv, int status)
+{
+	struct tx_complete_data *pv_data = priv;
+
+	if (status == 1)
+		PRINT_INFO(pv_data->vif->ndev, TX_DBG,
+			  "Packet sentSize= %d Add= %p SKB= %p\n",
+			  pv_data->size,pv_data->buff, pv_data->skb);
+	else
+		PRINT_INFO(pv_data->vif->ndev, TX_DBG,
+			   "Couldn't send pkt Size= %d Add= %p SKB= %p\n",
+			   pv_data->size,pv_data->buff, pv_data->skb);
+	dev_kfree_skb(pv_data->skb);
+	kfree(pv_data);
+}
+
+netdev_tx_t wilc_mac_xmit(struct sk_buff *skb, struct net_device *ndev)
+{
+	struct wilc_vif *vif;
+	struct tx_complete_data *tx_data = NULL;
+	int queue_count;
+	char *udp_buf;
+	struct iphdr *ih;
+	struct ethhdr *eth_h;
+	struct wilc *wilc;
+
+	vif = netdev_priv(ndev);
+	wilc = vif->wilc;
+
+	PRINT_INFO(vif->ndev, TX_DBG,
+		   "Sending packet just received from TCP/IP\n");
+	if (skb->dev != ndev) {
+		PRINT_ER(ndev, "Packet not destined to this device\n");
+		return NETDEV_TX_OK;
+	}
+
+	tx_data = kmalloc(sizeof(*tx_data), GFP_ATOMIC);
+	if (!tx_data) {
+		PRINT_ER(ndev, "Failed to alloc memory for tx_data struct\n");
+		dev_kfree_skb(skb);
+		netif_wake_queue(ndev);
+		return NETDEV_TX_OK;
+	}
+
+	tx_data->buff = skb->data;
+	tx_data->size = skb->len;
+	tx_data->skb  = skb;
+
+	eth_h = (struct ethhdr *)(skb->data);
+	if (eth_h->h_proto == (0x8e88))
+		PRINT_INFO(ndev,TX_DBG, " EAPOL transmitted\n");
+
+	ih = (struct iphdr *)(skb->data + sizeof(struct ethhdr));
+
+	udp_buf = (char *)ih + sizeof(struct iphdr);
+	if ((udp_buf[1] == 68 && udp_buf[3] == 67) ||
+	    (udp_buf[1] == 67 && udp_buf[3] == 68))
+		PRINT_INFO(ndev, GENERIC_DBG,
+			   "DHCP Message transmitted, type:%x %x %x\n",
+			   udp_buf[248], udp_buf[249], udp_buf[250]);
+
+	PRINT_D(vif->ndev, TX_DBG,"Sending pkt Size= %d Add= %p SKB= %p\n",
+		tx_data->size,tx_data->buff,tx_data->skb);
+	PRINT_D(vif->ndev, TX_DBG, "Adding tx pkt to TX Queue\n");
+	vif->netstats.tx_packets++;
+	vif->netstats.tx_bytes += tx_data->size;
+	tx_data->bssid = wilc->vif[vif->idx]->bssid;
+	tx_data->vif = vif;
+	queue_count = wilc_wlan_txq_add_net_pkt(ndev, (void *)tx_data,
+						tx_data->buff, tx_data->size,
+						linux_wlan_tx_complete);
+
+	if (queue_count > FLOW_CONTROL_UPPER_THRESHOLD) {
+		netif_stop_queue(wilc->vif[0]->ndev);
+		netif_stop_queue(wilc->vif[1]->ndev);
+	}
+
+	return NETDEV_TX_OK;
+}
+
+static int wilc_mac_close(struct net_device *ndev)
+{
+	struct wilc_priv *priv;
+	struct wilc_vif *vif;
+	struct host_if_drv *hif_drv;
+	struct wilc *wl;
+
+	vif = netdev_priv(ndev);
+
+	if (!vif || !vif->ndev || !vif->ndev->ieee80211_ptr ||
+	    !vif->ndev->ieee80211_ptr->wiphy) {
+		PRINT_ER(ndev, "vif = NULL\n");
+		return 0;
+	}
+
+	priv = wiphy_priv(vif->ndev->ieee80211_ptr->wiphy);
+	wl = vif->wilc;
+
+	if (!priv) {
+		PRINT_ER(ndev, "priv = NULL\n");
+		return 0;
+	}
+
+	hif_drv = (struct host_if_drv *)priv->hif_drv;
+
+	PRINT_INFO(vif->ndev, GENERIC_DBG, "Mac close\n");
+
+	if (!wl) {
+		PRINT_ER(ndev, "wilc = NULL\n");
+		return 0;
+	}
+
+	if (!hif_drv) {
+		PRINT_ER(ndev, "hif_drv = NULL\n");
+		return 0;
+	}
+
+	if (wl->open_ifcs > 0) {
+		wl->open_ifcs--;
+	} else {
+		PRINT_ER(ndev,"MAC close called with no opened interfaces\n");
+		return 0;
+	}
+
+	if (vif->ndev) {
+		netif_stop_queue(vif->ndev);
+
+	if(!recovery_on)
+		wilc_deinit_host_int(vif->ndev);
+	}
+
+	if (wl->open_ifcs == 0) {
+		PRINT_INFO(ndev, GENERIC_DBG, "Deinitializing wilc\n");
+		wl->close = 1;
+		wilc_wlan_deinitialize(ndev);
+		WILC_WFI_deinit_mon_interface();
+	}
+
+	vif->mac_opened = 0;
+
+	return 0;
+}
+
+void wilc_frmw_to_linux(struct wilc *wilc, u8 *buff, u32 size, u32 pkt_offset,
+			u8 status)
+{
+	unsigned int frame_len = 0;
+	int stats;
+	unsigned char *buff_to_send = NULL;
+	struct sk_buff *skb;
+	struct net_device *wilc_netdev;
+	struct wilc_vif *vif;
+	struct wilc_priv *priv;
+	u8 null_bssid[ETH_ALEN] = {0};
+
+	if (!wilc)
+		return;
+
+	wilc_netdev = get_if_handler(wilc, buff);
+	if (!wilc_netdev)
+		return;
+
+	buff += pkt_offset;
+	vif = netdev_priv(wilc_netdev);
+	priv = wiphy_priv(vif->ndev->ieee80211_ptr->wiphy);
+
+	if (size > 0) {
+		frame_len = size;
+		buff_to_send = buff;
+
+		if(status == PKT_STATUS_NEW && buff_to_send[12] == 0x88 &&
+		   buff_to_send[13] == 0x8e &&
+		   (vif->iftype == STATION_MODE || vif->iftype == CLIENT_MODE) &&
+		   !memcmp(priv->associated_bss, null_bssid, ETH_ALEN)) {
+			if(!priv->buffered_eap) {
+				priv->buffered_eap = kmalloc(sizeof(struct
+								    wilc_buffered_eap),
+							     GFP_ATOMIC);
+				if(priv->buffered_eap) {
+					priv->buffered_eap->buff = NULL;
+					priv->buffered_eap->size = 0;
+					priv->buffered_eap->pkt_offset = 0;
+				} else {
+					PRINT_ER(wilc_netdev,
+						 "failed to alloc buffered_eap\n");
+					return;
+				}
+			} else {
+				kfree(priv->buffered_eap->buff );
+			}
+			priv->buffered_eap->buff = kmalloc(size + pkt_offset,
+							   GFP_ATOMIC);
+			priv->buffered_eap->size = size;
+			priv->buffered_eap->pkt_offset = pkt_offset;
+			memcpy(priv->buffered_eap->buff, buff -
+			       pkt_offset, size + pkt_offset);
+		#if LINUX_VERSION_CODE < KERNEL_VERSION(4,15,0)
+			priv->eap_buff_timer.data = (unsigned long) priv;
+		#endif
+			mod_timer(&priv->eap_buff_timer,(jiffies +
+                                      msecs_to_jiffies(10))) ;
+			return;
+		}
+		skb = dev_alloc_skb(frame_len);
+		if (!skb) {
+       	 		PRINT_ER(wilc_netdev, "Low memory - packet droped\n");
+			return;
+		}
+
+		if (wilc == NULL || wilc_netdev == NULL)
+			PRINT_ER(wilc_netdev, "wilc_netdev in wilc is NULL");
+		skb->dev = wilc_netdev;
+		if (skb->dev == NULL)
+			PRINT_ER(wilc_netdev, "skb->dev is NULL\n");
+	#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,13,0)
+		skb_put_data(skb, buff_to_send, frame_len);
+	#else
+		memcpy(skb_put(skb, frame_len), buff_to_send, frame_len);
+	#endif
+
+		skb->protocol = eth_type_trans(skb, wilc_netdev);
+		vif->netstats.rx_packets++;
+		vif->netstats.rx_bytes += frame_len;
+		skb->ip_summed = CHECKSUM_UNNECESSARY;
+		stats = netif_rx(skb);
+		PRINT_D(wilc_netdev, RX_DBG, "netif_rx ret value is: %d\n", stats);
+	} else {
+		PRINT_ER(wilc_netdev,
+			 "Discard sending packet with len = %d\n", size);
+	}
+}
+
+void wilc_wfi_mgmt_rx(struct wilc *wilc, u8 *buff, u32 size)
+{
+	int i = 0;
+	struct wilc_vif *vif;
+
+	for (i = 0; i <= wilc->vif_num; i++) {
+		vif = netdev_priv(wilc->vif[i]->ndev);
+		if (vif->monitor_flag) {
+			WILC_WFI_monitor_rx(vif, buff, size);
+			return;
+		}
+	}
+
+	vif = netdev_priv(wilc->vif[1]->ndev);
+	if ((buff[0] == vif->frame_reg[0].type && vif->frame_reg[0].reg) ||
+	    (buff[0] == vif->frame_reg[1].type && vif->frame_reg[1].reg))
+		wilc_wfi_p2p_rx(wilc->vif[1]->ndev, buff, size);
+}
+
+#ifdef DISABLE_PWRSAVE_AND_SCAN_DURING_IP
+static struct notifier_block g_dev_notifier = {
+	.notifier_call = dev_state_ev_handler
+};
+#endif
+
+void wilc_netdev_cleanup(struct wilc *wilc)
+{
+	int i;
+
+	if (wilc && wilc->firmware) {
+		release_firmware(wilc->firmware);
+		wilc->firmware = NULL;
+	}
+
+	if (wilc && (wilc->vif[0]->ndev || wilc->vif[1]->ndev)) {
+		for (i = 0; i < NUM_CONCURRENT_IFC; i++)
+			if (wilc->vif[i]->ndev)
+				if (wilc->vif[i]->mac_opened)
+					wilc_mac_close(wilc->vif[i]->ndev);
+
+		for (i = 0; i < NUM_CONCURRENT_IFC; i++) {
+			if(wilc->vif[i] && wilc->vif[i]->ndev) {
+				PRINT_INFO(wilc->vif[i]->ndev, INIT_DBG,
+					   "Unregistering netdev %p\n",
+					   wilc->vif[i]->ndev);
+				unregister_netdev(wilc->vif[i]->ndev);
+				PRINT_INFO(wilc->vif[i]->ndev, INIT_DBG,
+					   "Freeing Wiphy...\n");
+				wilc_free_wiphy(wilc->vif[i]->ndev);
+				PRINT_INFO(wilc->vif[i]->ndev, INIT_DBG,
+					   "Freeing netdev...\n");
+			}
+			free_netdev(wilc->vif[i]->ndev);
+		}
+	}
+
+	#ifdef DISABLE_PWRSAVE_AND_SCAN_DURING_IP
+		unregister_inetaddr_notifier(&g_dev_notifier);
+	#endif
+
+	kfree(wilc);
+	wilc_sysfs_exit();
+	wilc_debugfs_remove();
+	pr_info("Module_exit Done.\n");
+}
+
+static const struct net_device_ops wilc_netdev_ops = {
+	.ndo_init = mac_init_fn,
+	.ndo_open = wilc_mac_open,
+	.ndo_stop = wilc_mac_close,
+	.ndo_set_mac_address = wilc_set_mac_addr,
+	.ndo_start_xmit = wilc_mac_xmit,
+	.ndo_get_stats = mac_stats,
+	.ndo_set_rx_mode  = wilc_set_multicast_list,
+};
+
+int wilc_netdev_init(struct wilc **wilc, struct device *dev, int io_type,
+		     const struct wilc_hif_func *ops)
+{
+	int i, ret;
+	struct wilc_vif *vif;
+	struct net_device *ndev;
+	struct wilc *wl;
+	struct wireless_dev *wdev;
+
+	wilc_debugfs_init();
+	wl = kzalloc(sizeof(*wl), GFP_KERNEL);
+	if (!wl)
+		return -ENOMEM;
+
+	*wilc = wl;
+	wl->io_type = io_type;
+	wl->hif_func = ops;
+
+#ifdef DISABLE_PWRSAVE_AND_SCAN_DURING_IP
+	register_inetaddr_notifier(&g_dev_notifier);
+#endif
+
+	for (i = 0; i < NUM_CONCURRENT_IFC; i++) {
+		ndev = alloc_etherdev(sizeof(struct wilc_vif));
+		if (!ndev)
+			return -ENOMEM;
+
+		vif = netdev_priv(ndev);
+		memset(vif, 0, sizeof(struct wilc_vif));
+
+		if (i == 0)
+			strcpy(ndev->name, "wlan%d");
+		else
+			strcpy(ndev->name, "p2p%d");
+
+		wl->vif_num = i;
+		vif->idx = wl->vif_num;
+		vif->wilc = *wilc;
+		vif->ndev = ndev;
+		wl->vif[i] = vif;
+
+
+		ndev->netdev_ops = &wilc_netdev_ops;
+
+		wdev = wilc_create_wiphy(ndev, dev);
+
+		if (dev)
+			SET_NETDEV_DEV(ndev, dev);
+
+		if (!wdev) {
+			PRINT_ER(ndev, "Can't register WILC Wiphy\n");
+			return -1;
+		}
+
+		vif->ndev->ieee80211_ptr = wdev;
+		vif->ndev->ml_priv = vif;
+		wdev->netdev = vif->ndev;
+		vif->netstats.rx_packets = 0;
+		vif->netstats.tx_packets = 0;
+		vif->netstats.rx_bytes = 0;
+		vif->netstats.tx_bytes = 0;
+
+		ret = register_netdev(ndev);
+		if (ret) {
+			PRINT_ER(ndev, "Device couldn't be registered - %s\n",
+			       ndev->name);
+			return ret;
+		}
+
+		vif->iftype = STATION_MODE;
+		vif->mac_opened = 0;
+	}
+	wilc_sysfs_init(wl->vif[0], wl->vif[1]);
+
+	return 0;
+}
+
+static void wilc_wlan_power(struct wilc *wilc, int power)
+{
+	pr_info("wifi_pm : %d \n", power);
+	if (gpio_request(wilc->gpio_chip_en, "CHIP_EN") == 0 &&
+	    gpio_request(wilc->gpio_reset, "RESET") == 0) {
+		gpio_direction_output(wilc->gpio_chip_en, 0);
+		gpio_direction_output(wilc->gpio_reset, 0);
+		if (power) {
+			gpio_set_value(wilc->gpio_chip_en, 1);
+			mdelay(5);
+			gpio_set_value(wilc->gpio_reset, 1);
+		} else {
+			gpio_set_value(wilc->gpio_reset, 0);
+			gpio_set_value(wilc->gpio_chip_en, 0);
+		}
+		gpio_free(wilc->gpio_chip_en);
+		gpio_free(wilc->gpio_reset);
+	} else {
+		dev_err(wilc->dev,
+			"Error requesting GPIOs for CHIP_EN and RESET");
+	}
+}
+
+void wilc_wlan_power_on_sequence(struct wilc *wilc)
+{
+	wilc_wlan_power(wilc, 0);
+	wilc_wlan_power(wilc, 1);
+}
+
+void wilc_wlan_power_off_sequence(struct wilc *wilc)
+{
+	wilc_wlan_power(wilc, 0);
+}
+
+MODULE_LICENSE("GPL");
diff --git a/drivers/staging/wilc/linux_wlan.h b/drivers/staging/wilc/linux_wlan.h
new file mode 100755
index 0000000..05f58ea
--- /dev/null
+++ b/drivers/staging/wilc/linux_wlan.h
@@ -0,0 +1,71 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Atmel WILC 802.11 b/g/n driver
+ *
+ * Copyright (c) 2015 Atmel Corportation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef WILC_LINUX_WLAN_H
+#define WILC_LINUX_WLAN_H
+#include <linux/types.h>
+#include "wilc_wfi_netdevice.h"
+#include "wilc_wlan_if.h"
+#include <linux/skbuff.h>
+#include <linux/netdevice.h>
+
+#define IP_STATE_OBTAINING						1
+#define IP_STATE_OBTAINED						2
+#define IP_STATE_GO_ASSIGNING					3
+#define IP_STATE_DEFAULT							4
+
+
+void handle_pwrsave_during_obtainingIP(struct wilc_vif *vif, uint8_t state);
+void store_power_save_current_state(struct wilc_vif *vif, bool val);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,15,0)
+void clear_duringIP(struct timer_list *t);
+#else
+void clear_duringIP(unsigned long arg);
+#endif
+
+struct net_device* wilc_get_if_netdev(struct wilc *wilc, uint8_t ifc);
+struct host_if_drv * wilc_get_drv_handler_by_ifc(struct wilc *wilc, uint8_t ifc);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,14,0)
+static inline void ether_addr_copy(u8 *dst, const u8 *src)
+{
+#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)
+	*(u32 *)dst = *(const u32 *)src;
+	*(u16 *)(dst + 4) = *(const u16 *)(src + 4);
+#else
+	u16 *a = (u16 *)dst;
+	const u16 *b = (const u16 *)src;
+
+	a[0] = b[0];
+	a[1] = b[1];
+	a[2] = b[2];
+#endif
+}
+
+static inline bool ether_addr_equal_unaligned(const u8 *addr1, const u8 *addr2)
+{
+#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)
+	return ether_addr_equal(addr1, addr2);
+#else
+	return memcmp(addr1, addr2, ETH_ALEN) == 0;
+#endif
+}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(3,14,0) */
+
+#endif /* WILC_LINUX_WLAN_H */
diff --git a/drivers/staging/wilc/sysfs.c b/drivers/staging/wilc/sysfs.c
new file mode 100644
index 0000000..1f7a9d4
--- /dev/null
+++ b/drivers/staging/wilc/sysfs.c
@@ -0,0 +1,111 @@
+// SPDX-License-Identifier: GPL-2.0
+#include <linux/kobject.h>
+#include "wilc_wfi_cfgoperations.h"
+
+static struct kobject *wilc_kobj;
+static int device_created;
+static struct wilc_vif *vif[NUM_CONCURRENT_IFC];
+
+static ssize_t wilc_sysfs_show(struct kobject *kobj, struct kobj_attribute *attr,
+		      char *buf)
+{
+	int attr_val = -1;
+
+	if (strcmp(attr->attr.name, "p2p_mode") == 0)
+		attr_val = vif[0]->attr_sysfs.p2p_mode;
+	if (strcmp(attr->attr.name, "ant_swtch_mode") == 0)
+		attr_val = vif[0]->attr_sysfs.ant_swtch_mode;
+	else if(strcmp(attr->attr.name, "antenna1") == 0)
+		attr_val = vif[0]->attr_sysfs.antenna1;
+	else if(strcmp(attr->attr.name, "antenna2") == 0)
+		attr_val = vif[0]->attr_sysfs.antenna2;
+
+	return sprintf(buf, "%d\n", attr_val);
+}
+
+static ssize_t wilc_sysfs_store(struct kobject *kobj, struct kobj_attribute *attr,
+	const char *buf, size_t count)
+{
+	int attr_val;
+	int i;
+
+	for (i=0; i< NUM_CONCURRENT_IFC; i++) {
+		if(kstrtoint(buf, 10, &attr_val))
+			PRINT_ER(vif[i]->ndev, "Failed to convert p2p_mode string");
+		if (strcmp(attr->attr.name, "p2p_mode") == 0) {
+			vif[i]->attr_sysfs.p2p_mode = (attr_val?1:0);
+		} else if(strcmp(attr->attr.name, "ant_swtch_mode") == 0) {
+			if (attr_val > ANT_SWTCH_DUAL_GPIO_CTRL)
+				PRINT_ER(vif[i]->ndev, "Valid antenna switch modes: \n1-Single Antenna, 2-Dual Antenna\n");
+			else
+				vif[i]->attr_sysfs.ant_swtch_mode = attr_val;
+		} else if(strcmp(attr->attr.name, "antenna1") == 0) {
+			vif[i]->attr_sysfs.antenna1 = attr_val;
+		} else if(strcmp(attr->attr.name, "antenna2") == 0) {
+			vif[i]->attr_sysfs.antenna2 = attr_val;
+		}
+	}
+
+	return count;
+}
+
+static struct kobj_attribute p2p_mode_attr =
+	__ATTR(p2p_mode, 0664, wilc_sysfs_show, wilc_sysfs_store);
+
+static struct kobj_attribute ant_swtch_mode_attr =
+	__ATTR(ant_swtch_mode, 0664, wilc_sysfs_show, wilc_sysfs_store);
+
+static struct kobj_attribute ant_swtch_antenna1_attr =
+	__ATTR(antenna1, 0664, wilc_sysfs_show, wilc_sysfs_store);
+
+static struct kobj_attribute ant_swtch_antenna2_attr =
+	__ATTR(antenna2, 0664, wilc_sysfs_show, wilc_sysfs_store);
+
+
+static struct attribute *wilc_attrs[] = {
+	&p2p_mode_attr.attr,
+	&ant_swtch_mode_attr.attr,
+	&ant_swtch_antenna1_attr.attr,
+	&ant_swtch_antenna2_attr.attr,
+	NULL
+};
+
+static struct attribute_group attr_group = {
+   .attrs = wilc_attrs,
+};
+
+void wilc_sysfs_init(struct wilc_vif *vif1, struct wilc_vif *vif2)
+{
+	int retval;
+	int i;
+	
+	vif[0] = vif1;
+	vif[1] = vif2;
+
+	if(device_created)
+		return;
+
+	wilc_kobj = kobject_create_and_add("wilc", NULL);
+	if (!wilc_kobj) {
+		retval = -ENOMEM;
+		return;
+	}
+
+	for (i=0; i< NUM_CONCURRENT_IFC; i++) {
+		/* By default p2p mode is Group Owner */
+		vif[i]->attr_sysfs.p2p_mode = 1;
+		vif[i]->attr_sysfs.ant_swtch_mode = ANT_SWTCH_INVALID_GPIO_CTRL;
+		vif[i]->attr_sysfs.antenna1 =0xFF;
+		vif[i]->attr_sysfs.antenna2 = 0xFF;
+	}	
+	retval = sysfs_create_group(wilc_kobj, &attr_group);
+	device_created = 1;
+}
+
+void wilc_sysfs_exit(void)
+{
+	device_created=0;
+	sysfs_remove_group(wilc_kobj, &attr_group);
+	kobject_put(wilc_kobj);
+}
+
diff --git a/drivers/staging/wilc/wilc_bt.c b/drivers/staging/wilc/wilc_bt.c
new file mode 100644
index 0000000..e944e4c
--- /dev/null
+++ b/drivers/staging/wilc/wilc_bt.c
@@ -0,0 +1,658 @@
+// SPDX-License-Identifier: GPL-2.0
+#include <linux/fs.h>
+#include <linux/device.h>
+#include <linux/cdev.h>
+#include <linux/types.h>
+#include <linux/kdev_t.h>
+#include <linux/firmware.h>
+
+#include <linux/mmc/sdio.h>
+#include <linux/mmc/sdio_func.h>
+#include <linux/mmc/card.h>
+#include <linux/mmc/sdio_ids.h>
+#include <linux/mmc/sdio.h>
+#include <linux/mmc/host.h>
+
+#include "wilc_wfi_netdevice.h"
+
+static struct wilc *wilc_bt;
+static dev_t chc_dev_no; /* Global variable for the first device number */
+static struct cdev str_chc_dev; /* Global variable for the character */
+struct device *dev;
+static struct class *chc_dev_class; /* Global variable for the device class */
+static bool device_created;
+int bt_init_done=0;
+
+typedef void (wilc_cmd_handler)(char*);
+
+static void wilc_cmd_handle_bt_enable(char* param);
+static void wilc_cmd_handle_bt_power_up(char* param);
+static void wilc_cmd_handle_bt_power_down(char* param);
+static void wilc_cmd_handle_bt_fw_chip_wake_up(char* param);
+static void wilc_cmd_handle_bt_fw_chip_allow_sleep(char* param);
+static void wilc_cmd_handle_bt_download_fw(char* param);
+static void wilc_cmd_handle_wilc_cca_threshold(char* param);
+
+int wilc_bt_power_up(struct wilc *, int source);
+int wilc_bt_power_down(struct wilc *, int source);
+static void wilc_bt_firmware_download(struct wilc *);
+static void wilc_bt_start(struct wilc *);
+static int wilc_bt_dev_open(struct inode *i, struct file *f);
+static int wilc_bt_dev_close(struct inode *i, struct file *f);
+static ssize_t wilc_bt_dev_read(struct file *f, char __user *buf, size_t len,
+				loff_t *off);
+static ssize_t wilc_bt_dev_write(struct file *f, const char __user *buff,
+				 size_t len, loff_t *off);
+
+static const struct file_operations pugs_fops = {
+	.owner = THIS_MODULE,
+	.open = wilc_bt_dev_open,
+	.release = wilc_bt_dev_close,
+	.read = wilc_bt_dev_read,
+	.write = wilc_bt_dev_write
+};
+
+struct wilc_cmd_handle_entry {
+	const char *wilc_cmd_str;
+	wilc_cmd_handler *wilc_handle_cmd;
+};
+
+static const struct wilc_cmd_handle_entry wilc_cmd_table[] = {
+	{"BT_DOWNLOAD_FW", wilc_cmd_handle_bt_download_fw},
+	{"BT_POWER_UP", wilc_cmd_handle_bt_power_up},
+	{"BT_POWER_DOWN", wilc_cmd_handle_bt_power_down},
+	{"BT_FW_CHIP_WAKEUP", wilc_cmd_handle_bt_fw_chip_wake_up},
+	{"BT_FW_CHIP_ALLOW_SLEEP", wilc_cmd_handle_bt_fw_chip_allow_sleep},
+	{"BT_ENABLE", wilc_cmd_handle_bt_enable},
+	{"CCA_THRESHOLD", wilc_cmd_handle_wilc_cca_threshold},
+	/* Keep the NULL handler at the end of the table */
+	{(const char *)NULL, NULL},
+};
+
+static int wilc_bt_dev_open(struct inode *i, struct file *f)
+{
+	pr_err("at_pwr_dev: open()\n");
+	return 0;
+}
+
+static int wilc_bt_dev_close(struct inode *i, struct file *f)
+{
+	pr_info("at_pwr_dev: close()\n");
+	return 0;
+}
+
+static ssize_t wilc_bt_dev_read(struct file *f, char __user *buf, size_t len,
+				loff_t *off)
+{
+	pr_debug("at_pwr_dev: read()\n");
+	return 0;
+}
+
+static ssize_t wilc_bt_dev_write(struct file *f, const char __user *buff,
+				 size_t len, loff_t *off)
+{
+	struct wilc_cmd_handle_entry *wilc_cmd_entry;
+	char *cmd_buff;
+
+	cmd_buff = kmalloc(sizeof(char) * len, GFP_KERNEL);
+
+	if(copy_from_user(cmd_buff, buff, len))
+		return -EIO;
+
+	if (len > 0) {
+		pr_debug("received %s, len %d\n", cmd_buff, len);
+		// call the appropriate command handler
+		wilc_cmd_entry = (struct wilc_cmd_handle_entry *)wilc_cmd_table;
+		while (wilc_cmd_entry->wilc_handle_cmd != NULL) {
+			if (strncmp(wilc_cmd_entry->wilc_cmd_str, cmd_buff,
+				    strlen(wilc_cmd_entry->wilc_cmd_str)) == 0) {
+				pr_debug("param len: %d, string: %s\n", len - strlen(wilc_cmd_entry->wilc_cmd_str), cmd_buff);
+				wilc_cmd_entry->wilc_handle_cmd(cmd_buff + strlen(wilc_cmd_entry->wilc_cmd_str));
+				break;
+			}
+			wilc_cmd_entry++;
+		}
+	} else {
+		pr_debug("received invalid size <=0: %d\n", len);
+	}
+	kfree(cmd_buff);
+	return len;
+}
+
+static void wilc_bt_create_device(void)
+{
+	int ret = 0;
+
+	if (device_created)
+		return;
+
+	ret = alloc_chrdev_region(&chc_dev_no, 0, 1, "atmel");
+	if (ret < 0)
+		return;
+	chc_dev_class = class_create(THIS_MODULE, "atmel");
+	if (IS_ERR(chc_dev_class)) {
+		unregister_chrdev_region(chc_dev_no, 1);
+		return;
+	}
+	dev = device_create(chc_dev_class, NULL, chc_dev_no, NULL,
+			    "wilc_bt");
+	if (IS_ERR(dev)) {
+		class_destroy(chc_dev_class);
+		unregister_chrdev_region(chc_dev_no, 1);
+		return;
+	}
+
+	cdev_init(&str_chc_dev, &pugs_fops);
+	ret = cdev_add(&str_chc_dev, chc_dev_no, 1);
+	if (ret < 0) {
+		device_destroy(chc_dev_class, chc_dev_no);
+		class_destroy(chc_dev_class);
+		unregister_chrdev_region(chc_dev_no, 1);
+		return;
+	}
+	mutex_init(&wilc_bt->cs);
+	device_created = 1;
+}
+
+static void wilc_cmd_handle_wilc_cca_threshold(char* param)
+{
+	int carrier_thrshold, noise_thrshold;
+	unsigned int carr_thrshold_frac, noise_thrshold_frac, carr_thrshold_int,
+		noise_thrshold_int, reg;
+
+	if(param == NULL) {
+		pr_err("Invalid parameter\n");
+		return;
+	}
+
+	if(sscanf(param, " %d %d", &noise_thrshold, &carrier_thrshold) != 2) {
+		pr_err("Failed to parse input parameters. Usage:\n echo CCA_THRESHOLD "
+			"NOISE_THRESHOLD CARRIER_THRESHOLD > /dev/at_pwr_dev\n"
+			"where threshold values are in dB * 10\ne.g."
+			"echo CCA_THRESHOLD -625 -826 > /dev/at_pwr_dev to set thresholds "
+			"to -62.5 and -82.6\n\n");
+		return;
+	}
+
+	pr_info("Changing CCA noise threshold to %d and carrier thresholds to %d \n",
+		noise_thrshold, carrier_thrshold);
+
+	carr_thrshold_int = carrier_thrshold/10;
+	if(carrier_thrshold < 0)
+		carr_thrshold_frac = (carr_thrshold_int * 10) - carrier_thrshold;
+	else
+		carr_thrshold_frac = carrier_thrshold - (carr_thrshold_int * 10);
+
+	noise_thrshold_int = noise_thrshold/10;
+	if(noise_thrshold < 0)
+		noise_thrshold_frac = (noise_thrshold_int * 10) - noise_thrshold;
+	else
+		noise_thrshold_frac = noise_thrshold - (noise_thrshold_int * 10);
+
+	wilc_bt->hif_func->hif_read_reg(wilc_bt, CCA_CTL_2, &reg);
+	reg &= ~(0x7FF0000);
+	reg |= ((noise_thrshold_frac & 0x7) | ((noise_thrshold_int & 0x1FF) << 3)) << 16;
+	wilc_bt->hif_func->hif_write_reg(wilc_bt, CCA_CTL_2, reg);
+
+	wilc_bt->hif_func->hif_read_reg(wilc_bt, CCA_CTL_7, &reg);
+	reg &= ~(0x7FF0000);
+	reg |= ((carr_thrshold_frac & 0x7) | ((carr_thrshold_int & 0x1FF) << 3)) << 16;
+	wilc_bt->hif_func->hif_write_reg(wilc_bt, CCA_CTL_7, reg);
+
+	return;
+}
+
+int wilc_bt_power_up(struct wilc *wilc, int source)
+{
+	int count=0;
+	int ret;
+	int reg;
+
+	mutex_lock(&wilc->cs);
+
+	pr_debug("source: %s, current bus status Wifi: %d, BT: %d\n",
+		 (source == PWR_DEV_SRC_WIFI ? "Wifi" : "BT"),
+		 wilc->power_status[PWR_DEV_SRC_WIFI],
+		 wilc->power_status[PWR_DEV_SRC_BT]);
+
+	if (wilc->power_status[source] == true) {
+		pr_err("power up request for already powered up source %s\n",
+			 (source == PWR_DEV_SRC_WIFI ? "Wifi" : "BT"));
+		}
+	else
+	{
+		/*Bug 215*/
+		/*Avoid overlapping between BT and Wifi intialization*/
+		if((wilc->power_status[PWR_DEV_SRC_WIFI]==true))
+		{
+			while(!wilc->initialized)
+			{
+				msleep(100);
+				if(++count>20)
+				{
+					pr_warn("Wifi took too much time to initialize \n");
+					break;
+				}
+			}
+		}
+		else if((wilc->power_status[PWR_DEV_SRC_BT]==true))
+		{
+			while(!bt_init_done)
+			{
+				msleep(200);
+				if(++count>30)
+				{
+					pr_warn("BT has taken too much time to initialize \n");
+					break;
+				}
+			}
+			/*An additional wait to give BT firmware time to do CPLL update as the time
+			measured since the start of BT Fw till the end of function "rf_nmi_init_tuner" was 71.2 ms */
+			msleep(100);
+		}
+	}
+
+	if ((wilc->power_status[PWR_DEV_SRC_WIFI] == true) ||
+		   (wilc->power_status[PWR_DEV_SRC_BT] == true)) {
+		pr_info("Device already up. request source is %s\n",
+			 (source == PWR_DEV_SRC_WIFI ? "Wifi" : "BT"));
+	} else {
+		pr_info("WILC POWER UP\n");
+	}
+	wilc->power_status[source] = true;
+	mutex_unlock(&wilc->cs);
+
+	if(source == PWR_DEV_SRC_BT)
+	{
+		/*TicketId1092*/
+		/*If WiFi is off, force BT*/
+		if(wilc->power_status[PWR_DEV_SRC_WIFI] == false)
+		{
+			acquire_bus(wilc, ACQUIRE_AND_WAKEUP,PWR_DEV_SRC_BT);
+
+			/*TicketId1115*/
+			/*Disable awake coex null frames*/
+			ret = wilc->hif_func->hif_read_reg(wilc, WILC_COE_AUTO_PS_ON_NULL_PKT, &reg);
+			if (!ret) {
+				pr_err("[wilc start]: fail read reg %x ...\n", WILC_COE_AUTO_PS_ON_NULL_PKT);
+				goto fail;
+			}
+			reg &= ~BIT(30);
+			ret = wilc->hif_func->hif_write_reg(wilc, WILC_COE_AUTO_PS_ON_NULL_PKT, reg);
+			if (!ret) {
+				pr_err( "[wilc start]: fail write reg %x ...\n", WILC_COE_AUTO_PS_ON_NULL_PKT);
+				goto fail;
+			}
+
+			/*TicketId1115*/
+			/*Disable doze coex null frames*/
+			ret = wilc->hif_func->hif_read_reg(wilc, WILC_COE_AUTO_PS_OFF_NULL_PKT, &reg);
+			if (!ret) {
+				pr_err("[wilc start]: fail read reg %x ...\n", WILC_COE_AUTO_PS_OFF_NULL_PKT);
+				goto fail;
+			}
+			reg &= ~BIT(30);
+			ret = wilc->hif_func->hif_write_reg(wilc, WILC_COE_AUTO_PS_OFF_NULL_PKT, reg);
+			if (!ret) {
+				pr_err( "[wilc start]: fail write reg %x ...\n", WILC_COE_AUTO_PS_OFF_NULL_PKT);
+				goto fail;
+			}
+
+			release_bus(wilc, RELEASE_ALLOW_SLEEP, PWR_DEV_SRC_BT);
+		}
+
+		// Enable BT wakeup
+		acquire_bus(wilc, ACQUIRE_AND_WAKEUP, PWR_DEV_SRC_BT);
+
+		ret = wilc->hif_func->hif_read_reg(wilc, WILC_PWR_SEQ_MISC_CTRL, &reg);
+		if (!ret) {
+			pr_err( "[wilc start]: fail read reg %x ...\n", WILC_PWR_SEQ_MISC_CTRL);
+			goto fail;
+		}
+		reg |= BIT(29);
+		ret = wilc->hif_func->hif_write_reg(wilc, WILC_PWR_SEQ_MISC_CTRL, reg);
+		if (!ret) {
+			pr_err( "[wilc start]: fail write reg %x ...\n", WILC_PWR_SEQ_MISC_CTRL);
+			goto fail;
+		}
+
+		release_bus(wilc, RELEASE_ALLOW_SLEEP, PWR_DEV_SRC_BT);
+	}
+
+	return 0;
+
+fail:
+	release_bus(wilc, RELEASE_ALLOW_SLEEP, PWR_DEV_SRC_BT);
+	wilc_bt_power_down(wilc, PWR_DEV_SRC_BT);
+	return ret;
+}
+
+int wilc_bt_power_down(struct wilc *wilc, int source)
+{
+	if(source == PWR_DEV_SRC_BT)
+	{
+		int ret;
+		u32 reg;
+
+		pr_info("AT PWR: bt_power_down\n");
+
+		/* Adjust coexistence module. This should be done from the FW in the future*/
+		acquire_bus(wilc, ACQUIRE_AND_WAKEUP, PWR_DEV_SRC_BT);
+
+		ret = wilc->hif_func->hif_read_reg(wilc, WILC_GLOBAL_MODE_CONTROL, &reg);
+		if (!ret) {
+			pr_err("[wilc start]: fail read reg %x ...\n",
+			       WILC_GLOBAL_MODE_CONTROL);
+			release_bus(wilc, RELEASE_ALLOW_SLEEP, PWR_DEV_SRC_BT);
+			return ret;
+		}
+		/* Clear BT mode*/
+		reg &= ~BIT(1);
+		ret = wilc->hif_func->hif_write_reg(wilc, WILC_GLOBAL_MODE_CONTROL, reg);
+		if (!ret) {
+			pr_err("[wilc start]: fail write reg %x ...\n",
+			       WILC_GLOBAL_MODE_CONTROL);
+			release_bus(wilc, RELEASE_ALLOW_SLEEP, PWR_DEV_SRC_BT);
+			return ret;
+		}
+
+
+		/*TicketId1115*/
+		/*Disable awake coex null frames*/
+		ret = wilc->hif_func->hif_read_reg(wilc, WILC_COE_AUTO_PS_ON_NULL_PKT, &reg);
+		if (!ret) {
+			pr_err("[wilc start]: fail read reg %x ...\n", WILC_COE_AUTO_PS_ON_NULL_PKT);
+			release_bus(wilc, RELEASE_ALLOW_SLEEP, PWR_DEV_SRC_BT);
+			return ret;
+		}
+		reg &= ~BIT(30);
+		ret = wilc->hif_func->hif_write_reg(wilc, WILC_COE_AUTO_PS_ON_NULL_PKT, reg);
+		if (!ret) {
+			pr_err( "[wilc start]: fail write reg %x ...\n", WILC_COE_AUTO_PS_ON_NULL_PKT);
+			release_bus(wilc, RELEASE_ALLOW_SLEEP, PWR_DEV_SRC_BT);
+			return ret;
+		}
+
+		/*TicketId1115*/
+		/*Disable doze coex null frames*/
+		ret = wilc->hif_func->hif_read_reg(wilc, WILC_COE_AUTO_PS_OFF_NULL_PKT, &reg);
+		if (!ret) {
+			pr_err("[wilc start]: fail read reg %x ...\n", WILC_COE_AUTO_PS_OFF_NULL_PKT);
+			release_bus(wilc, RELEASE_ALLOW_SLEEP, PWR_DEV_SRC_BT);
+			return ret;
+		}
+		reg &= ~BIT(30);
+		ret = wilc->hif_func->hif_write_reg(wilc, WILC_COE_AUTO_PS_OFF_NULL_PKT, reg);
+		if (!ret) {
+			pr_err( "[wilc start]: fail write reg %x ...\n", WILC_COE_AUTO_PS_OFF_NULL_PKT);
+			release_bus(wilc, RELEASE_ALLOW_SLEEP, PWR_DEV_SRC_BT);
+			return ret;
+		}
+		// Disable BT wakeup
+		ret = wilc->hif_func->hif_read_reg(wilc, WILC_PWR_SEQ_MISC_CTRL, &reg);
+		if (!ret) {
+			pr_err( "[wilc start]: fail read reg %x ...\n", WILC_PWR_SEQ_MISC_CTRL);
+			release_bus(wilc, RELEASE_ALLOW_SLEEP, PWR_DEV_SRC_BT);
+			return ret;
+		}
+		reg &= ~ BIT(29);
+		ret = wilc->hif_func->hif_write_reg(wilc, WILC_PWR_SEQ_MISC_CTRL, reg);
+		if (!ret) {
+			pr_err( "[wilc start]: fail write reg %x ...\n", WILC_PWR_SEQ_MISC_CTRL);
+			release_bus(wilc, RELEASE_ALLOW_SLEEP, PWR_DEV_SRC_BT);
+			return ret;
+		}
+
+		release_bus(wilc, RELEASE_ALLOW_SLEEP, PWR_DEV_SRC_BT);
+
+		bt_init_done=0;
+	}
+
+	mutex_lock(&wilc->cs);
+
+	pr_info("source: %s, current bus status Wifi: %d, BT: %d\n",
+		 (source == PWR_DEV_SRC_WIFI ? "Wifi" : "BT"),
+		 wilc->power_status[PWR_DEV_SRC_WIFI],
+		 wilc->power_status[PWR_DEV_SRC_BT]);
+
+	if (wilc->power_status[source] == false) {
+		pr_err("power down request for already powered down source %s\n",
+		       (source == PWR_DEV_SRC_WIFI ? "Wifi" : "BT"));
+	} else if (((source == PWR_DEV_SRC_WIFI) &&
+		  (wilc->power_status[PWR_DEV_SRC_BT] == true)) ||
+		  ((source == PWR_DEV_SRC_BT) &&
+		  (wilc->power_status[PWR_DEV_SRC_WIFI] == true))) {
+		pr_warn("Another device is preventing power down. request source is %s\n",
+			(source == PWR_DEV_SRC_WIFI ? "Wifi" : "BT"));
+	} else {
+		wilc_wlan_power_off_sequence(wilc);
+	}
+	wilc->power_status[source] = false;
+
+	mutex_unlock(&wilc->cs);
+
+	return 0;
+}
+
+static void wilc_bt_firmware_download(struct wilc *wilc)
+{
+	u32 offset;
+	u32 addr, size, size2, blksz;
+	u8 *dma_buffer;
+	const struct firmware *wilc_bt_firmware;
+	const u8 *buffer;
+	size_t buffer_size;
+	int ret = 0;
+	u32 reg;
+
+	pr_info("Bluetooth firmware: %s\n", FIRMWARE_WILC3000_BLE);
+	if (request_firmware(&wilc_bt_firmware, FIRMWARE_WILC3000_BLE, dev) != 0) {
+		pr_err("%s - firmare not available. Skip!\n", FIRMWARE_WILC3000_BLE);
+		ret = -1;
+		goto fail_1;
+	}
+
+	buffer = wilc_bt_firmware->data;
+	buffer_size = (size_t)wilc_bt_firmware->size;
+	if (buffer_size <= 0) {
+		pr_err("Firmware size = 0!\n");
+		ret = -1;
+		goto fail_1;
+	}
+
+	acquire_bus(wilc, ACQUIRE_AND_WAKEUP, PWR_DEV_SRC_BT);
+
+	ret = wilc->hif_func->hif_write_reg(wilc, 0x4f0000, 0x71);
+	if (!ret) {
+		pr_err("[wilc start]: fail write reg 0x4f0000 ...\n");
+		release_bus(wilc,RELEASE_ALLOW_SLEEP, PWR_DEV_SRC_BT);
+		goto fail_1;
+	}
+
+	/*
+	 * Avoid booting from BT boot ROM. Make sure that Drive IRQN [SDIO platform]
+	 * or SD_DAT3 [SPI platform] to ?1?
+	 */
+	/* Set cortus reset register to register control. */
+	ret = wilc->hif_func->hif_read_reg(wilc, 0x3b0090, &reg);
+	if (!ret) {
+		pr_err("[wilc start]: fail read reg 0x3b0090 ...\n");
+		release_bus(wilc, RELEASE_ALLOW_SLEEP, PWR_DEV_SRC_BT);
+		goto fail_1;
+	}
+
+	reg |= (1 << 0);
+	ret = wilc->hif_func->hif_write_reg(wilc, 0x3b0090, reg);
+	if (!ret) {
+		pr_err("[wilc start]: fail write reg 0x3b0090 ...\n");
+		release_bus(wilc, RELEASE_ALLOW_SLEEP, PWR_DEV_SRC_BT);
+		goto fail_1;
+	}
+
+	wilc->hif_func->hif_read_reg(wilc, 0x3B0400, &reg);
+
+	if (reg & (1ul << 2)) {
+		reg &= ~(1ul << 2);
+	} else {
+		reg |= (1ul << 2);
+		wilc->hif_func->hif_write_reg(wilc, 0x3B0400, reg);
+		reg &= ~(1ul << 2);
+	}
+	wilc->hif_func->hif_write_reg(wilc, 0x3B0400, reg);
+
+		release_bus(wilc, RELEASE_ALLOW_SLEEP, PWR_DEV_SRC_BT);
+
+	/* blocks of sizes > 512 causes the wifi to hang! */
+	blksz = (1ul << 9);
+	/* Allocate a DMA coherent  buffer. */
+	dma_buffer = kmalloc(blksz, GFP_KERNEL);
+	if (dma_buffer == NULL) {
+		ret = -5;
+		pr_err("Can't allocate buffer for BT firmware download IO error\n");
+		goto fail_1;
+	}
+	pr_info("Downloading BT firmware size = %d ...\n", buffer_size);
+
+	offset = 0;
+	addr = 0x400000;
+	size = buffer_size;
+	addr = cpu_to_le32(addr);
+	size = cpu_to_le32(size);
+	offset = 0;
+
+	while (((int)size) && (offset < buffer_size)) {
+		if (size <= blksz)
+			size2 = size;
+		else
+			size2 = blksz;
+
+		/* Copy firmware into a DMA coherent buffer */
+		memcpy(dma_buffer, &buffer[offset], size2);
+
+		acquire_bus(wilc, ACQUIRE_AND_WAKEUP, PWR_DEV_SRC_BT);
+
+		ret = wilc->hif_func->hif_block_tx(wilc, addr, dma_buffer, size2);
+
+		release_bus(wilc, RELEASE_ALLOW_SLEEP, PWR_DEV_SRC_BT);
+
+		if (!ret)
+			break;
+
+		addr += size2;
+		offset += size2;
+		size -= size2;
+	}
+
+	if (!ret) {
+		ret = -5;
+		pr_err("Can't download BT firmware IO error\n");
+		goto fail;
+	}
+
+fail:
+	kfree(dma_buffer);
+fail_1:
+	pr_debug("Freeing BT FW buffer ...\n");
+	pr_debug("Releasing BT firmware\n");
+	release_firmware(wilc_bt_firmware);
+	return;
+}
+
+static void wilc_bt_start(struct wilc *wilc)
+{
+	u32 val32 = 0;
+
+	acquire_bus(wilc, ACQUIRE_AND_WAKEUP, PWR_DEV_SRC_BT);
+
+	pr_info("Starting BT firmware\n");
+	/*
+	 * Write the firmware download complete magic value 0x10ADD09E at
+	 * location 0xFFFF000C (Cortus map) or C000C (AHB map).
+	 * This will let the boot-rom code execute from RAM.
+	 */
+	wilc->hif_func->hif_write_reg(wilc, 0x4F000c, 0x10add09e);
+
+	wilc->hif_func->hif_read_reg(wilc, 0x3B0400, &val32);
+	val32 &= ~((1ul << 2) | (1ul << 3));
+	wilc->hif_func->hif_write_reg(wilc, 0x3B0400, val32);
+
+	msleep(100);
+
+	val32 |= ((1ul << 2) | (1ul << 3));
+
+	wilc->hif_func->hif_write_reg(wilc, 0x3B0400, val32);
+
+	pr_info("BT Start Succeeded\n");
+
+	release_bus(wilc, RELEASE_ALLOW_SLEEP, PWR_DEV_SRC_BT);
+}
+
+static void wilc_cmd_handle_bt_power_up(char* param)
+{
+	pr_info("AT PWR: bt_power_up\n");
+	bt_init_done=0;
+
+	if(!wilc_bt->initialized && !wilc_bt->hif_func->hif_is_init()) {
+		acquire_bus(wilc_bt, ACQUIRE_ONLY, PWR_DEV_SRC_BT);
+		if (!wilc_bt->hif_func->hif_init(wilc_bt, false)) {
+			release_bus(wilc_bt, RELEASE_ONLY, PWR_DEV_SRC_BT);
+			return;
+		}
+		release_bus(wilc_bt, RELEASE_ONLY, PWR_DEV_SRC_BT);
+	}
+
+	wilc_bt_power_up(wilc_bt, PWR_DEV_SRC_BT);
+}
+
+static void wilc_cmd_handle_bt_power_down(char* param)
+{
+	wilc_bt_power_down(wilc_bt, PWR_DEV_SRC_BT);
+}
+
+static void wilc_cmd_handle_bt_fw_chip_wake_up(char* param)
+{
+	chip_wakeup(wilc_bt, PWR_DEV_SRC_BT);
+}
+
+static void wilc_cmd_handle_bt_fw_chip_allow_sleep(char* param)
+{
+	bt_init_done=1;
+	chip_allow_sleep(wilc_bt, PWR_DEV_SRC_BT);
+}
+
+static void wilc_cmd_handle_bt_download_fw(char* param)
+{
+	pr_info("AT PWR: bt_download_fw\n");
+
+	wilc_bt_firmware_download(wilc_bt);
+	wilc_bt_start(wilc_bt);
+}
+
+static void wilc_cmd_handle_bt_enable(char* param)
+{
+	wilc_bt_power_up(wilc_bt, PWR_DEV_SRC_BT);
+	wilc_bt_firmware_download(wilc_bt);
+	wilc_bt_start(wilc_bt);
+}
+
+void wilc_bt_init(struct wilc *wilc)
+{
+	wilc_bt = wilc;
+	pr_debug("at_pwr_dev: init\n");
+	wilc_bt_create_device();
+}
+
+void wilc_bt_deinit(void)
+{
+	pr_info("at_pwr_dev: deinit\n");
+
+	if (&wilc_bt->cs != NULL)
+		mutex_destroy(&wilc_bt->cs);
+
+	cdev_del(&str_chc_dev);
+	device_created = 0;
+	device_destroy(chc_dev_class, chc_dev_no);
+	class_destroy(chc_dev_class);
+	unregister_chrdev_region(chc_dev_no, 1);
+	pr_info("at_pwr_dev: unregistered\n");
+}
diff --git a/drivers/staging/wilc1000/wilc_debugfs.c b/drivers/staging/wilc/wilc_debugfs.c
similarity index 62%
rename from drivers/staging/wilc1000/wilc_debugfs.c
rename to drivers/staging/wilc/wilc_debugfs.c
index ce54864..7d24a15 100644
--- a/drivers/staging/wilc1000/wilc_debugfs.c
+++ b/drivers/staging/wilc/wilc_debugfs.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * NewportMedia WiFi chipset driver test tools - wilc-debug
  * Copyright (c) 2012 NewportMedia Inc.
@@ -15,27 +16,22 @@
 #include <linux/poll.h>
 #include <linux/sched.h>
 
-#include "wilc_wlan_if.h"
+#include "wilc_debugfs.h"
 
 static struct dentry *wilc_dir;
 
 /*
  * ----------------------------------------------------------------------------
  */
-#define DEBUG           BIT(0)
-#define INFO            BIT(1)
-#define WRN             BIT(2)
-#define ERR             BIT(3)
-
-#define DBG_LEVEL_ALL	(DEBUG | INFO | WRN | ERR)
-static atomic_t WILC_DEBUG_LEVEL = ATOMIC_INIT(ERR);
-EXPORT_SYMBOL_GPL(WILC_DEBUG_LEVEL);
+atomic_t WILC_DEBUG_REGION = ATOMIC_INIT(INIT_DBG | GENERIC_DBG |
+										  CFG80211_DBG | HOSTAPD_DBG |
+										  PWRDEV_DBG);
 
 /*
  * ----------------------------------------------------------------------------
  */
 
-static ssize_t wilc_debug_level_read(struct file *file, char __user *userbuf,
+static ssize_t wilc_debug_region_read(struct file *file, char __user *userbuf,
 				     size_t count, loff_t *ppos)
 {
 	char buf[128];
@@ -45,13 +41,13 @@ static ssize_t wilc_debug_level_read(struct file *file, char __user *userbuf,
 	if (*ppos > 0)
 		return 0;
 
-	res = scnprintf(buf, sizeof(buf), "Debug Level: %x\n",
-			atomic_read(&WILC_DEBUG_LEVEL));
+	res = scnprintf(buf, sizeof(buf), "Debug Region: (0x%08x)\n",
+				    atomic_read(&WILC_DEBUG_REGION));
 
 	return simple_read_from_buffer(userbuf, count, ppos, buf, res);
 }
 
-static ssize_t wilc_debug_level_write(struct file *filp,
+static ssize_t wilc_debug_region_write(struct file *filp,
 				      const char __user *buf, size_t count,
 				      loff_t *ppos)
 {
@@ -62,18 +58,16 @@ static ssize_t wilc_debug_level_write(struct file *filp,
 	if (ret)
 		return ret;
 
-	if (flag > DBG_LEVEL_ALL) {
-		pr_info("%s, value (0x%08x) is out of range, stay previous flag (0x%08x)\n",
-			__func__, flag, atomic_read(&WILC_DEBUG_LEVEL));
+	if (flag > DBG_REGION_ALL) {
+		pr_err("%s, value (0x%08x) is out of range, stay previous flag (0x%08x)\n",
+			   __func__, flag, atomic_read(&WILC_DEBUG_REGION));
+		pr_err("allowed bits are 0 to 15\n");
 		return -EINVAL;
 	}
 
-	atomic_set(&WILC_DEBUG_LEVEL, (int)flag);
+	atomic_set(&WILC_DEBUG_REGION, (int)flag);
 
-	if (flag == 0)
-		pr_info("Debug-level disabled\n");
-	else
-		pr_info("Debug-level enabled\n");
+	pr_info("Debug region set to %x\n", atomic_read(&WILC_DEBUG_REGION));
 
 	return count;
 }
@@ -99,19 +93,23 @@ struct wilc_debugfs_info_t {
 
 static struct wilc_debugfs_info_t debugfs_info[] = {
 	{
-		"wilc_debug_level",
+		"wilc_debug_region",
 		0666,
-		(DEBUG | ERR),
-		FOPS(NULL, wilc_debug_level_read, wilc_debug_level_write, NULL),
+		0,
+		FOPS(NULL, wilc_debug_region_read, wilc_debug_region_write, NULL),
 	},
 };
 
-static int __init wilc_debugfs_init(void)
+int wilc_debugfs_init(void)
 {
 	int i;
 	struct wilc_debugfs_info_t *info;
 
-	wilc_dir = debugfs_create_dir("wilc_wifi", NULL);
+	wilc_dir = debugfs_create_dir("wilc", NULL);
+	if(wilc_dir == NULL) {
+		pr_err("Error creating debugfs\n");
+		return -EFAULT;
+	}
 	for (i = 0; i < ARRAY_SIZE(debugfs_info); i++) {
 		info = &debugfs_info[i];
 		debugfs_create_file(info->name,
@@ -122,12 +120,10 @@ static int __init wilc_debugfs_init(void)
 	}
 	return 0;
 }
-module_init(wilc_debugfs_init);
 
-static void __exit wilc_debugfs_remove(void)
+void wilc_debugfs_remove(void)
 {
 	debugfs_remove_recursive(wilc_dir);
 }
-module_exit(wilc_debugfs_remove);
 
 #endif
diff --git a/drivers/staging/wilc/wilc_debugfs.h b/drivers/staging/wilc/wilc_debugfs.h
new file mode 100755
index 0000000..531ffba
--- /dev/null
+++ b/drivers/staging/wilc/wilc_debugfs.h
@@ -0,0 +1,54 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Atmel WILC 802.11 b/g/n driver
+ *
+ * Copyright (c) 2015 Atmel Corportation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef WILC_DEBUGFS_H
+#define WILC_DEBUGFS_H
+
+#include <linux/kern_levels.h>
+
+#define GENERIC_DBG	  		BIT(0)
+#define HOSTAPD_DBG       	BIT(1)
+#define HOSTINF_DBG	  		BIT(2)
+#define CORECONFIG_DBG  	BIT(3)
+#define CFG80211_DBG      	BIT(4)
+#define INT_DBG		  		BIT(5)
+#define TX_DBG		 		BIT(6)
+#define RX_DBG		 		BIT(7)
+#define TCP_ENH	  			BIT(8)
+#define INIT_DBG	  	  	BIT(9)
+#define PWRDEV_DBG	  		BIT(10)
+#define DBG_REGION_ALL		(BIT(11)-1)
+
+extern atomic_t WILC_DEBUG_REGION;
+
+#define PRINT_D(netdev, region,format,...)	do{ if(atomic_read(&WILC_DEBUG_REGION)&(region))\
+	netdev_dbg(netdev, "DBG [%s: %d] "format,__FUNCTION__,__LINE__, ##__VA_ARGS__);}while(0)
+							
+#define PRINT_INFO(netdev, region, format,...) do{ if(atomic_read(&WILC_DEBUG_REGION)&(region))\
+	netdev_info(netdev, "INFO [%s]"format,__FUNCTION__, ##__VA_ARGS__);}while(0)
+
+#define PRINT_WRN(netdev, region, format,...) do{ if(atomic_read(&WILC_DEBUG_REGION)&(region))\
+	netdev_warn(netdev, "WRN [%s: %d]"format,__FUNCTION__,__LINE__, ##__VA_ARGS__);}while(0)
+
+#define PRINT_ER(netdev, format,...) do{ netdev_err(netdev, "ERR [%s: %d] "format,\
+	__FUNCTION__,__LINE__, ##__VA_ARGS__);}while(0)
+
+int wilc_debugfs_init(void);
+void wilc_debugfs_remove(void);
+#endif /* WILC_DEBUGFS_H */
diff --git a/drivers/staging/wilc1000/wilc_sdio.c b/drivers/staging/wilc/wilc_sdio.c
similarity index 72%
rename from drivers/staging/wilc1000/wilc_sdio.c
rename to drivers/staging/wilc/wilc_sdio.c
index 0189e3e..6fb9b7d 100644
--- a/drivers/staging/wilc1000/wilc_sdio.c
+++ b/drivers/staging/wilc/wilc_sdio.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Copyright (c) Atmel Corporation.  All rights reserved.
  *
@@ -15,7 +16,19 @@
 #include <linux/mmc/host.h>
 #include <linux/of_gpio.h>
 
-#define SDIO_MODALIAS "wilc1000_sdio"
+void chip_wakeup(struct wilc *wilc, int source);
+void chip_allow_sleep(struct wilc *wilc, int source);
+
+enum sdio_host_lock {
+	WILC_SDIO_HOST_NO_TAKEN = 0,
+	WILC_SDIO_HOST_IRQ_TAKEN = 1,
+	WILC_SDIO_HOST_DIS_TAKEN = 2,
+};
+
+static enum sdio_host_lock	sdio_intr_lock = WILC_SDIO_HOST_NO_TAKEN;
+static wait_queue_head_t sdio_intr_waitqueue;
+
+#define SDIO_MODALIAS "wilc_sdio"
 
 #define SDIO_VENDOR_ID_WILC 0x0296
 #define SDIO_DEVICE_ID_WILC 0x5347
@@ -31,8 +44,7 @@ struct wilc_sdio {
 	bool irq_gpio;
 	u32 block_size;
 	int nint;
-#define MAX_NUN_INT_THRPT_ENH2 (5) /* Max num interrupts allowed in registers 0xf7, 0xf8 */
-	int has_thrpt_enh3;
+	bool is_init;
 };
 
 static struct wilc_sdio g_sdio;
@@ -44,9 +56,14 @@ static int sdio_init(struct wilc *wilc, bool resume);
 
 static void wilc_sdio_interrupt(struct sdio_func *func)
 {
+	if (sdio_intr_lock == WILC_SDIO_HOST_DIS_TAKEN)
+		return;
+	sdio_intr_lock = WILC_SDIO_HOST_IRQ_TAKEN;
 	sdio_release_host(func);
 	wilc_handle_isr(sdio_get_drvdata(func));
 	sdio_claim_host(func);
+	sdio_intr_lock = WILC_SDIO_HOST_NO_TAKEN;
+	wake_up_interruptible(&sdio_intr_waitqueue);
 }
 
 static int wilc_sdio_cmd52(struct wilc *wilc, struct sdio_cmd52 *cmd)
@@ -112,18 +129,24 @@ static int linux_sdio_probe(struct sdio_func *func,
 			    const struct sdio_device_id *id)
 {
 	struct wilc *wilc;
-	int gpio, ret;
+	int ret, io_type;
+	static bool init_power;
 
-	gpio = -1;
-	if (IS_ENABLED(CONFIG_WILC1000_HW_OOB_INTR)) {
-		gpio = of_get_gpio(func->dev.of_node, 0);
-		if (gpio < 0)
-			gpio = GPIO_NUM;
-	}
+	int gpio_reset = -1;
+	int gpio_chip_en = -1;
+	int gpio_irq = -1;
+
+	struct device_node *cnp;
 
+	cnp = of_get_child_by_name(func->card->host->parent->of_node,
+				   "wilc_sdio");
+
+	if (IS_ENABLED(CONFIG_WILC_HW_OOB_INTR))
+		io_type = HIF_SDIO_GPIO_IRQ;
+	else
+		io_type = HIF_SDIO;
 	dev_dbg(&func->dev, "Initializing netdev\n");
-	ret = wilc_netdev_init(&wilc, &func->dev, HIF_SDIO, gpio,
-			       &wilc_hif_sdio);
+	ret = wilc_netdev_init(&wilc, &func->dev, io_type, &wilc_hif_sdio);
 	if (ret) {
 		dev_err(&func->dev, "Couldn't initialize netdev\n");
 		return ret;
@@ -131,6 +154,54 @@ static int linux_sdio_probe(struct sdio_func *func,
 	sdio_set_drvdata(func, wilc);
 	wilc->dev = &func->dev;
 
+	gpio_reset = of_get_named_gpio_flags(cnp, "gpio_reset", 0, NULL);
+	if (gpio_reset < 0) {
+		ret = gpio_reset;
+		gpio_reset = GPIO_NUM_RESET;
+		dev_warn(wilc->dev, 
+			 "WILC setting default Reset GPIO to %d. Got %d\r\n",
+			 gpio_reset, ret);
+	} else {
+		dev_info(wilc->dev, "WILC got %d for gpio_reset\r\n",
+			 gpio_reset);
+	}
+
+	gpio_chip_en = of_get_named_gpio_flags(cnp, "gpio_chip_en", 0, NULL);
+	if (gpio_chip_en < 0) {
+		ret = gpio_chip_en;
+		gpio_chip_en = GPIO_NUM_CHIP_EN;
+		dev_warn(wilc->dev,
+			 "WILC setting default Chip Enable GPIO to %d. Got %d\r\n",
+			 gpio_chip_en, ret);
+	} else {
+		dev_info(wilc->dev, "WILC got %d for gpio_chip_en\r\n",
+			 gpio_chip_en);
+	}
+
+	gpio_irq = of_get_named_gpio_flags(cnp, "gpio_irq", 0, NULL);
+	if (gpio_irq < 0) {
+		ret = gpio_irq;
+		gpio_irq = GPIO_NUM;
+		dev_warn(wilc->dev, "WILC setting default IRQ GPIO to %d. Got %d\r\n",
+			 gpio_irq, ret);
+	} else {
+		dev_info(wilc->dev, "WILC got %d for gpio_irq\r\n", gpio_irq);
+	}
+
+	wilc->gpio_irq = gpio_irq;
+	wilc->gpio_chip_en = gpio_chip_en;
+	wilc->gpio_reset = gpio_reset;
+
+	if (!init_power) {
+		wilc_wlan_power_on_sequence(wilc);
+		init_power = 1;
+	}
+
+	mutex_init(&wilc->hif_cs);
+	mutex_init(&wilc->cs);
+
+	wilc_bt_init(wilc);
+
 	dev_info(&func->dev, "Driver Initializing success\n");
 	return 0;
 }
@@ -138,25 +209,31 @@ static int linux_sdio_probe(struct sdio_func *func,
 static void linux_sdio_remove(struct sdio_func *func)
 {
 	wilc_netdev_cleanup(sdio_get_drvdata(func));
+	wilc_bt_deinit();
 }
 
-static int sdio_reset(struct wilc *wilc)
+static int wilc_sdio_reset(struct wilc *wilc)
 {
 	struct sdio_cmd52 cmd;
 	int ret;
 	struct sdio_func *func = dev_to_sdio_func(wilc->dev);
 
+	dev_info(&func->dev, "De Init SDIO\n");
+
 	cmd.read_write = 1;
 	cmd.function = 0;
 	cmd.raw = 0;
 	cmd.address = 0x6;
 	cmd.data = 0x8;
 	ret = wilc_sdio_cmd52(wilc, &cmd);
-	if (ret) {
-		dev_err(&func->dev, "Fail cmd 52, reset cmd ...\n");
-		return ret;
-	}
-	return 0;
+	if (ret)
+		dev_err(&func->dev, "Fail cmd 52, reset cmd\n");
+	return ret;
+}
+
+static bool sdio_is_init(void)
+{
+	return g_sdio.is_init;
 }
 
 static int wilc_sdio_suspend(struct device *dev)
@@ -165,22 +242,21 @@ static int wilc_sdio_suspend(struct device *dev)
 	struct wilc *wilc = sdio_get_drvdata(func);
 	int ret;
 
-	dev_info(dev, "sdio suspend\n");
-	chip_wakeup(wilc);
+	dev_info(&func->dev, "sdio suspend\n");
+	mutex_lock(&wilc->hif_cs);
 
-	if (!wilc->suspend_event) {
-		wilc_chip_sleep_manually(wilc);
-	} else {
-		host_sleep_notify(wilc);
-		chip_allow_sleep(wilc);
-	}
+	chip_wakeup(wilc, 0);
 
-	ret = sdio_reset(wilc);
-	if (ret) {
-		dev_err(&func->dev, "Fail reset sdio\n");
-		return ret;
+	if (mutex_is_locked(&wilc->hif_cs)){
+		mutex_unlock(&wilc->hif_cs);
 	}
-	sdio_claim_host(func);
+
+	host_sleep_notify(wilc, 0);
+	chip_allow_sleep(wilc, 0);
+
+	mutex_lock(&wilc->hif_cs);
+
+	ret = wilc_sdio_reset(wilc);
 
 	return 0;
 }
@@ -190,34 +266,47 @@ static int wilc_sdio_resume(struct device *dev)
 	struct sdio_func *func = dev_to_sdio_func(dev);
 	struct wilc *wilc = sdio_get_drvdata(func);
 
-	dev_info(dev, "sdio resume\n");
-	sdio_release_host(func);
-	chip_wakeup(wilc);
+	dev_info(&func->dev, "sdio resume\n");
+	chip_wakeup(wilc, 0);
 	sdio_init(wilc, true);
 
-	if (wilc->suspend_event)
-		host_wakeup_notify(wilc);
+	if (mutex_is_locked(&wilc->hif_cs))
+		mutex_unlock(&wilc->hif_cs);
+
+	host_wakeup_notify(wilc, 0);
+
+	mutex_lock(&wilc->hif_cs);
 
-	chip_allow_sleep(wilc);
+	chip_allow_sleep(wilc, 0);
+
+	if (mutex_is_locked(&wilc->hif_cs))
+		mutex_unlock(&wilc->hif_cs);
 
 	return 0;
 }
 
+static const struct of_device_id wilc_of_match[] = {
+	{ .compatible = "atmel,wilc_sdio", },
+	{}
+};
+MODULE_DEVICE_TABLE(of, wilc_of_match);
+
 static const struct dev_pm_ops wilc_sdio_pm_ops = {
 	.suspend = wilc_sdio_suspend,
 	.resume = wilc_sdio_resume,
 };
 
-static struct sdio_driver wilc1000_sdio_driver = {
+static struct sdio_driver wilc_sdio_driver = {
 	.name		= SDIO_MODALIAS,
 	.id_table	= wilc_sdio_ids,
 	.probe		= linux_sdio_probe,
 	.remove		= linux_sdio_remove,
 	.drv = {
 		.pm = &wilc_sdio_pm_ops,
+		.of_match_table = wilc_of_match,
 	}
 };
-module_driver(wilc1000_sdio_driver,
+module_driver(wilc_sdio_driver,
 	      sdio_register_driver,
 	      sdio_unregister_driver);
 MODULE_LICENSE("GPL");
@@ -226,6 +315,7 @@ static int wilc_sdio_enable_interrupt(struct wilc *dev)
 {
 	struct sdio_func *func = container_of(dev->dev, struct sdio_func, dev);
 	int ret = 0;
+	sdio_intr_lock  = WILC_SDIO_HOST_NO_TAKEN;
 
 	sdio_claim_host(func);
 	ret = sdio_claim_irq(func, wilc_sdio_interrupt);
@@ -243,11 +333,19 @@ static void wilc_sdio_disable_interrupt(struct wilc *dev)
 	struct sdio_func *func = container_of(dev->dev, struct sdio_func, dev);
 	int ret;
 
+	dev_info(&func->dev, "wilc_sdio_disable_interrupt\n");
+
+	if (sdio_intr_lock  == WILC_SDIO_HOST_IRQ_TAKEN)
+		wait_event_interruptible(sdio_intr_waitqueue,
+				   sdio_intr_lock == WILC_SDIO_HOST_NO_TAKEN);
+	sdio_intr_lock  = WILC_SDIO_HOST_DIS_TAKEN;
+
 	sdio_claim_host(func);
 	ret = sdio_release_irq(func);
 	if (ret < 0)
 		dev_err(&func->dev, "can't release sdio_irq, err(%d)\n", ret);
 	sdio_release_host(func);
+	sdio_intr_lock  = WILC_SDIO_HOST_NO_TAKEN;
 }
 
 /********************************************
@@ -273,7 +371,7 @@ static int sdio_set_func0_csa_address(struct wilc *wilc, u32 adr)
 	ret = wilc_sdio_cmd52(wilc, &cmd);
 	if (ret) {
 		dev_err(&func->dev, "Failed cmd52, set 0x10c data...\n");
-		goto _fail_;
+		goto fail;
 	}
 
 	cmd.address = 0x10d;
@@ -281,7 +379,7 @@ static int sdio_set_func0_csa_address(struct wilc *wilc, u32 adr)
 	ret = wilc_sdio_cmd52(wilc, &cmd);
 	if (ret) {
 		dev_err(&func->dev, "Failed cmd52, set 0x10d data...\n");
-		goto _fail_;
+		goto fail;
 	}
 
 	cmd.address = 0x10e;
@@ -289,11 +387,11 @@ static int sdio_set_func0_csa_address(struct wilc *wilc, u32 adr)
 	ret = wilc_sdio_cmd52(wilc, &cmd);
 	if (ret) {
 		dev_err(&func->dev, "Failed cmd52, set 0x10e data...\n");
-		goto _fail_;
+		goto fail;
 	}
 
 	return 1;
-_fail_:
+fail:
 	return 0;
 }
 
@@ -311,7 +409,7 @@ static int sdio_set_func0_block_size(struct wilc *wilc, u32 block_size)
 	ret = wilc_sdio_cmd52(wilc, &cmd);
 	if (ret) {
 		dev_err(&func->dev, "Failed cmd52, set 0x10 data...\n");
-		goto _fail_;
+		goto fail;
 	}
 
 	cmd.address = 0x11;
@@ -319,11 +417,11 @@ static int sdio_set_func0_block_size(struct wilc *wilc, u32 block_size)
 	ret = wilc_sdio_cmd52(wilc, &cmd);
 	if (ret) {
 		dev_err(&func->dev, "Failed cmd52, set 0x11 data...\n");
-		goto _fail_;
+		goto fail;
 	}
 
 	return 1;
-_fail_:
+fail:
 	return 0;
 }
 
@@ -347,18 +445,18 @@ static int sdio_set_func1_block_size(struct wilc *wilc, u32 block_size)
 	ret = wilc_sdio_cmd52(wilc, &cmd);
 	if (ret) {
 		dev_err(&func->dev, "Failed cmd52, set 0x110 data...\n");
-		goto _fail_;
+		goto fail;
 	}
 	cmd.address = 0x111;
 	cmd.data = (u8)(block_size >> 8);
 	ret = wilc_sdio_cmd52(wilc, &cmd);
 	if (ret) {
 		dev_err(&func->dev, "Failed cmd52, set 0x111 data...\n");
-		goto _fail_;
+		goto fail;
 	}
 
 	return 1;
-_fail_:
+fail:
 	return 0;
 }
 
@@ -374,7 +472,7 @@ static int sdio_write_reg(struct wilc *wilc, u32 addr, u32 data)
 
 	data = cpu_to_le32(data);
 
-	if ((addr >= 0xf0) && (addr <= 0xff)) {
+	if (addr >= 0xf0 && addr <= 0xff) {
 		struct sdio_cmd52 cmd;
 
 		cmd.read_write = 1;
@@ -385,8 +483,8 @@ static int sdio_write_reg(struct wilc *wilc, u32 addr, u32 data)
 		ret = wilc_sdio_cmd52(wilc, &cmd);
 		if (ret) {
 			dev_err(&func->dev,
-				"Failed cmd 52, read reg (%08x) ...\n", addr);
-			goto _fail_;
+				"Failed cmd 52, write reg %08x ...\n", addr);
+			goto fail;
 		}
 	} else {
 		struct sdio_cmd53 cmd;
@@ -395,7 +493,7 @@ static int sdio_write_reg(struct wilc *wilc, u32 addr, u32 data)
 		 *      set the AHB address
 		 **/
 		if (!sdio_set_func0_csa_address(wilc, addr))
-			goto _fail_;
+			goto fail;
 
 		cmd.read_write = 1;
 		cmd.function = 0;
@@ -404,18 +502,18 @@ static int sdio_write_reg(struct wilc *wilc, u32 addr, u32 data)
 		cmd.increment = 1;
 		cmd.count = 4;
 		cmd.buffer = (u8 *)&data;
-		cmd.block_size = g_sdio.block_size; /* johnny : prevent it from setting unexpected value */
+		cmd.block_size = g_sdio.block_size;
 		ret = wilc_sdio_cmd53(wilc, &cmd);
 		if (ret) {
 			dev_err(&func->dev,
 				"Failed cmd53, write reg (%08x)...\n", addr);
-			goto _fail_;
+			goto fail;
 		}
 	}
 
 	return 1;
 
-_fail_:
+fail:
 
 	return 0;
 }
@@ -469,13 +567,13 @@ static int sdio_write(struct wilc *wilc, u32 addr, u8 *buf, u32 size)
 		cmd.block_size = block_size;
 		if (addr > 0) {
 			if (!sdio_set_func0_csa_address(wilc, addr))
-				goto _fail_;
+				goto fail;
 		}
 		ret = wilc_sdio_cmd53(wilc, &cmd);
 		if (ret) {
 			dev_err(&func->dev,
 				"Failed cmd53 [%x], block send...\n", addr);
-			goto _fail_;
+			goto fail;
 		}
 		if (addr > 0)
 			addr += nblk * block_size;
@@ -488,23 +586,23 @@ static int sdio_write(struct wilc *wilc, u32 addr, u8 *buf, u32 size)
 		cmd.count = nleft;
 		cmd.buffer = buf;
 
-		cmd.block_size = block_size; /* johnny : prevent it from setting unexpected value */
+		cmd.block_size = block_size;
 
 		if (addr > 0) {
 			if (!sdio_set_func0_csa_address(wilc, addr))
-				goto _fail_;
+				goto fail;
 		}
 		ret = wilc_sdio_cmd53(wilc, &cmd);
 		if (ret) {
 			dev_err(&func->dev,
 				"Failed cmd53 [%x], bytes send...\n", addr);
-			goto _fail_;
+			goto fail;
 		}
 	}
 
 	return 1;
 
-_fail_:
+fail:
 
 	return 0;
 }
@@ -514,7 +612,7 @@ static int sdio_read_reg(struct wilc *wilc, u32 addr, u32 *data)
 	struct sdio_func *func = dev_to_sdio_func(wilc->dev);
 	int ret;
 
-	if ((addr >= 0xf0) && (addr <= 0xff)) {
+	if (addr >= 0xf0 && addr <= 0xff) {
 		struct sdio_cmd52 cmd;
 
 		cmd.read_write = 0;
@@ -525,14 +623,14 @@ static int sdio_read_reg(struct wilc *wilc, u32 addr, u32 *data)
 		if (ret) {
 			dev_err(&func->dev,
 				"Failed cmd 52, read reg (%08x) ...\n", addr);
-			goto _fail_;
+			goto fail;
 		}
 		*data = cmd.data;
 	} else {
 		struct sdio_cmd53 cmd;
 
 		if (!sdio_set_func0_csa_address(wilc, addr))
-			goto _fail_;
+			goto fail;
 
 		cmd.read_write = 0;
 		cmd.function = 0;
@@ -542,12 +640,12 @@ static int sdio_read_reg(struct wilc *wilc, u32 addr, u32 *data)
 		cmd.count = 4;
 		cmd.buffer = (u8 *)data;
 
-		cmd.block_size = g_sdio.block_size; /* johnny : prevent it from setting unexpected value */
+		cmd.block_size = g_sdio.block_size;
 		ret = wilc_sdio_cmd53(wilc, &cmd);
 		if (ret) {
 			dev_err(&func->dev,
 				"Failed cmd53, read reg (%08x)...\n", addr);
-			goto _fail_;
+			goto fail;
 		}
 	}
 
@@ -555,7 +653,7 @@ static int sdio_read_reg(struct wilc *wilc, u32 addr, u32 *data)
 
 	return 1;
 
-_fail_:
+fail:
 
 	return 0;
 }
@@ -609,13 +707,13 @@ static int sdio_read(struct wilc *wilc, u32 addr, u8 *buf, u32 size)
 		cmd.block_size = block_size;
 		if (addr > 0) {
 			if (!sdio_set_func0_csa_address(wilc, addr))
-				goto _fail_;
+				goto fail;
 		}
 		ret = wilc_sdio_cmd53(wilc, &cmd);
 		if (ret) {
 			dev_err(&func->dev,
 				"Failed cmd53 [%x], block read...\n", addr);
-			goto _fail_;
+			goto fail;
 		}
 		if (addr > 0)
 			addr += nblk * block_size;
@@ -628,23 +726,23 @@ static int sdio_read(struct wilc *wilc, u32 addr, u8 *buf, u32 size)
 		cmd.count = nleft;
 		cmd.buffer = buf;
 
-		cmd.block_size = block_size; /* johnny : prevent it from setting unexpected value */
+		cmd.block_size = block_size;
 
 		if (addr > 0) {
 			if (!sdio_set_func0_csa_address(wilc, addr))
-				goto _fail_;
+				goto fail;
 		}
 		ret = wilc_sdio_cmd53(wilc, &cmd);
 		if (ret) {
 			dev_err(&func->dev,
 				"Failed cmd53 [%x], bytes read...\n", addr);
-			goto _fail_;
+			goto fail;
 		}
 	}
 
 	return 1;
 
-_fail_:
+fail:
 
 	return 0;
 }
@@ -657,6 +755,8 @@ static int sdio_read(struct wilc *wilc, u32 addr, u8 *buf, u32 size)
 
 static int sdio_deinit(struct wilc *wilc)
 {
+	g_sdio.is_init = false;
+
 	return 1;
 }
 
@@ -667,10 +767,10 @@ static int sdio_init(struct wilc *wilc, bool resume)
 	int loop, ret;
 	u32 chipid;
 
-	if (!resume) {
-		memset(&g_sdio, 0, sizeof(struct wilc_sdio));
-		g_sdio.irq_gpio = wilc->dev_irq_num;
-	}
+	dev_info(&func->dev, "SDIO speed: %d\n",
+		func->card->host->ios.clock);
+	init_waitqueue_head(&sdio_intr_waitqueue);
+	g_sdio.irq_gpio = (wilc->io_type == HIF_SDIO_GPIO_IRQ);
 
 	/**
 	 *      function 0 csa enable
@@ -683,7 +783,7 @@ static int sdio_init(struct wilc *wilc, bool resume)
 	ret = wilc_sdio_cmd52(wilc, &cmd);
 	if (ret) {
 		dev_err(&func->dev, "Fail cmd 52, enable csa...\n");
-		goto _fail_;
+		goto fail;
 	}
 
 	/**
@@ -691,7 +791,7 @@ static int sdio_init(struct wilc *wilc, bool resume)
 	 **/
 	if (!sdio_set_func0_block_size(wilc, WILC_SDIO_BLOCK_SIZE)) {
 		dev_err(&func->dev, "Fail cmd 52, set func 0 block size...\n");
-		goto _fail_;
+		goto fail;
 	}
 	g_sdio.block_size = WILC_SDIO_BLOCK_SIZE;
 
@@ -707,7 +807,7 @@ static int sdio_init(struct wilc *wilc, bool resume)
 	if (ret) {
 		dev_err(&func->dev,
 			"Fail cmd 52, set IOE register...\n");
-		goto _fail_;
+		goto fail;
 	}
 
 	/**
@@ -724,7 +824,7 @@ static int sdio_init(struct wilc *wilc, bool resume)
 		if (ret) {
 			dev_err(&func->dev,
 				"Fail cmd 52, get IOR register...\n");
-			goto _fail_;
+			goto fail;
 		}
 		if (cmd.data == 0x2)
 			break;
@@ -732,7 +832,7 @@ static int sdio_init(struct wilc *wilc, bool resume)
 
 	if (loop <= 0) {
 		dev_err(&func->dev, "Fail func 1 is not ready...\n");
-		goto _fail_;
+		goto fail;
 	}
 
 	/**
@@ -740,7 +840,7 @@ static int sdio_init(struct wilc *wilc, bool resume)
 	 **/
 	if (!sdio_set_func1_block_size(wilc, WILC_SDIO_BLOCK_SIZE)) {
 		dev_err(&func->dev, "Fail set func 1 block size...\n");
-		goto _fail_;
+		goto fail;
 	}
 
 	/**
@@ -754,29 +854,30 @@ static int sdio_init(struct wilc *wilc, bool resume)
 	ret = wilc_sdio_cmd52(wilc, &cmd);
 	if (ret) {
 		dev_err(&func->dev, "Fail cmd 52, set IEN register...\n");
-		goto _fail_;
+		goto fail;
 	}
 
 	/**
 	 *      make sure can read back chip id correctly
 	 **/
 	if (!resume) {
-		if (!sdio_read_reg(wilc, 0x1000, &chipid)) {
-			dev_err(&func->dev, "Fail cmd read chip id...\n");
-			goto _fail_;
+		chipid = wilc_get_chipid(wilc, true);
+		if(ISWILC3000(chipid)) {
+			wilc->chip = WILC_3000;
+		} else if(ISWILC1000(chipid)) {
+			wilc->chip = WILC_1000;
+		} else {
+			dev_err(&func->dev, "Unsupported chipid: %x\n", chipid);
+			goto fail;
 		}
-		dev_err(&func->dev, "chipid (%08x)\n", chipid);
-		if ((chipid & 0xfff) > 0x2a0)
-			g_sdio.has_thrpt_enh3 = 1;
-		else
-			g_sdio.has_thrpt_enh3 = 0;
-		dev_info(&func->dev, "has_thrpt_enh3 = %d...\n",
-			 g_sdio.has_thrpt_enh3);
+		dev_info(&func->dev, "chipid %08x\n", chipid);
 	}
 
+	g_sdio.is_init = true;
+
 	return 1;
 
-_fail_:
+fail:
 
 	return 0;
 }
@@ -814,15 +915,31 @@ static int sdio_read_int(struct wilc *wilc, u32 *int_status)
 	struct sdio_func *func = dev_to_sdio_func(wilc->dev);
 	u32 tmp;
 	struct sdio_cmd52 cmd;
+	u32 irq_flags;
+	int i;
 
-	sdio_read_size(wilc, &tmp);
+	if (g_sdio.irq_gpio) {
+		sdio_read_size(wilc, &tmp);
 
-	/**
-	 *      Read IRQ flags
-	 **/
-	if (!g_sdio.irq_gpio) {
-		int i;
+		cmd.read_write = 0;
+		cmd.function = 1;
+		cmd.raw = 0;
+		cmd.data = 0;
+		if(wilc->chip == WILC_1000) {
+			cmd.address = 0xf7;
+			wilc_sdio_cmd52(wilc, &cmd);
+			irq_flags = cmd.data & 0x1f;
+		} else {
+			cmd.address = 0xfe;
+			wilc_sdio_cmd52(wilc, &cmd);
+			irq_flags = cmd.data & 0x0f;
+		}
+		tmp |= ((irq_flags >> 0) << IRG_FLAGS_OFFSET);
 
+		*int_status = tmp;
+	} else {
+		sdio_read_size(wilc, &tmp);
+		cmd.read_write = 0;
 		cmd.function = 1;
 		cmd.address = 0x04;
 		cmd.data = 0;
@@ -838,8 +955,7 @@ static int sdio_read_int(struct wilc *wilc, u32 *int_status)
 			tmp |= INT_3;
 		if (cmd.data & BIT(5))
 			tmp |= INT_4;
-		if (cmd.data & BIT(6))
-			tmp |= INT_5;
+
 		for (i = g_sdio.nint; i < MAX_NUM_INT; i++) {
 			if ((tmp >> (IRG_FLAGS_OFFSET + i)) & 0x1) {
 				dev_err(&func->dev,
@@ -848,20 +964,10 @@ static int sdio_read_int(struct wilc *wilc, u32 *int_status)
 				break;
 			}
 		}
-	} else {
-		u32 irq_flags;
 
-		cmd.read_write = 0;
-		cmd.function = 0;
-		cmd.raw = 0;
-		cmd.address = 0xf7;
-		cmd.data = 0;
-		wilc_sdio_cmd52(wilc, &cmd);
-		irq_flags = cmd.data & 0x1f;
-		tmp |= ((irq_flags >> 0) << IRG_FLAGS_OFFSET);
-	}
+		*int_status = tmp;
 
-	*int_status = tmp;
+	}
 
 	return 1;
 }
@@ -870,26 +976,20 @@ static int sdio_clear_int_ext(struct wilc *wilc, u32 val)
 {
 	struct sdio_func *func = dev_to_sdio_func(wilc->dev);
 	int ret;
+	u32 reg = 0;
 
-	if (g_sdio.has_thrpt_enh3) {
-		u32 reg;
-
-		if (g_sdio.irq_gpio) {
-			u32 flags;
+	if(wilc->chip == WILC_1000) {
+		if(g_sdio.irq_gpio)
+			reg = val & (BIT(MAX_NUM_INT) - 1);
 
-			flags = val & (BIT(MAX_NUN_INT_THRPT_ENH2) - 1);
-			reg = flags;
-		} else {
-			reg = 0;
-		}
 		/* select VMM table 0 */
-		if ((val & SEL_VMM_TBL0) == SEL_VMM_TBL0)
+		if (val & SEL_VMM_TBL0)
 			reg |= BIT(5);
 		/* select VMM table 1 */
-		if ((val & SEL_VMM_TBL1) == SEL_VMM_TBL1)
+		if (val & SEL_VMM_TBL1)
 			reg |= BIT(6);
 		/* enable VMM */
-		if ((val & EN_VMM) == EN_VMM)
+		if (val & EN_VMM)
 			reg |= BIT(7);
 		if (reg) {
 			struct sdio_cmd52 cmd;
@@ -905,89 +1005,61 @@ static int sdio_clear_int_ext(struct wilc *wilc, u32 val)
 				dev_err(&func->dev,
 					"Failed cmd52, set 0xf8 data (%d) ...\n",
 					__LINE__);
-				goto _fail_;
+				goto fail;
 			}
 		}
 	} else {
-		if (g_sdio.irq_gpio) {
-			/* see below. has_thrpt_enh2 uses register 0xf8 to clear interrupts. */
-			/* Cannot clear multiple interrupts. Must clear each interrupt individually */
-			u32 flags;
-
-			flags = val & (BIT(MAX_NUM_INT) - 1);
-			if (flags) {
-				int i;
-
-				ret = 1;
-				for (i = 0; i < g_sdio.nint; i++) {
-					if (flags & 1) {
-						struct sdio_cmd52 cmd;
-
-						cmd.read_write = 1;
-						cmd.function = 0;
-						cmd.raw = 0;
-						cmd.address = 0xf8;
-						cmd.data = BIT(i);
-
-						ret = wilc_sdio_cmd52(wilc, &cmd);
-						if (ret) {
-							dev_err(&func->dev,
-								"Failed cmd52, set 0xf8 data (%d) ...\n",
-								__LINE__);
-							goto _fail_;
-						}
-					}
-					if (!ret)
-						break;
-					flags >>= 1;
-				}
-				if (!ret)
-					goto _fail_;
-				for (i = g_sdio.nint; i < MAX_NUM_INT; i++) {
-					if (flags & 1)
-						dev_err(&func->dev,
-							"Unexpected interrupt cleared %d...\n",
-							i);
-					flags >>= 1;
-				}
-			}
-		}
-
-		{
-			u32 vmm_ctl;
-
-			vmm_ctl = 0;
-			/* select VMM table 0 */
-			if ((val & SEL_VMM_TBL0) == SEL_VMM_TBL0)
-				vmm_ctl |= BIT(0);
-			/* select VMM table 1 */
-			if ((val & SEL_VMM_TBL1) == SEL_VMM_TBL1)
-				vmm_ctl |= BIT(1);
-			/* enable VMM */
-			if ((val & EN_VMM) == EN_VMM)
-				vmm_ctl |= BIT(2);
-
-			if (vmm_ctl) {
+		if(g_sdio.irq_gpio) {
+			reg = val & (BIT(MAX_NUM_INT) - 1);
+			if (reg) {
 				struct sdio_cmd52 cmd;
 
 				cmd.read_write = 1;
 				cmd.function = 0;
 				cmd.raw = 0;
-				cmd.address = 0xf6;
-				cmd.data = vmm_ctl;
+				cmd.address = 0xfe;
+				cmd.data = reg;
+
 				ret = wilc_sdio_cmd52(wilc, &cmd);
 				if (ret) {
 					dev_err(&func->dev,
-						"Failed cmd52, set 0xf6 data (%d) ...\n",
+						"Failed cmd52, set 0xf8 data (%d) ...\n",
 						__LINE__);
-					goto _fail_;
+					goto fail;
 				}
 			}
 		}
+		/* select VMM table 0 */
+		if (val & SEL_VMM_TBL0)
+			reg |= BIT(0);
+		/* select VMM table 1 */
+		if (val & SEL_VMM_TBL1)
+			reg |= BIT(1);
+		/* enable VMM */
+		if (val & EN_VMM)
+			reg |= BIT(2);
+
+		if (reg) {
+			struct sdio_cmd52 cmd;
+
+			cmd.read_write = 1;
+			cmd.function = 0;
+			cmd.raw = 0;
+			cmd.address = 0xf1;
+			cmd.data = reg;
+
+			ret = wilc_sdio_cmd52(wilc, &cmd);
+			if (ret) {
+				dev_err(&func->dev,
+					"Failed cmd52, set 0xf6 data (%d) ...\n",
+					__LINE__);
+				goto fail;
+			}
+		}
 	}
 
 	return 1;
-_fail_:
+fail:
 	return 0;
 }
 
@@ -995,37 +1067,34 @@ static int sdio_sync_ext(struct wilc *wilc, int nint)
 {
 	struct sdio_func *func = dev_to_sdio_func(wilc->dev);
 	u32 reg;
+	int ret, i;
 
 	if (nint > MAX_NUM_INT) {
-		dev_err(&func->dev, "Too many interrupts (%d)...\n", nint);
-		return 0;
-	}
-	if (nint > MAX_NUN_INT_THRPT_ENH2) {
-		dev_err(&func->dev,
-			"Cannot support more than 5 interrupts when has_thrpt_enh2=1.\n");
+		dev_err(&func->dev,"Too many interrupts %d\n", nint);
 		return 0;
 	}
 
 	g_sdio.nint = nint;
 
-	/**
-	 *      Disable power sequencer
-	 **/
-	if (!sdio_read_reg(wilc, WILC_MISC, &reg)) {
-		dev_err(&func->dev, "Failed read misc reg...\n");
-		return 0;
-	}
-
-	reg &= ~BIT(8);
-	if (!sdio_write_reg(wilc, WILC_MISC, reg)) {
-		dev_err(&func->dev, "Failed write misc reg...\n");
-		return 0;
+/* WILC3000 only. Was removed in WILC1000 on revision 6200.
+ * Might be related to suspend/resume
+ */
+ 	if(wilc->chip == WILC_3000) {
+		/**
+		 *      Disable power sequencer
+		 **/
+		if (!sdio_read_reg(wilc, WILC_MISC, &reg)) {
+			dev_err(&func->dev, "Failed read misc reg\n");
+			return 0;
+		}
+		reg &= ~BIT(8);
+		if (!sdio_write_reg(wilc, WILC_MISC, reg)) {
+			dev_err(&func->dev, "Failed write misc reg\n");
+			return 0;
+		}
 	}
 
 	if (g_sdio.irq_gpio) {
-		u32 reg;
-		int ret, i;
-
 		/**
 		 *      interrupt pin mux select
 		 **/
@@ -1106,5 +1175,7 @@ static const struct wilc_hif_func wilc_hif_sdio = {
 	.hif_sync_ext = sdio_sync_ext,
 	.enable_interrupt = wilc_sdio_enable_interrupt,
 	.disable_interrupt = wilc_sdio_disable_interrupt,
+	.hif_reset = wilc_sdio_reset,
+	.hif_is_init = sdio_is_init,
 };
 
diff --git a/drivers/staging/wilc1000/wilc_spi.c b/drivers/staging/wilc/wilc_spi.c
similarity index 58%
rename from drivers/staging/wilc1000/wilc_spi.c
rename to drivers/staging/wilc/wilc_spi.c
index 5ef8441..17ea29d 100644
--- a/drivers/staging/wilc1000/wilc_spi.c
+++ b/drivers/staging/wilc/wilc_spi.c
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Copyright (c) Atmel Corporation.  All rights reserved.
  *
@@ -24,7 +25,7 @@
 struct wilc_spi {
 	int crc_off;
 	int nint;
-	int has_thrpt_enh;
+	bool is_init;
 };
 
 static struct wilc_spi g_spi;
@@ -32,6 +33,8 @@ static const struct wilc_hif_func wilc_hif_spi;
 
 static int wilc_spi_read(struct wilc *wilc, u32, u8 *, u32);
 static int wilc_spi_write(struct wilc *wilc, u32, u8 *, u32);
+static int wilc_spi_rx(struct wilc *wilc, u8 *rb, u32 rlen);
+static int wilc_spi_reset(struct wilc *wilc);
 
 /********************************************
  *
@@ -94,72 +97,201 @@ static u8 crc7(u8 crc, const u8 *buffer, u32 len)
 
 #define CMD_DMA_WRITE				0xc1
 #define CMD_DMA_READ				0xc2
-#define CMD_INTERNAL_WRITE		0xc3
-#define CMD_INTERNAL_READ		0xc4
+#define CMD_INTERNAL_WRITE			0xc3
+#define CMD_INTERNAL_READ			0xc4
 #define CMD_TERMINATE				0xc5
-#define CMD_REPEAT					0xc6
-#define CMD_DMA_EXT_WRITE		0xc7
-#define CMD_DMA_EXT_READ		0xc8
+#define CMD_REPEAT				0xc6
+#define CMD_DMA_EXT_WRITE			0xc7
+#define CMD_DMA_EXT_READ			0xc8
 #define CMD_SINGLE_WRITE			0xc9
-#define CMD_SINGLE_READ			0xca
-#define CMD_RESET						0xcf
+#define CMD_SINGLE_READ				0xca
+#define CMD_RESET				0xcf
 
-#define N_OK								1
-#define N_FAIL								0
-#define N_RESET							-1
-#define N_RETRY							-2
+#define N_OK					1
+#define N_FAIL					0
+#define N_RESET					-1
+#define N_RETRY					-2
 
+#define SPI_RESP_RETRY_COUNT 			(10)
+#define SPI_RETRY_COUNT				(10)
 #define DATA_PKT_SZ_256				256
-#define DATA_PKT_SZ_512			512
+#define DATA_PKT_SZ_512				512
 #define DATA_PKT_SZ_1K				1024
+#define DATA_PKT_SZ_2K				(2 * 1024)
 #define DATA_PKT_SZ_4K				(4 * 1024)
 #define DATA_PKT_SZ_8K				(8 * 1024)
-#define DATA_PKT_SZ					DATA_PKT_SZ_8K
+#define DATA_PKT_SZ				DATA_PKT_SZ_8K
 
-#define USE_SPI_DMA     0
+#define USE_SPI_DMA				0
 
 static int wilc_bus_probe(struct spi_device *spi)
 {
-	int ret, gpio;
+	int ret;
+	static bool init_power;
 	struct wilc *wilc;
+	struct device *dev = &spi->dev;
+
+	int gpio_reset = -1;
+	int gpio_chip_en = -1;
+	int gpio_irq = -1;
 
-	gpio = of_get_gpio(spi->dev.of_node, 0);
-	if (gpio < 0)
-		gpio = GPIO_NUM;
+	dev_info(&spi->dev, "spiModalias: %s, spiMax-Speed: %d\n",
+			spi->modalias, spi->max_speed_hz);
 
-	ret = wilc_netdev_init(&wilc, NULL, HIF_SPI, GPIO_NUM, &wilc_hif_spi);
+	ret = wilc_netdev_init(&wilc, dev, HIF_SPI, &wilc_hif_spi);
 	if (ret)
 		return ret;
 
 	spi_set_drvdata(spi, wilc);
 	wilc->dev = &spi->dev;
 
+	gpio_reset = of_get_named_gpio_flags(dev->of_node, "gpio_reset", 0, NULL);
+	if (gpio_reset < 0) {
+		ret = gpio_reset;
+		gpio_reset = GPIO_NUM_RESET;
+		dev_warn(dev, "WILC setting default Reset GPIO to %d.  Got %d\r\n", gpio_reset, ret);
+	} else {
+		dev_info(dev, "WILC got %d for gpio_reset\r\n", gpio_reset);
+	}
+
+	gpio_chip_en = of_get_named_gpio_flags(dev->of_node, "gpio_chip_en", 0, NULL);
+	if (gpio_chip_en < 0) {
+		ret = gpio_chip_en;
+		gpio_chip_en = GPIO_NUM_CHIP_EN;
+		dev_warn(dev, "WILC setting default Chip Enable GPIO to %d.  Got %d\r\n", gpio_chip_en, ret);
+	} else {
+		dev_info(dev, "WILC got %d for gpio_chip_en\r\n", gpio_chip_en);
+	}
+
+	gpio_irq = of_get_named_gpio_flags(dev->of_node, "gpio_irq", 0, NULL);
+	if (gpio_irq < 0) {
+		ret = gpio_irq;
+		gpio_irq = GPIO_NUM;
+		dev_warn(dev, "WILC setting default IRQ GPIO to %d.  Got %d\r\n", gpio_irq, ret);
+	} else {
+		dev_info(dev, "WILC got %d for gpio_irq\r\n", gpio_irq);
+	}
+
+	wilc->gpio_irq = gpio_irq;
+	wilc->gpio_chip_en = gpio_chip_en;
+	wilc->gpio_reset = gpio_reset;
+
+	if (!init_power) {
+		wilc_wlan_power_on_sequence(wilc);
+		init_power = 1;
+	}
+
+	mutex_init(&wilc->hif_cs);
+	mutex_init(&wilc->cs);
+	wilc_bt_init(wilc);
+
+	dev_info(dev, "WILC SPI probe success\n");
 	return 0;
 }
 
 static int wilc_bus_remove(struct spi_device *spi)
 {
 	wilc_netdev_cleanup(spi_get_drvdata(spi));
+	wilc_bt_deinit();
+	return 0;
+}
+
+static int wilc_spi_suspend(struct device *dev)
+{
+	struct spi_device *spi = to_spi_device(dev);
+	struct wilc *wilc = spi_get_drvdata(spi);
+
+	dev_info(&spi->dev, "\n\n << SUSPEND >>\n\n");
+	mutex_lock(&wilc->hif_cs);
+	chip_wakeup(wilc, 0);
+
+	if (mutex_is_locked(&wilc->hif_cs))
+		mutex_unlock(&wilc->hif_cs);
+
+	/*notify the chip that host will sleep*/
+	host_sleep_notify(wilc, 0);
+	chip_allow_sleep(wilc, 0);
+	mutex_lock(&wilc->hif_cs);
+
+ 	return 0 ;
+}
+
+static int wilc_spi_resume(struct device *dev)
+{
+	struct spi_device *spi = to_spi_device(dev);
+	struct wilc *wilc = spi_get_drvdata(spi);
+
+	dev_info(&spi->dev, "\n\n  <<RESUME>> \n\n");
+
+	/*wake the chip to compelete the re-intialization*/
+	chip_wakeup(wilc, 0);
+
+	if (mutex_is_locked(&wilc->hif_cs))
+		mutex_unlock(&wilc->hif_cs);
+
+	host_wakeup_notify(wilc, 0);
+
+	mutex_lock(&wilc->hif_cs);
+
+	chip_allow_sleep(wilc, 0);
+
+	if (mutex_is_locked(&wilc->hif_cs))
+		mutex_unlock(&wilc->hif_cs);
+
 	return 0;
 }
 
-static const struct of_device_id wilc1000_of_match[] = {
+static const struct of_device_id wilc_of_match[] = {
 	{ .compatible = "atmel,wilc_spi", },
 	{}
 };
-MODULE_DEVICE_TABLE(of, wilc1000_of_match);
+MODULE_DEVICE_TABLE(of, wilc_of_match);
+static const struct dev_pm_ops wilc_spi_pm_ops = {
+     .suspend = wilc_spi_suspend,
+     .resume    = wilc_spi_resume,
+    	};
 
-static struct spi_driver wilc1000_spi_driver = {
+static struct spi_driver wilc_spi_driver = {
 	.driver = {
 		.name = MODALIAS,
-		.of_match_table = wilc1000_of_match,
+		.of_match_table = wilc_of_match,
+		.pm = &wilc_spi_pm_ops,
 	},
 	.probe =  wilc_bus_probe,
 	.remove = wilc_bus_remove,
 };
-module_spi_driver(wilc1000_spi_driver);
+module_spi_driver(wilc_spi_driver);
 MODULE_LICENSE("GPL");
 
+static int spi_data_rsp(struct wilc *wilc, u8 cmd)
+{
+	struct spi_device *spi = to_spi_device(wilc->dev);
+    u8 len;
+    u8 rsp[3];
+    int result = N_OK;
+
+    if (!g_spi.crc_off)
+            len = 2;
+    else
+            len = 3;
+
+    if (wilc_spi_rx(wilc, &rsp[0], len)) {
+		dev_err(&spi->dev, "Failed bus error...\n");
+		result = N_FAIL;
+		goto fail;
+	}
+
+	if((rsp[len-1] != 0) || (rsp[len-2] != 0xC3)) {
+		dev_err(&spi->dev, "Failed data response read, %x %x %x\n",
+			rsp[0], rsp[1], rsp[2]);
+		result = N_FAIL;
+		goto fail;
+	}
+
+fail:
+	return result;
+}
+
 static int wilc_spi_tx(struct wilc *wilc, u8 *b, u32 len)
 {
 	struct spi_device *spi = to_spi_device(wilc->dev);
@@ -174,9 +306,11 @@ static int wilc_spi_tx(struct wilc *wilc, u8 *b, u32 len)
 		};
 		char *r_buffer = kzalloc(len, GFP_KERNEL);
 
-		if (!r_buffer)
+		if(! r_buffer){
+			dev_err(&spi->dev,
+				"Failed to allocate memory for r_buffer\n");
 			return -ENOMEM;
-
+		}
 		tr.rx_buf = r_buffer;
 		dev_dbg(&spi->dev, "Request writing %d bytes\n", len);
 
@@ -216,9 +350,10 @@ static int wilc_spi_rx(struct wilc *wilc, u8 *rb, u32 rlen)
 		};
 		char *t_buffer = kzalloc(rlen, GFP_KERNEL);
 
-		if (!t_buffer)
+		if(! t_buffer){
+			dev_err(&spi->dev, "Failed to allocate memory for t_buffer\n");
 			return -ENOMEM;
-
+		}
 		tr.tx_buf = t_buffer;
 
 		memset(&msg, 0, sizeof(msg));
@@ -286,17 +421,19 @@ static int spi_cmd_complete(struct wilc *wilc, u8 cmd, u32 adr, u8 *b, u32 sz,
 	u8 rsp;
 	int len = 0;
 	int result = N_OK;
+	int retry;
+	u8 crc[2];
 
 	wb[0] = cmd;
 	switch (cmd) {
-	case CMD_SINGLE_READ:                           /* single word (4 bytes) read */
+	case CMD_SINGLE_READ: /* single word (4 bytes) read */
 		wb[1] = (u8)(adr >> 16);
 		wb[2] = (u8)(adr >> 8);
 		wb[3] = (u8)adr;
 		len = 5;
 		break;
 
-	case CMD_INTERNAL_READ:                 /* internal register read */
+	case CMD_INTERNAL_READ: /* internal register read */
 		wb[1] = (u8)(adr >> 8);
 		if (clockless == 1)
 			wb[1] |= BIT(7);
@@ -305,29 +442,29 @@ static int spi_cmd_complete(struct wilc *wilc, u8 cmd, u32 adr, u8 *b, u32 sz,
 		len = 5;
 		break;
 
-	case CMD_TERMINATE:                                     /* termination */
+	case CMD_TERMINATE:
 		wb[1] = 0x00;
 		wb[2] = 0x00;
 		wb[3] = 0x00;
 		len = 5;
 		break;
 
-	case CMD_REPEAT:                                                /* repeat */
+	case CMD_REPEAT:
 		wb[1] = 0x00;
 		wb[2] = 0x00;
 		wb[3] = 0x00;
 		len = 5;
 		break;
 
-	case CMD_RESET:                                                 /* reset */
+	case CMD_RESET:
 		wb[1] = 0xff;
 		wb[2] = 0xff;
 		wb[3] = 0xff;
 		len = 5;
 		break;
 
-	case CMD_DMA_WRITE:                                     /* dma write */
-	case CMD_DMA_READ:                                      /* dma read */
+	case CMD_DMA_WRITE: /* dma write */
+	case CMD_DMA_READ:  /* dma read */
 		wb[1] = (u8)(adr >> 16);
 		wb[2] = (u8)(adr >> 8);
 		wb[3] = (u8)adr;
@@ -336,8 +473,8 @@ static int spi_cmd_complete(struct wilc *wilc, u8 cmd, u32 adr, u8 *b, u32 sz,
 		len = 7;
 		break;
 
-	case CMD_DMA_EXT_WRITE:         /* dma extended write */
-	case CMD_DMA_EXT_READ:                  /* dma extended read */
+	case CMD_DMA_EXT_WRITE: /* dma extended write */
+	case CMD_DMA_EXT_READ:  /* dma extended read */
 		wb[1] = (u8)(adr >> 16);
 		wb[2] = (u8)(adr >> 8);
 		wb[3] = (u8)adr;
@@ -347,7 +484,7 @@ static int spi_cmd_complete(struct wilc *wilc, u8 cmd, u32 adr, u8 *b, u32 sz,
 		len = 8;
 		break;
 
-	case CMD_INTERNAL_WRITE:                /* internal register write */
+	case CMD_INTERNAL_WRITE: /* internal register write */
 		wb[1] = (u8)(adr >> 8);
 		if (clockless == 1)
 			wb[1] |= BIT(7);
@@ -359,7 +496,7 @@ static int spi_cmd_complete(struct wilc *wilc, u8 cmd, u32 adr, u8 *b, u32 sz,
 		len = 8;
 		break;
 
-	case CMD_SINGLE_WRITE:                  /* single word write */
+	case CMD_SINGLE_WRITE: /* single word write */
 		wb[1] = (u8)(adr >> 16);
 		wb[2] = (u8)(adr >> 8);
 		wb[3] = (u8)(adr);
@@ -389,18 +526,17 @@ static int spi_cmd_complete(struct wilc *wilc, u8 cmd, u32 adr, u8 *b, u32 sz,
 #define NUM_DATA_BYTES (4)
 #define NUM_CRC_BYTES (2)
 #define NUM_DUMMY_BYTES (3)
-	if ((cmd == CMD_RESET) ||
-	    (cmd == CMD_TERMINATE) ||
-	    (cmd == CMD_REPEAT)) {
+	if (cmd == CMD_RESET ||
+	    cmd == CMD_TERMINATE ||
+	    cmd == CMD_REPEAT) {
 		len2 = len + (NUM_SKIP_BYTES + NUM_RSP_BYTES + NUM_DUMMY_BYTES);
-	} else if ((cmd == CMD_INTERNAL_READ) || (cmd == CMD_SINGLE_READ)) {
-		if (!g_spi.crc_off) {
-			len2 = len + (NUM_RSP_BYTES + NUM_DATA_HDR_BYTES + NUM_DATA_BYTES
-				      + NUM_CRC_BYTES + NUM_DUMMY_BYTES);
-		} else {
-			len2 = len + (NUM_RSP_BYTES + NUM_DATA_HDR_BYTES + NUM_DATA_BYTES
-				      + NUM_DUMMY_BYTES);
-		}
+	} else if (cmd == CMD_INTERNAL_READ || cmd == CMD_SINGLE_READ) {
+		int tmp = NUM_RSP_BYTES + NUM_DATA_HDR_BYTES + NUM_DATA_BYTES
+			+ NUM_DUMMY_BYTES;
+		if (!g_spi.crc_off)
+			len2 = len + tmp + NUM_CRC_BYTES;
+		else
+			len2 = len + tmp;
 	} else {
 		len2 = len + (NUM_RSP_BYTES + NUM_DUMMY_BYTES);
 	}
@@ -421,19 +557,13 @@ static int spi_cmd_complete(struct wilc *wilc, u8 cmd, u32 adr, u8 *b, u32 sz,
 		return N_FAIL;
 	}
 
-	/**
+	/*
 	 * Command/Control response
-	 **/
-	if ((cmd == CMD_RESET) ||
-	    (cmd == CMD_TERMINATE) ||
-	    (cmd == CMD_REPEAT)) {
-		rix++;         /* skip 1 byte */
-	}
+	 */
+	if (cmd == CMD_RESET || cmd == CMD_TERMINATE || cmd == CMD_REPEAT)
+		rix++; /* skip 1 byte */
 
-	/* do { */
 	rsp = rb[rix++];
-	/*	if(rsp == cmd) break; */
-	/* } while(&rptr[1] <= &rb[len2]); */
 
 	if (rsp != cmd) {
 		dev_err(&spi->dev,
@@ -442,9 +572,9 @@ static int spi_cmd_complete(struct wilc *wilc, u8 cmd, u32 adr, u8 *b, u32 sz,
 		return N_FAIL;
 	}
 
-	/**
+	/*
 	 * State response
-	 **/
+	 */
 	rsp = rb[rix++];
 	if (rsp != 0x00) {
 		dev_err(&spi->dev, "Failed cmd state response state (%02x)\n",
@@ -452,17 +582,17 @@ static int spi_cmd_complete(struct wilc *wilc, u8 cmd, u32 adr, u8 *b, u32 sz,
 		return N_FAIL;
 	}
 
-	if ((cmd == CMD_INTERNAL_READ) || (cmd == CMD_SINGLE_READ) ||
-	    (cmd == CMD_DMA_READ) || (cmd == CMD_DMA_EXT_READ)) {
-		int retry;
-		/* u16 crc1, crc2; */
-		u8 crc[2];
-		/**
+	if (cmd == CMD_INTERNAL_READ || cmd == CMD_SINGLE_READ ||
+	    cmd == CMD_DMA_READ || cmd == CMD_DMA_EXT_READ) {
+		/*
 		 * Data Respnose header
-		 **/
-		retry = 100;
+		 */
+		retry = SPI_RESP_RETRY_COUNT;
 		do {
-			/* ensure there is room in buffer later to read data and crc */
+			/*
+			 * ensure there is room in buffer later
+			 * to read data and crc
+			 */
 			if (rix < len2) {
 				rsp = rb[rix++];
 			} else {
@@ -478,132 +608,134 @@ static int spi_cmd_complete(struct wilc *wilc, u8 cmd, u32 adr, u8 *b, u32 sz,
 				"Error, data read response (%02x)\n", rsp);
 			return N_RESET;
 		}
+	}
 
-		if ((cmd == CMD_INTERNAL_READ) || (cmd == CMD_SINGLE_READ)) {
-			/**
-			 * Read bytes
-			 **/
-			if ((rix + 3) < len2) {
-				b[0] = rb[rix++];
-				b[1] = rb[rix++];
-				b[2] = rb[rix++];
-				b[3] = rb[rix++];
+	if (cmd == CMD_INTERNAL_READ || cmd == CMD_SINGLE_READ) {
+		/*
+		 * Read bytes
+		 */
+		if ((rix + 3) < len2) {
+			b[0] = rb[rix++];
+			b[1] = rb[rix++];
+			b[2] = rb[rix++];
+			b[3] = rb[rix++];
+		} else {
+			dev_err(&spi->dev,
+				"buffer overrun when reading data.\n");
+			return N_FAIL;
+		}
+
+		if (!g_spi.crc_off) {
+			/*
+			 * Read Crc
+			 */
+			if ((rix + 1) < len2) {
+				crc[0] = rb[rix++];
+				crc[1] = rb[rix++];
 			} else {
 				dev_err(&spi->dev,
-					"buffer overrun when reading data.\n");
+					"buffer overrun when reading crc.\n");
 				return N_FAIL;
 			}
+		}
+	} else if ((cmd == CMD_DMA_READ) || (cmd == CMD_DMA_EXT_READ)) {
+		int ix;
 
-			if (!g_spi.crc_off) {
-				/**
-				 * Read Crc
-				 **/
-				if ((rix + 1) < len2) {
-					crc[0] = rb[rix++];
-					crc[1] = rb[rix++];
-				} else {
-					dev_err(&spi->dev, "buffer overrun when reading crc.\n");
-					return N_FAIL;
-				}
-			}
-		} else if ((cmd == CMD_DMA_READ) || (cmd == CMD_DMA_EXT_READ)) {
-			int ix;
-
-			/* some data may be read in response to dummy bytes. */
-			for (ix = 0; (rix < len2) && (ix < sz); )
-				b[ix++] = rb[rix++];
-
-			sz -= ix;
+		/* some data may be read in response to dummy bytes. */
+		for (ix = 0; (rix < len2) && (ix < sz); )
+			b[ix++] = rb[rix++];
 
-			if (sz > 0) {
-				int nbytes;
+		sz -= ix;
 
-				if (sz <= (DATA_PKT_SZ - ix))
-					nbytes = sz;
-				else
-					nbytes = DATA_PKT_SZ - ix;
+		if (sz > 0) {
+			int nbytes;
 
-				/**
-				 * Read bytes
-				 **/
-				if (wilc_spi_rx(wilc, &b[ix], nbytes)) {
-					dev_err(&spi->dev, "Failed data block read, bus error...\n");
-					result = N_FAIL;
-					goto _error_;
-				}
+			if (sz <= (DATA_PKT_SZ - ix))
+				nbytes = sz;
+			else
+				nbytes = DATA_PKT_SZ - ix;
 
-				/**
-				 * Read Crc
-				 **/
-				if (!g_spi.crc_off) {
-					if (wilc_spi_rx(wilc, crc, 2)) {
-						dev_err(&spi->dev, "Failed data block crc read, bus error...\n");
-						result = N_FAIL;
-						goto _error_;
-					}
-				}
+			/*
+			 * Read bytes
+			 */
+			if (wilc_spi_rx(wilc, &b[ix], nbytes)) {
+				dev_err(&spi->dev,
+					"Failed block read, bus err\n");
+				return N_FAIL;
+			}
 
-				ix += nbytes;
-				sz -= nbytes;
+			/*
+			 * Read Crc
+			 */
+			if (!g_spi.crc_off && wilc_spi_rx(wilc, crc, 2)) {
+				dev_err(&spi->dev,
+					"Failed block crc read, bus err\n");
+				return N_FAIL;
 			}
 
-			/*  if any data in left unread, then read the rest using normal DMA code.*/
-			while (sz > 0) {
-				int nbytes;
-
-				if (sz <= DATA_PKT_SZ)
-					nbytes = sz;
-				else
-					nbytes = DATA_PKT_SZ;
-
-				/**
-				 * read data response only on the next DMA cycles not
-				 * the first DMA since data response header is already
-				 * handled above for the first DMA.
-				 **/
-				/**
-				 * Data Respnose header
-				 **/
-				retry = 10;
-				do {
-					if (wilc_spi_rx(wilc, &rsp, 1)) {
-						dev_err(&spi->dev, "Failed data response read, bus error...\n");
-						result = N_FAIL;
-						break;
-					}
-					if (((rsp >> 4) & 0xf) == 0xf)
-						break;
-				} while (retry--);
-
-				if (result == N_FAIL)
-					break;
+			ix += nbytes;
+			sz -= nbytes;
+		}
+
+		/*
+		 * if any data in left unread,
+		 * then read the rest using normal DMA code.
+		 */
+		while (sz > 0) {
+			int nbytes;
 
-				/**
-				 * Read bytes
-				 **/
-				if (wilc_spi_rx(wilc, &b[ix], nbytes)) {
-					dev_err(&spi->dev, "Failed data block read, bus error...\n");
+			if (sz <= DATA_PKT_SZ)
+				nbytes = sz;
+			else
+				nbytes = DATA_PKT_SZ;
+
+			/*
+			 * read data response only on the next DMA cycles not
+			 * the first DMA since data response header is already
+			 * handled above for the first DMA.
+			 */
+			/*
+			 * Data Respnose header
+			 */
+			retry = SPI_RESP_RETRY_COUNT;
+			do {
+				if (wilc_spi_rx(wilc, &rsp, 1)) {
+					dev_err(&spi->dev,
+						"Failed resp read, bus err\n");
 					result = N_FAIL;
 					break;
 				}
+				if (((rsp >> 4) & 0xf) == 0xf)
+					break;
+			} while (retry--);
 
-				/**
-				 * Read Crc
-				 **/
-				if (!g_spi.crc_off) {
-					if (wilc_spi_rx(wilc, crc, 2)) {
-						dev_err(&spi->dev, "Failed data block crc read, bus error...\n");
-						result = N_FAIL;
-						break;
-					}
-				}
+			if (result == N_FAIL)
+				break;
 
-				ix += nbytes;
-				sz -= nbytes;
+			/*
+			 * Read bytes
+			 */
+			if (wilc_spi_rx(wilc, &b[ix], nbytes)) {
+				dev_err(&spi->dev,
+					"Failed block read, bus err\n");
+				result = N_FAIL;
+				break;
+			}
+
+			/*
+			 * Read Crc
+			 */
+			if (!g_spi.crc_off && wilc_spi_rx(wilc, crc, 2)) {
+				dev_err(&spi->dev,
+					"Failed block crc read, bus err\n");
+				result = N_FAIL;
+				break;
 			}
+
+			ix += nbytes;
+			sz -= nbytes;
 		}
 	}
-_error_:
 	return result;
 }
 
@@ -613,35 +745,29 @@ static int spi_data_write(struct wilc *wilc, u8 *b, u32 sz)
 	int ix, nbytes;
 	int result = 1;
 	u8 cmd, order, crc[2] = {0};
-	/* u8 rsp; */
 
-	/**
-	 *      Data
-	 **/
+	/*
+	 * Data
+	 */
 	ix = 0;
 	do {
-		if (sz <= DATA_PKT_SZ)
+		if (sz <= DATA_PKT_SZ) {
 			nbytes = sz;
-		else
+			order = 0x3;
+		} else {
 			nbytes = DATA_PKT_SZ;
-
-		/**
-		 *      Write command
-		 **/
-		cmd = 0xf0;
-		if (ix == 0) {
-			if (sz <= DATA_PKT_SZ)
-
-				order = 0x3;
-			else
+			if (ix == 0)
 				order = 0x1;
-		} else {
-			if (sz <= DATA_PKT_SZ)
-				order = 0x3;
 			else
-				order = 0x2;
+				order = 0x02;
 		}
+
+		/*
+		 * Write command
+		 */
+		cmd = 0xf0;
 		cmd |= order;
+
 		if (wilc_spi_tx(wilc, &cmd, 1)) {
 			dev_err(&spi->dev,
 				"Failed data block cmd write, bus error...\n");
@@ -649,9 +775,9 @@ static int spi_data_write(struct wilc *wilc, u8 *b, u32 sz)
 			break;
 		}
 
-		/**
-		 *      Write data
-		 **/
+		/*
+		 * Write data
+		 */
 		if (wilc_spi_tx(wilc, &b[ix], nbytes)) {
 			dev_err(&spi->dev,
 				"Failed data block write, bus error...\n");
@@ -659,9 +785,9 @@ static int spi_data_write(struct wilc *wilc, u8 *b, u32 sz)
 			break;
 		}
 
-		/**
-		 *      Write Crc
-		 **/
+		/*
+		 * Write Crc
+		 */
 		if (!g_spi.crc_off) {
 			if (wilc_spi_tx(wilc, crc, 2)) {
 				dev_err(&spi->dev, "Failed data block crc write, bus error...\n");
@@ -670,9 +796,9 @@ static int spi_data_write(struct wilc *wilc, u8 *b, u32 sz)
 			}
 		}
 
-		/**
-		 *      No need to wait for response
-		 **/
+		/*
+		 * No need to wait for response
+		 */
 		ix += nbytes;
 		sz -= nbytes;
 	} while (sz);
@@ -690,31 +816,57 @@ static int spi_internal_write(struct wilc *wilc, u32 adr, u32 dat)
 {
 	struct spi_device *spi = to_spi_device(wilc->dev);
 	int result;
+	u8 retry = SPI_RETRY_COUNT;
 
+retry:
 	dat = cpu_to_le32(dat);
 	result = spi_cmd_complete(wilc, CMD_INTERNAL_WRITE, adr, (u8 *)&dat, 4,
 				  0);
-	if (result != N_OK)
+	if (result != N_OK) {
 		dev_err(&spi->dev, "Failed internal write cmd...\n");
+		goto fail;
+	}
 
+fail:
+	if (result != N_OK) {
+		msleep(1);
+		wilc_spi_reset(wilc);
+		dev_err(&spi->dev, "Reset and retry %d %x\n",retry, adr);
+		msleep(1);
+		retry--;
+		if(retry)
+			goto retry;
+	}
 	return result;
 }
 
 static int spi_internal_read(struct wilc *wilc, u32 adr, u32 *data)
 {
 	struct spi_device *spi = to_spi_device(wilc->dev);
-	int result;
+	int result = N_OK;
+	u8 retry = SPI_RETRY_COUNT;
 
+retry:
 	result = spi_cmd_complete(wilc, CMD_INTERNAL_READ, adr, (u8 *)data, 4,
 				  0);
 	if (result != N_OK) {
 		dev_err(&spi->dev, "Failed internal read cmd...\n");
-		return 0;
+		goto fail;
 	}
 
 	*data = cpu_to_le32(*data);
 
-	return 1;
+fail:
+	if(result != N_OK) {
+		msleep(1);
+		wilc_spi_reset(wilc);
+		dev_err(&spi->dev, "Reset and retry %d %x\n",retry, adr);
+		msleep(1);
+		retry--;
+		if(retry)
+			goto retry;
+	}
+	return result;
 }
 
 /********************************************
@@ -726,21 +878,39 @@ static int spi_internal_read(struct wilc *wilc, u32 adr, u32 *data)
 static int wilc_spi_write_reg(struct wilc *wilc, u32 addr, u32 data)
 {
 	struct spi_device *spi = to_spi_device(wilc->dev);
+	u8 retry = SPI_RETRY_COUNT;
 	int result = N_OK;
 	u8 cmd = CMD_SINGLE_WRITE;
 	u8 clockless = 0;
 
 	data = cpu_to_le32(data);
-	if (addr < 0x30) {
-		/* Clockless register*/
+_RETRY_:
+	if (addr <= 0x30) {
+		/* Clockless register */
 		cmd = CMD_INTERNAL_WRITE;
 		clockless = 1;
+	} else {
+		cmd = CMD_SINGLE_WRITE;
+		clockless = 0;
 	}
 
 	result = spi_cmd_complete(wilc, cmd, addr, (u8 *)&data, 4, clockless);
-	if (result != N_OK)
+	if (result != N_OK) {
 		dev_err(&spi->dev, "Failed cmd, write reg (%08x)...\n", addr);
+		goto fail;
+	}
 
+fail:
+	if (result != N_OK) {
+		msleep(1);
+		wilc_spi_reset(wilc);
+		dev_err(&spi->dev,
+			"Reset and retry %d %x %d\n",retry, addr, data);
+		msleep(1);
+		retry--;
+		if(retry)
+			goto _RETRY_;
+	}
 	return result;
 }
 
@@ -748,72 +918,121 @@ static int wilc_spi_write(struct wilc *wilc, u32 addr, u8 *buf, u32 size)
 {
 	struct spi_device *spi = to_spi_device(wilc->dev);
 	int result;
-	u8 cmd = CMD_DMA_EXT_WRITE;
+	u8 retry = SPI_RETRY_COUNT;
 
-	/**
-	 *      has to be greated than 4
-	 **/
+	/*
+	 * has to be greated than 4
+	 */
 	if (size <= 4)
 		return 0;
 
-	result = spi_cmd_complete(wilc, cmd, addr, NULL, size, 0);
+retry:
+	result = spi_cmd_complete(wilc, CMD_DMA_EXT_WRITE, addr, NULL, size, 0);
 	if (result != N_OK) {
 		dev_err(&spi->dev,
 			"Failed cmd, write block (%08x)...\n", addr);
-		return 0;
+		goto fail;
 	}
 
-	/**
-	 *      Data
-	 **/
+	/*
+	 * Data
+	 */
 	result = spi_data_write(wilc, buf, size);
-	if (result != N_OK)
+	if (result != N_OK) {
+		dev_err(&spi->dev, "Failed block data write...\n");
+		goto fail;
+	}
+	/*
+	 * Data RESP
+	 */
+	result = spi_data_rsp(wilc, CMD_DMA_EXT_WRITE);
+	if (result != N_OK) {
 		dev_err(&spi->dev, "Failed block data write...\n");
+		goto fail;
+	}
 
-	return 1;
+fail:
+	if (result != N_OK) {
+		msleep(1);
+		wilc_spi_reset(wilc);
+		dev_err(&spi->dev,
+			"Reset and retry %d %x %d\n",retry, addr, size);
+		msleep(1);
+		retry--;
+		if(retry)
+			goto retry;
+	}
+	return result;
 }
 
 static int wilc_spi_read_reg(struct wilc *wilc, u32 addr, u32 *data)
 {
 	struct spi_device *spi = to_spi_device(wilc->dev);
+	u8 retry = SPI_RETRY_COUNT;
 	int result = N_OK;
 	u8 cmd = CMD_SINGLE_READ;
 	u8 clockless = 0;
 
-	if (addr < 0x30) {
+retry:
+	if (addr <= 0x30) {
 		/* dev_err(&spi->dev, "***** read addr %d\n\n", addr); */
-		/* Clockless register*/
+		/* Clockless register */
 		cmd = CMD_INTERNAL_READ;
 		clockless = 1;
+	} else {
+		cmd = CMD_SINGLE_READ;
+		clockless = 0;
 	}
 
 	result = spi_cmd_complete(wilc, cmd, addr, (u8 *)data, 4, clockless);
 	if (result != N_OK) {
 		dev_err(&spi->dev, "Failed cmd, read reg (%08x)...\n", addr);
-		return 0;
+		goto fail;
 	}
 
 	*data = cpu_to_le32(*data);
 
-	return 1;
+fail:
+	if(result != N_OK) {
+		msleep(1);
+		wilc_spi_reset(wilc);
+		dev_warn(&spi->dev, "Reset and retry %d %x\n",retry, addr);
+		msleep(1);
+		retry--;
+		if(retry)
+			goto retry;
+	}
+	return result;
 }
 
 static int wilc_spi_read(struct wilc *wilc, u32 addr, u8 *buf, u32 size)
 {
 	struct spi_device *spi = to_spi_device(wilc->dev);
-	u8 cmd = CMD_DMA_EXT_READ;
 	int result;
+	u8 retry = SPI_RETRY_COUNT;
 
 	if (size <= 4)
 		return 0;
 
-	result = spi_cmd_complete(wilc, cmd, addr, buf, size, 0);
+retry:
+	result = spi_cmd_complete(wilc, CMD_DMA_EXT_READ, addr, buf, size, 0);
 	if (result != N_OK) {
 		dev_err(&spi->dev, "Failed cmd, read block (%08x)...\n", addr);
-		return 0;
+		goto fail;
 	}
 
-	return 1;
+fail:
+	if(result != N_OK) {
+		msleep(1);
+		wilc_spi_reset(wilc);
+		dev_warn(&spi->dev, "Reset and retry %d %x %d\n",retry, addr,
+			 size);
+		msleep(1);
+		retry--;
+		if(retry)
+			goto retry;
+	}
+	return result;
 }
 
 /********************************************
@@ -822,11 +1041,32 @@ static int wilc_spi_read(struct wilc *wilc, u32 addr, u8 *buf, u32 size)
  *
  ********************************************/
 
+int wilc_spi_reset(struct wilc *wilc)
+{
+	struct spi_device *spi = to_spi_device(wilc->dev);
+	int result = N_OK;
+
+	result = spi_cmd_complete(wilc, CMD_RESET, 0, 0 ,0, 0);
+	if (result != N_OK) {
+		dev_err(&spi->dev, "Failed cmd reset \n");
+		return 0;
+	}
+
+	return 1;
+}
+
+static bool wilc_spi_is_init(void)
+{
+	return g_spi.is_init;
+}
+
 static int _wilc_spi_deinit(struct wilc *wilc)
 {
-	/**
-	 *      TODO:
-	 **/
+	/*
+	 * TODO:
+	 */
+	g_spi.is_init = false;
+
 	return 1;
 }
 
@@ -836,9 +1076,7 @@ static int wilc_spi_init(struct wilc *wilc, bool resume)
 	u32 reg;
 	u32 chipid;
 
-	static int isinit;
-
-	if (isinit) {
+	if (g_spi.is_init) {
 		if (!wilc_spi_read_reg(wilc, 0x1000, &chipid)) {
 			dev_err(&spi->dev, "Fail cmd read chip id...\n");
 			return 0;
@@ -848,206 +1086,103 @@ static int wilc_spi_init(struct wilc *wilc, bool resume)
 
 	memset(&g_spi, 0, sizeof(struct wilc_spi));
 
-	/**
-	 *      configure protocol
-	 **/
+	/*
+	 * configure protocol
+	 */
 	g_spi.crc_off = 0;
 
-	/* TODO: We can remove the CRC trials if there is a definite way to reset */
+	/*
+	 * TODO: We can remove the CRC trials if there is a definite
+	 * way to reset
+	 */
 	/* the SPI to it's initial value. */
 	if (!spi_internal_read(wilc, WILC_SPI_PROTOCOL_OFFSET, &reg)) {
-		/* Read failed. Try with CRC off. This might happen when module
+		/*
+		 * Read failed. Try with CRC off. This might happen when module
 		 * is removed but chip isn't reset
 		 */
 		g_spi.crc_off = 1;
-		dev_err(&spi->dev, "Failed internal read protocol with CRC on, retrying with CRC off...\n");
+		dev_err(&spi->dev,
+			"Failed read with CRC on, retrying with CRC off\n");
 		if (!spi_internal_read(wilc, WILC_SPI_PROTOCOL_OFFSET, &reg)) {
-			/* Reaad failed with both CRC on and off, something went bad */
-			dev_err(&spi->dev,
-				"Failed internal read protocol...\n");
+			/*
+			 * Read failed with both CRC on and off,
+			 * something went bad
+			 */
+			dev_err(&spi->dev, "Failed internal read protocol...\n");
 			return 0;
 		}
 	}
-	if (g_spi.crc_off == 0)	{
-		reg &= ~0xc;    /* disable crc checking */
+	if (g_spi.crc_off == 0) {
+		reg &= ~0xc; /* disable crc checking */
 		reg &= ~0x70;
 		reg |= (0x5 << 4);
 		if (!spi_internal_write(wilc, WILC_SPI_PROTOCOL_OFFSET, reg)) {
-			dev_err(&spi->dev, "[wilc spi %d]: Failed internal write protocol reg...\n", __LINE__);
+			dev_err(&spi->dev,
+				"[wilc spi %d]: Failed internal write reg\n",
+				__LINE__);
 			return 0;
 		}
 		g_spi.crc_off = 1;
 	}
 
-	/**
-	 *      make sure can read back chip id correctly
-	 **/
+	/*
+	 * make sure can read back chip id correctly
+	 */
 	if (!wilc_spi_read_reg(wilc, 0x1000, &chipid)) {
 		dev_err(&spi->dev, "Fail cmd read chip id...\n");
 		return 0;
 	}
-	/* dev_err(&spi->dev, "chipid (%08x)\n", chipid); */
 
-	g_spi.has_thrpt_enh = 1;
-
-	isinit = 1;
+	if (!resume) {
+		chipid = wilc_get_chipid(wilc, true);
+		if(ISWILC3000(chipid)) {
+			wilc->chip = WILC_3000;
+			goto pass;
+		} else if(ISWILC1000(chipid)) {
+			wilc->chip = WILC_1000;
+			goto pass;
+		} else {
+			dev_err(&spi->dev, "Unsupported chipid: %x\n", chipid);
+			goto fail;
+		}
+		dev_dbg(&spi->dev, "chipid %08x\n", chipid);
+	}
 
+pass:
+	g_spi.is_init = true;
 	return 1;
+
+fail:
+	return 0;
 }
 
 static int wilc_spi_read_size(struct wilc *wilc, u32 *size)
 {
-	struct spi_device *spi = to_spi_device(wilc->dev);
 	int ret;
 
-	if (g_spi.has_thrpt_enh) {
-		ret = spi_internal_read(wilc, 0xe840 - WILC_SPI_REG_BASE,
-					size);
-		*size = *size  & IRQ_DMA_WD_CNT_MASK;
-	} else {
-		u32 tmp;
-		u32 byte_cnt;
+	ret = spi_internal_read(wilc, 0xe840 - WILC_SPI_REG_BASE,
+				size);
+	*size = *size  & IRQ_DMA_WD_CNT_MASK;
 
-		ret = wilc_spi_read_reg(wilc, WILC_VMM_TO_HOST_SIZE,
-					&byte_cnt);
-		if (!ret) {
-			dev_err(&spi->dev,
-				"Failed read WILC_VMM_TO_HOST_SIZE ...\n");
-			goto _fail_;
-		}
-		tmp = (byte_cnt >> 2) & IRQ_DMA_WD_CNT_MASK;
-		*size = tmp;
-	}
-
-_fail_:
 	return ret;
 }
 
 static int wilc_spi_read_int(struct wilc *wilc, u32 *int_status)
 {
-	struct spi_device *spi = to_spi_device(wilc->dev);
 	int ret;
-	u32 tmp;
-	u32 byte_cnt;
-	int happened, j;
-	u32 unknown_mask;
-	u32 irq_flags;
-
-	if (g_spi.has_thrpt_enh) {
-		ret = spi_internal_read(wilc, 0xe840 - WILC_SPI_REG_BASE,
-					int_status);
-	} else {
-		ret = wilc_spi_read_reg(wilc, WILC_VMM_TO_HOST_SIZE,
-					&byte_cnt);
-		if (!ret) {
-			dev_err(&spi->dev,
-				"Failed read WILC_VMM_TO_HOST_SIZE ...\n");
-			goto _fail_;
-		}
-		tmp = (byte_cnt >> 2) & IRQ_DMA_WD_CNT_MASK;
 
-		j = 0;
-		do {
-			happened = 0;
-
-			wilc_spi_read_reg(wilc, 0x1a90, &irq_flags);
-			tmp |= ((irq_flags >> 27) << IRG_FLAGS_OFFSET);
+	ret = spi_internal_read(wilc, 0xe840 - WILC_SPI_REG_BASE,
+				int_status);
 
-			if (g_spi.nint > 5) {
-				wilc_spi_read_reg(wilc, 0x1a94,
-						  &irq_flags);
-				tmp |= (((irq_flags >> 0) & 0x7) << (IRG_FLAGS_OFFSET + 5));
-			}
-
-			unknown_mask = ~((1ul << g_spi.nint) - 1);
-
-			if ((tmp >> IRG_FLAGS_OFFSET) & unknown_mask) {
-				dev_err(&spi->dev, "Unexpected interrupt (2): j=%d, tmp=%x, mask=%x\n", j, tmp, unknown_mask);
-					happened = 1;
-			}
-
-			j++;
-		} while (happened);
-
-		*int_status = tmp;
-	}
-
-_fail_:
 	return ret;
 }
 
 static int wilc_spi_clear_int_ext(struct wilc *wilc, u32 val)
 {
-	struct spi_device *spi = to_spi_device(wilc->dev);
 	int ret;
 
-	if (g_spi.has_thrpt_enh) {
-		ret = spi_internal_write(wilc, 0xe844 - WILC_SPI_REG_BASE,
-					 val);
-	} else {
-		u32 flags;
-
-		flags = val & (BIT(MAX_NUM_INT) - 1);
-		if (flags) {
-			int i;
-
-			ret = 1;
-			for (i = 0; i < g_spi.nint; i++) {
-				/* No matter what you write 1 or 0, it will clear interrupt. */
-				if (flags & 1)
-					ret = wilc_spi_write_reg(wilc, 0x10c8 + i * 4, 1);
-				if (!ret)
-					break;
-				flags >>= 1;
-			}
-			if (!ret) {
-				dev_err(&spi->dev,
-					"Failed wilc_spi_write_reg, set reg %x ...\n",
-					0x10c8 + i * 4);
-				goto _fail_;
-			}
-			for (i = g_spi.nint; i < MAX_NUM_INT; i++) {
-				if (flags & 1)
-					dev_err(&spi->dev,
-						"Unexpected interrupt cleared %d...\n",
-						i);
-				flags >>= 1;
-			}
-		}
-
-		{
-			u32 tbl_ctl;
-
-			tbl_ctl = 0;
-			/* select VMM table 0 */
-			if ((val & SEL_VMM_TBL0) == SEL_VMM_TBL0)
-				tbl_ctl |= BIT(0);
-			/* select VMM table 1 */
-			if ((val & SEL_VMM_TBL1) == SEL_VMM_TBL1)
-				tbl_ctl |= BIT(1);
-
-			ret = wilc_spi_write_reg(wilc, WILC_VMM_TBL_CTL,
-						 tbl_ctl);
-			if (!ret) {
-				dev_err(&spi->dev,
-					"fail write reg vmm_tbl_ctl...\n");
-				goto _fail_;
-			}
-
-			if ((val & EN_VMM) == EN_VMM) {
-				/**
-				 *      enable vmm transfer.
-				 **/
-				ret = wilc_spi_write_reg(wilc,
-							 WILC_VMM_CORE_CTL, 1);
-				if (!ret) {
-					dev_err(&spi->dev, "fail write reg vmm_core_ctl...\n");
-					goto _fail_;
-				}
-			}
-		}
-	}
-_fail_:
+	ret = spi_internal_write(wilc, 0xe844 - WILC_SPI_REG_BASE, val);
 	return ret;
 }
 
@@ -1064,9 +1199,9 @@ static int wilc_spi_sync_ext(struct wilc *wilc, int nint)
 
 	g_spi.nint = nint;
 
-	/**
-	 *      interrupt pin mux select
-	 **/
+	/*
+	 * interrupt pin mux select
+	 */
 	ret = wilc_spi_read_reg(wilc, WILC_PIN_MUX_0, &reg);
 	if (!ret) {
 		dev_err(&spi->dev, "Failed read reg (%08x)...\n",
@@ -1081,9 +1216,9 @@ static int wilc_spi_sync_ext(struct wilc *wilc, int nint)
 		return 0;
 	}
 
-	/**
-	 *      interrupt enable
-	 **/
+	/*
+	 * interrupt enable
+	 */
 	ret = wilc_spi_read_reg(wilc, WILC_INTR_ENABLE, &reg);
 	if (!ret) {
 		dev_err(&spi->dev, "Failed read reg (%08x)...\n",
@@ -1136,4 +1271,6 @@ static const struct wilc_hif_func wilc_hif_spi = {
 	.hif_block_tx_ext = wilc_spi_write,
 	.hif_block_rx_ext = wilc_spi_read,
 	.hif_sync_ext = wilc_spi_sync_ext,
-};
+	.hif_reset = wilc_spi_reset,
+	.hif_is_init = wilc_spi_is_init,
+};
\ No newline at end of file
diff --git a/drivers/staging/wilc/wilc_wfi_cfgoperations.c b/drivers/staging/wilc/wilc_wfi_cfgoperations.c
new file mode 100644
index 0000000..1d5f6f8
--- /dev/null
+++ b/drivers/staging/wilc/wilc_wfi_cfgoperations.c
@@ -0,0 +1,3046 @@
+// SPDX-License-Identifier: GPL-2.0
+#include "wilc_wfi_cfgoperations.h"
+#include "host_interface.h"
+#include "linux_wlan.h"
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <net/cfg80211.h>
+
+#define ENCRYPT_ENABLED		BIT(0)
+#define WEP			BIT(1)
+#define WEP_EXTENDED		BIT(2)
+#define WPA			BIT(3)
+#define WPA2			BIT(4)
+#define AES			BIT(5)
+#define TKIP			BIT(6)
+
+#define FRAME_TYPE_ID			0
+#define ACTION_CAT_ID			24
+#define ACTION_SUBTYPE_ID		25
+#define P2P_PUB_ACTION_SUBTYPE		30
+
+#define ACTION_FRAME			0xd0
+#define GO_INTENT_ATTR_ID		0x04
+#define CHANLIST_ATTR_ID		0x0b
+#define OPERCHAN_ATTR_ID		0x11
+#define PUB_ACTION_ATTR_ID		0x04
+#define P2PELEM_ATTR_ID			0xdd
+
+#define GO_NEG_REQ			0x00
+#define GO_NEG_RSP			0x01
+#define GO_NEG_CONF			0x02
+#define P2P_INV_REQ			0x03
+#define P2P_INV_RSP			0x04
+#define PUBLIC_ACT_VENDORSPEC		0x09
+#define GAS_INITIAL_REQ			0x0a
+#define GAS_INITIAL_RSP			0x0b
+
+#define INVALID_CHANNEL			0
+
+#define nl80211_SCAN_RESULT_EXPIRE	(3 * HZ)
+#define SCAN_RESULT_EXPIRE		(40 * HZ)
+
+static const u32 cipher_suites[] = {
+	WLAN_CIPHER_SUITE_WEP40,
+	WLAN_CIPHER_SUITE_WEP104,
+	WLAN_CIPHER_SUITE_TKIP,
+	WLAN_CIPHER_SUITE_CCMP,
+	WLAN_CIPHER_SUITE_AES_CMAC,
+};
+
+static const struct ieee80211_txrx_stypes
+	wilc_wfi_cfg80211_mgmt_types[NUM_NL80211_IFTYPES] = {
+	[NL80211_IFTYPE_STATION] = {
+		.tx = 0xffff,
+		.rx = BIT(IEEE80211_STYPE_ACTION >> 4) |
+			BIT(IEEE80211_STYPE_PROBE_REQ >> 4)
+	},
+	[NL80211_IFTYPE_AP] = {
+		.tx = 0xffff,
+		.rx = BIT(IEEE80211_STYPE_ASSOC_REQ >> 4) |
+			BIT(IEEE80211_STYPE_REASSOC_REQ >> 4) |
+			BIT(IEEE80211_STYPE_PROBE_REQ >> 4) |
+			BIT(IEEE80211_STYPE_DISASSOC >> 4) |
+			BIT(IEEE80211_STYPE_AUTH >> 4) |
+			BIT(IEEE80211_STYPE_DEAUTH >> 4) |
+			BIT(IEEE80211_STYPE_ACTION >> 4)
+	},
+	[NL80211_IFTYPE_P2P_CLIENT] = {
+		.tx = 0xffff,
+		.rx = BIT(IEEE80211_STYPE_ACTION >> 4) |
+			BIT(IEEE80211_STYPE_PROBE_REQ >> 4) |
+			BIT(IEEE80211_STYPE_ASSOC_REQ >> 4) |
+			BIT(IEEE80211_STYPE_REASSOC_REQ >> 4) |
+			BIT(IEEE80211_STYPE_DISASSOC >> 4) |
+			BIT(IEEE80211_STYPE_AUTH >> 4) |
+			BIT(IEEE80211_STYPE_DEAUTH >> 4)
+	}
+};
+
+static const struct wiphy_wowlan_support wowlan_support = {
+	.flags = WIPHY_WOWLAN_ANY
+};
+
+#define TCP_ACK_FILTER_LINK_SPEED_THRESH	54
+#define DEFAULT_LINK_SPEED			72
+
+#define GET_PKT_OFFSET(a) (((a) >> 22) & 0x1ff)
+
+static struct network_info last_scanned_shadow[MAX_NUM_SCANNED_NETWORKS_SHADOW];
+static u32 last_scanned_cnt;
+static u8 op_ifcs;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 7, 0)
+#define CHAN2G(_channel, _freq, _flags) {	 \
+		.band             = IEEE80211_BAND_2GHZ, \
+		.center_freq      = (_freq),		 \
+		.hw_value         = (_channel),		 \
+		.flags            = (_flags),		 \
+		.max_antenna_gain = 0,			 \
+		.max_power        = 30,			 \
+}				
+#else
+#define CHAN2G(_channel, _freq, _flags) {	 \
+		.band             = NL80211_BAND_2GHZ, \
+		.center_freq      = (_freq),		 \
+		.hw_value         = (_channel),		 \
+		.flags            = (_flags),		 \
+		.max_antenna_gain = 0,			 \
+		.max_power        = 30,			 \
+}
+#endif
+
+static struct ieee80211_channel ieee80211_2ghz_channels[] = {
+	CHAN2G(1,  2412, 0),
+	CHAN2G(2,  2417, 0),
+	CHAN2G(3,  2422, 0),
+	CHAN2G(4,  2427, 0),
+	CHAN2G(5,  2432, 0),
+	CHAN2G(6,  2437, 0),
+	CHAN2G(7,  2442, 0),
+	CHAN2G(8,  2447, 0),
+	CHAN2G(9,  2452, 0),
+	CHAN2G(10, 2457, 0),
+	CHAN2G(11, 2462, 0),
+	CHAN2G(12, 2467, 0),
+	CHAN2G(13, 2472, 0),
+	CHAN2G(14, 2484, 0),
+};
+
+#define RATETAB_ENT(_rate, _hw_value, _flags) {	\
+		.bitrate  = (_rate),			\
+		.hw_value = (_hw_value),		\
+		.flags    = (_flags),			\
+}
+
+static struct ieee80211_rate ieee80211_bitrates[] = {
+	RATETAB_ENT(10,  0,  0),
+	RATETAB_ENT(20,  1,  0),
+	RATETAB_ENT(55,  2,  0),
+	RATETAB_ENT(110, 3,  0),
+	RATETAB_ENT(60,  9,  0),
+	RATETAB_ENT(90,  6,  0),
+	RATETAB_ENT(120, 7,  0),
+	RATETAB_ENT(180, 8,  0),
+	RATETAB_ENT(240, 9,  0),
+	RATETAB_ENT(360, 10, 0),
+	RATETAB_ENT(480, 11, 0),
+	RATETAB_ENT(540, 12, 0),
+};
+
+struct p2p_mgmt_data {
+	int size;
+	u8 *buff;
+};
+
+static u8 wlan_channel = INVALID_CHANNEL;
+static u8 curr_channel;
+static u8 p2p_oui[] = {0x50, 0x6f, 0x9A, 0x09};
+static u8 p2p_local_random = 0x01;
+static u8 p2p_recv_random;
+static u8 p2p_vendor_spec[] = {0xdd, 0x05, 0x00, 0x08, 0x40, 0x03};
+static bool wilc_ie;
+
+static struct ieee80211_supported_band WILC_WFI_band_2ghz = {
+	.channels = ieee80211_2ghz_channels,
+	.n_channels = ARRAY_SIZE(ieee80211_2ghz_channels),
+	.bitrates = ieee80211_bitrates,
+	.n_bitrates = ARRAY_SIZE(ieee80211_bitrates),
+};
+
+#define AGING_TIME	(9 * 1000)
+#define during_ip_time	15000
+
+void clear_shadow_scan(struct wilc_vif *vif)
+{
+	int i;
+
+	if (op_ifcs == 0)
+		return;
+
+	del_timer_sync(&vif->wilc->aging_timer);
+	PRINT_D(vif->ndev, CORECONFIG_DBG, "destroy aging timer\n");
+
+	for (i = 0; i < last_scanned_cnt; i++) {
+		if (last_scanned_shadow[i].ies) {
+			kfree(last_scanned_shadow[i].ies);
+			last_scanned_shadow[i].ies = NULL;
+		}
+
+		kfree(last_scanned_shadow[i].join_params);
+		last_scanned_shadow[i].join_params = NULL;
+	}
+	last_scanned_cnt = 0;
+}
+
+void filter_shadow_scan(void* pUserVoid, u8 *ch_freq_list, u8 ch_list_len)
+{
+	struct WILC_WFI_priv* priv;
+	int i;
+	int ch_index;
+	int j;
+ 	priv = (struct WILC_WFI_priv*)pUserVoid;
+
+	if(ch_list_len > 0) {
+		for(i = 0;i < last_scanned_cnt;) {
+			for(ch_index=0;ch_index < ch_list_len;ch_index++) 				
+				if(last_scanned_shadow[i].ch == (ch_freq_list[ch_index] + 1))
+					break;
+
+			/* filter only un-matched channels */
+			if (ch_index == ch_list_len){
+				if (last_scanned_shadow[i].ies){
+					kfree(last_scanned_shadow[i].ies);
+					last_scanned_shadow[i].ies = NULL;
+				}
+
+				kfree(last_scanned_shadow[i].join_params);
+				last_scanned_shadow[i].join_params = NULL;
+
+				for(j=i;(j<last_scanned_cnt-1);j++)
+					last_scanned_shadow[j] = last_scanned_shadow[j+1];
+
+				last_scanned_cnt--;
+				continue;
+			}
+			i++;
+		}
+	}
+}
+
+static u32 get_rssi_avg(struct network_info *network_info)
+{
+	u8 i;
+	int rssi_v = 0;
+	u8 num_rssi = (network_info->rssi_history.full) ?
+		       NUM_RSSI : (network_info->rssi_history.index);
+
+	for (i = 0; i < num_rssi; i++)
+		rssi_v += network_info->rssi_history.samples[i];
+
+	rssi_v /= num_rssi;
+	return rssi_v;
+}
+
+static void refresh_scan(struct wilc_priv *priv, bool direct_scan)
+{
+	struct wiphy *wiphy = priv->dev->ieee80211_ptr->wiphy;
+	int i;
+
+	for (i = 0; i < last_scanned_cnt; i++) {
+		struct network_info *network_info;
+		s32 freq;
+		struct ieee80211_channel *channel;
+		int rssi;
+		struct cfg80211_bss *bss;
+
+		network_info = &last_scanned_shadow[i];
+
+		if (!network_info)
+			continue;
+
+		if (!memcmp("DIRECT-", network_info->ssid, 7) && !direct_scan)
+			continue;
+
+	#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,7,0)
+		freq = ieee80211_channel_to_frequency((s32)network_info->ch,
+						      NL80211_BAND_2GHZ);
+	#else
+		freq = ieee80211_channel_to_frequency((s32)network_info->ch,
+											  IEEE80211_BAND_2GHZ);
+	#endif
+		channel = ieee80211_get_channel(wiphy, freq);
+		rssi = get_rssi_avg(network_info);
+		bss = cfg80211_inform_bss(wiphy,
+					  channel,
+				#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,18,0)
+					  CFG80211_BSS_FTYPE_UNKNOWN,
+				#endif
+					  network_info->bssid,
+					  network_info->tsf_hi,
+					  network_info->cap_info,
+					  network_info->beacon_period,
+					  (const u8 *)network_info->ies,
+					  (size_t)network_info->ies_len,
+					  (s32)rssi * 100,
+					  GFP_KERNEL);
+		cfg80211_put_bss(wiphy, bss);
+	}
+}
+
+static void reset_shadow_found(void)
+{
+	int i;
+
+	for (i = 0; i < last_scanned_cnt; i++)
+		last_scanned_shadow[i].found = 0;
+}
+
+static void update_scan_time(void)
+{
+	int i;
+
+	for (i = 0; i < last_scanned_cnt; i++)
+		last_scanned_shadow[i].time_scan = jiffies;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,15,0)
+void remove_network_from_shadow(struct timer_list *t)
+#else
+void remove_network_from_shadow(unsigned long arg)
+#endif
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,15,0)
+	struct wilc* wilc = from_timer(wilc, t, aging_timer);
+#else
+	struct wilc* wilc = (struct wilc*)arg;
+#endif
+	struct wilc_vif* vif = wilc->aging_timer_vif;
+	unsigned long now = jiffies;
+	int i, j;
+
+	for (i = 0; i < last_scanned_cnt; i++) {
+		if (time_after(now, last_scanned_shadow[i].time_scan +
+			       (unsigned long)(SCAN_RESULT_EXPIRE))) {
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+				   "Network expired in ScanShadow: %s\n",
+				   last_scanned_shadow[i].ssid);
+			kfree(last_scanned_shadow[i].ies);
+			last_scanned_shadow[i].ies = NULL;
+
+			kfree(last_scanned_shadow[i].join_params);
+
+			for (j = i; (j < last_scanned_cnt - 1); j++)
+				last_scanned_shadow[j] = last_scanned_shadow[j + 1];
+
+			last_scanned_cnt--;
+		}
+	}
+
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "Number of cached networks: %d\n",
+		   last_scanned_cnt);
+
+	if (last_scanned_cnt != 0) {
+	#if LINUX_VERSION_CODE < KERNEL_VERSION(4,15,0)
+		wilc->aging_timer.data = (unsigned long) wilc;
+	#endif
+		wilc->aging_timer_vif = vif;
+		mod_timer(&wilc->aging_timer,
+			  jiffies + msecs_to_jiffies(AGING_TIME));
+	}
+	else {
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "No need to restart Aging timer\n");
+	}
+}
+
+static int is_network_in_shadow(struct network_info *nw_info, struct wilc_priv *priv)
+{
+	struct wilc* wilc;
+	struct wilc_vif* vif;
+	struct net_device *dev;
+	int state = -1;
+	int i;
+
+	dev = priv->dev;
+	vif = netdev_priv(dev);
+	wilc = vif->wilc;
+
+	if (last_scanned_cnt == 0) {
+		PRINT_INFO(priv->dev, CFG80211_DBG, "Starting Aging timer\n");
+	#if LINUX_VERSION_CODE < KERNEL_VERSION(4,15,0)
+		wilc->aging_timer.data = (unsigned long) wilc;
+	#endif
+		wilc->aging_timer_vif = vif;
+		mod_timer(&wilc->aging_timer,
+			  jiffies + msecs_to_jiffies(AGING_TIME));
+		state = -1;
+	} else {
+		for (i = 0; i < last_scanned_cnt; i++) {
+			if (memcmp(last_scanned_shadow[i].bssid,
+				   nw_info->bssid, 6) == 0) {
+				state = i;
+				break;
+			}
+		}
+	}
+	return state;
+}
+
+static void add_network_to_shadow(struct network_info *nw_info,
+				  struct wilc_priv *priv, void *join_params)
+{
+	int ap_found = is_network_in_shadow(nw_info, priv);
+	u32 ap_index = 0;
+	u8 rssi_index = 0;
+
+	if (last_scanned_cnt >= MAX_NUM_SCANNED_NETWORKS_SHADOW) {
+		PRINT_INFO(priv->dev, CFG80211_DBG,
+			   "Shadow network reached its maximum limit\n");
+		return;
+	}
+	if (ap_found == -1) {
+		ap_index = last_scanned_cnt;
+		last_scanned_cnt++;
+	} else {
+		ap_index = ap_found;
+	}
+	rssi_index = last_scanned_shadow[ap_index].rssi_history.index;
+	last_scanned_shadow[ap_index].rssi_history.samples[rssi_index++] = nw_info->rssi;
+	if (rssi_index == NUM_RSSI) {
+		rssi_index = 0;
+		last_scanned_shadow[ap_index].rssi_history.full = true;
+	}
+	last_scanned_shadow[ap_index].rssi_history.index = rssi_index;
+	last_scanned_shadow[ap_index].rssi = nw_info->rssi;
+	last_scanned_shadow[ap_index].cap_info = nw_info->cap_info;
+	last_scanned_shadow[ap_index].ssid_len = nw_info->ssid_len;
+	memcpy(last_scanned_shadow[ap_index].ssid,
+	       nw_info->ssid, nw_info->ssid_len);
+	memcpy(last_scanned_shadow[ap_index].bssid,
+	       nw_info->bssid, ETH_ALEN);
+	last_scanned_shadow[ap_index].beacon_period = nw_info->beacon_period;
+	last_scanned_shadow[ap_index].dtim_period = nw_info->dtim_period;
+	last_scanned_shadow[ap_index].ch = nw_info->ch;
+	last_scanned_shadow[ap_index].ies_len = nw_info->ies_len;
+	last_scanned_shadow[ap_index].tsf_hi = nw_info->tsf_hi;
+	if (ap_found != -1)
+		kfree(last_scanned_shadow[ap_index].ies);
+	last_scanned_shadow[ap_index].ies = kmalloc(nw_info->ies_len,
+						    GFP_KERNEL);
+	memcpy(last_scanned_shadow[ap_index].ies,
+	       nw_info->ies, nw_info->ies_len);
+	last_scanned_shadow[ap_index].time_scan = jiffies;
+	last_scanned_shadow[ap_index].time_scan_cached = jiffies;
+	last_scanned_shadow[ap_index].found = 1;
+	if (ap_found != -1)
+		kfree(last_scanned_shadow[ap_index].join_params);
+	last_scanned_shadow[ap_index].join_params = join_params;
+}
+
+static void cfg_scan_result(enum scan_event scan_event,
+			    struct network_info *network_info,
+			    void *user_void, void *join_params)
+{
+	struct wilc_priv *priv;
+	struct wiphy *wiphy;
+	s32 freq;
+	struct ieee80211_channel *channel;
+	struct cfg80211_bss *bss = NULL;
+
+	priv = user_void;
+	if (!priv->cfg_scanning)
+		return;
+
+	if (scan_event == SCAN_EVENT_NETWORK_FOUND) {
+		wiphy = priv->dev->ieee80211_ptr->wiphy;
+
+		if (!wiphy || !network_info)
+			return;
+
+		if (wiphy->signal_type == CFG80211_SIGNAL_TYPE_UNSPEC &&
+		    (((s32)network_info->rssi * 100) < 0 ||
+		    ((s32)network_info->rssi * 100) > 100))
+			return;
+
+		freq = ieee80211_channel_to_frequency((s32)network_info->ch,
+							 NL80211_BAND_2GHZ);
+		channel = ieee80211_get_channel(wiphy, freq);
+
+		if (!channel)
+			return;
+		PRINT_D(priv->dev, CFG80211_DBG,
+			"Network Info:: CHANNEL Frequency: %d, RSSI: %d, CapabilityInfo: %d, BeaconPeriod: %d\n",
+			channel->center_freq,
+			((s32)network_info->rssi * 100),
+			network_info->cap_info,
+			network_info->beacon_period);
+
+		if (network_info->new_network) {
+			if (priv->rcvd_ch_cnt >= MAX_NUM_SCANNED_NETWORKS) {
+				PRINT_ER(priv->dev,
+					 "Discovered networks exceeded the max limit\n");
+				return;
+			}
+			
+			PRINT_INFO(priv->dev, CFG80211_DBG,
+				    "Network %s found\n",
+				    network_info->ssid);
+			priv->rcvd_ch_cnt++;
+
+			add_network_to_shadow(network_info, priv, join_params);
+
+			if (memcmp("DIRECT-", network_info->ssid, 7))
+				return;
+
+			bss = cfg80211_inform_bss(wiphy,
+						  channel,
+					#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,18,0)
+						  CFG80211_BSS_FTYPE_UNKNOWN,
+					#endif
+						  network_info->bssid,
+						  network_info->tsf_hi,
+						  network_info->cap_info,
+						  network_info->beacon_period,
+						  (const u8 *)network_info->ies,
+						  (size_t)network_info->ies_len,
+						  (s32)network_info->rssi * 100,
+						  GFP_KERNEL);
+			cfg80211_put_bss(wiphy, bss);
+		} else {
+			u32 i;
+
+			for (i = 0; i < priv->rcvd_ch_cnt; i++) {
+				if (memcmp(last_scanned_shadow[i].bssid,
+					   network_info->bssid, 6) == 0)
+					break;
+			}
+
+			if (i >= priv->rcvd_ch_cnt)
+				return;
+
+			PRINT_INFO(priv->dev, CFG80211_DBG,
+				   "Update RSSI of %s\n",
+				   last_scanned_shadow[i].ssid);
+			last_scanned_shadow[i].rssi = network_info->rssi;
+			last_scanned_shadow[i].time_scan = jiffies;
+		}
+	} else if (scan_event == SCAN_EVENT_DONE) {
+		PRINT_INFO(priv->dev, CFG80211_DBG, "Scan Done[%p]\n",
+			   priv->dev);
+		PRINT_INFO(priv->dev, CFG80211_DBG, "Refreshing Scan ...\n");
+		refresh_scan(priv, false);
+
+		if (priv->rcvd_ch_cnt > 0)
+			PRINT_INFO(priv->dev, CFG80211_DBG,
+				   "%d Network(s) found\n", priv->rcvd_ch_cnt);
+		else
+			PRINT_INFO(priv->dev, CFG80211_DBG,
+				   "No networks found\n");
+		mutex_lock(&priv->scan_req_lock);
+
+		if (priv->scan_req) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,7,0)
+			struct cfg80211_scan_info info = {
+				.aborted = false,
+			};
+
+			cfg80211_scan_done(priv->scan_req, &info);
+#else
+			cfg80211_scan_done(priv->scan_req, false);
+#endif
+			priv->rcvd_ch_cnt = 0;
+			priv->cfg_scanning = false;
+			priv->scan_req = NULL;
+		}
+		mutex_unlock(&priv->scan_req_lock);
+	} else if (scan_event == SCAN_EVENT_ABORTED) {
+		mutex_lock(&priv->scan_req_lock);
+
+		PRINT_INFO(priv->dev, CFG80211_DBG, "Scan Aborted \n");
+		if (priv->scan_req) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,7,0)
+			struct cfg80211_scan_info info = {
+				.aborted = false,
+			};
+			cfg80211_scan_done(priv->scan_req, &info);
+#else
+			cfg80211_scan_done(priv->scan_req, false);
+#endif
+
+			update_scan_time();
+			refresh_scan(priv, false);
+			priv->cfg_scanning = false;
+			priv->scan_req = NULL;
+		}
+		mutex_unlock(&priv->scan_req_lock);
+	}
+}
+
+static inline bool wilc_wfi_cfg_scan_time_expired(int i)
+{
+	unsigned long now = jiffies;
+
+	if (time_after(now, last_scanned_shadow[i].time_scan_cached +
+		       (unsigned long)(nl80211_SCAN_RESULT_EXPIRE - (1 * HZ))))
+		return true;
+	else
+		return false;
+}
+
+int wilc_connecting;
+
+static void cfg_connect_result(enum conn_event conn_disconn_evt,
+			       struct connect_info *conn_info,
+			       u8 mac_status,
+			       struct disconnect_info *disconn_info,
+			       void *priv_data)
+{
+	struct wilc_priv *priv;
+	struct net_device *dev;
+	struct host_if_drv *wfi_drv;
+	u8 null_bssid[ETH_ALEN] = {0};
+	struct wilc *wl;
+	struct wilc_vif *vif;
+
+	wilc_connecting = 0;
+
+	priv = priv_data;
+	dev = priv->dev;
+	vif = netdev_priv(dev);
+	wl = vif->wilc;
+	wfi_drv = (struct host_if_drv *)priv->hif_drv;
+
+	if (conn_disconn_evt == CONN_DISCONN_EVENT_CONN_RESP) {
+		u16 connect_status;
+
+		connect_status = conn_info->status;
+
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Connection response received = %d\n",
+			   mac_status);
+		if (mac_status == MAC_STATUS_DISCONNECTED &&
+		    conn_info->status == SUCCESSFUL_STATUSCODE) {
+			connect_status = WLAN_STATUS_UNSPECIFIED_FAILURE;
+			wilc_wlan_set_bssid(priv->dev, null_bssid,
+					    STATION_MODE);
+			eth_zero_addr(wilc_connected_ssid);
+
+			if (!wfi_drv->p2p_connect)
+				wlan_channel = INVALID_CHANNEL;
+
+			PRINT_ER(dev, "Unspecified failure\n");
+		}
+
+		if (connect_status == WLAN_STATUS_SUCCESS) {
+			bool scan_refresh = false;
+			u32 i;
+
+			PRINT_D(vif->ndev, CFG80211_DBG,
+				"Connection Successful: BSSID: %x%x%x%x%x%x\n",
+				conn_info->bssid[0], conn_info->bssid[1],
+				conn_info->bssid[2], conn_info->bssid[3],
+				conn_info->bssid[4], conn_info->bssid[5]);
+			memcpy(priv->associated_bss, conn_info->bssid,
+			       ETH_ALEN);
+
+			for (i = 0; i < last_scanned_cnt; i++) {
+				if (memcmp(last_scanned_shadow[i].bssid,
+					   conn_info->bssid,
+					   ETH_ALEN) == 0) {
+					if (wilc_wfi_cfg_scan_time_expired(i))
+						scan_refresh = true;
+
+					break;
+				}
+			}
+
+			if (scan_refresh)
+				refresh_scan(priv, true);
+		}
+
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Association request info elements length = %d\n",
+			   conn_info->req_ies_len);
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Association response info elements length = %d\n",
+			   conn_info->resp_ies_len);
+		cfg80211_connect_result(dev, conn_info->bssid,
+					conn_info->req_ies,
+					conn_info->req_ies_len,
+					conn_info->resp_ies,
+					conn_info->resp_ies_len, connect_status,
+					GFP_KERNEL);
+	} else if (conn_disconn_evt == CONN_DISCONN_EVENT_DISCONN_NOTIF)    {
+#ifdef DISABLE_PWRSAVE_AND_SCAN_DURING_IP
+		wilc_optaining_ip = false;
+#endif
+		PRINT_ER(vif->ndev,
+			 "Received MAC_STATUS_DISCONNECTED from firmware with reason %d on dev [%p]\n",
+			 disconn_info->reason, priv->dev);
+		p2p_local_random = 0x01;
+		p2p_recv_random = 0x00;
+		wilc_ie = false;
+		eth_zero_addr(priv->associated_bss);
+		wilc_wlan_set_bssid(priv->dev, null_bssid, STATION_MODE);
+		eth_zero_addr(wilc_connected_ssid);
+
+		if (!wfi_drv->p2p_connect)
+			wlan_channel = INVALID_CHANNEL;
+		if (wfi_drv->IFC_UP && dev == wl->vif[1]->ndev)
+			disconn_info->reason = 3;
+		else if (!wfi_drv->IFC_UP && dev == wl->vif[1]->ndev)
+			disconn_info->reason = 1;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,2,0)
+		cfg80211_disconnected(dev, disconn_info->reason,
+				      disconn_info->ie, disconn_info->ie_len,
+				      GFP_KERNEL);
+#else
+		cfg80211_disconnected(dev, disconn_info->reason,
+				      disconn_info->ie, disconn_info->ie_len,
+				      false, GFP_KERNEL);
+#endif
+	}
+}
+
+static int set_channel(struct wiphy *wiphy,
+		       struct cfg80211_chan_def *chandef)
+{
+	u32 channelnum = 0;
+	struct wilc_priv *priv;
+	int result = 0;
+	struct wilc_vif *vif;
+
+	priv = wiphy_priv(wiphy);
+	vif = netdev_priv(priv->dev);
+
+	channelnum = ieee80211_frequency_to_channel(chandef->chan->center_freq);
+	PRINT_INFO(vif->ndev, CFG80211_DBG,
+		   "Setting channel %d with frequency %d\n",
+		   channelnum, chandef->chan->center_freq);
+
+	curr_channel = channelnum;
+	result = wilc_set_mac_chnl_num(vif, channelnum);
+
+	if (result != 0)
+		PRINT_ER(priv->dev, "Error in setting channel %d\n", channelnum);
+
+	return result;
+}
+
+static inline int wilc_wfi_cfg_alloc_fill_ssid(struct wilc_vif *vif, 
+			     struct cfg80211_scan_request *request,
+			     struct hidden_network *ntwk)
+{
+	int i;
+	int slot_id = 0;
+
+	ntwk->net_info = kcalloc(request->n_ssids,
+				 sizeof(struct hidden_network), GFP_KERNEL);
+	if (!ntwk->net_info)
+		goto out;
+
+	ntwk->n_ssids = request->n_ssids;
+
+	for (i = 0; i < request->n_ssids; i++) {
+		if (request->ssids[i].ssid_len > 0) {
+			struct hidden_net_info *info = &ntwk->net_info[slot_id];
+
+			info->ssid = kmemdup(request->ssids[i].ssid,
+					     request->ssids[i].ssid_len,
+					     GFP_KERNEL);
+			if (!info->ssid)
+				goto out_free;
+
+			info->ssid_len = request->ssids[i].ssid_len;
+			slot_id++;
+		} else {
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+				   "Received one NULL SSID\n");
+			ntwk->n_ssids -= 1;
+		}
+	}
+	return 0;
+
+out_free:
+
+	for (i = 0; i < slot_id ; i++)
+		kfree(ntwk->net_info[i].ssid);
+
+	kfree(ntwk->net_info);
+out:
+
+	return -ENOMEM;
+}
+
+static int scan(struct wiphy *wiphy, struct cfg80211_scan_request *request)
+{
+	struct wilc_priv *priv;
+	u32 i;
+	s32 ret = 0;
+	u8 scan_ch_list[MAX_NUM_SCANNED_NETWORKS];
+	struct hidden_network hidden_ntwk;
+	struct wilc_vif *vif;
+
+	priv = wiphy_priv(wiphy);
+	vif = netdev_priv(priv->dev);
+
+	priv->scan_req = request;
+
+	priv->rcvd_ch_cnt = 0;
+
+	reset_shadow_found();
+
+	priv->cfg_scanning = true;
+	if (request->n_channels <= MAX_NUM_SCANNED_NETWORKS) {
+		for (i = 0; i < request->n_channels; i++) {
+			scan_ch_list[i] = (u8)ieee80211_frequency_to_channel(request->channels[i]->center_freq);
+			PRINT_D(vif->ndev, CFG80211_DBG,
+				"ScanChannel List[%d] = %d",
+				i, scan_ch_list[i]);
+		}
+
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Requested num of scan channel %d\n",
+			   request->n_channels);
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Scan Request IE len =  %d\n",
+			   request->ie_len);
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Number of SSIDs %d\n",
+			   request->n_ssids);
+		if (request->n_ssids >= 1) {
+			if (wilc_wfi_cfg_alloc_fill_ssid(vif, request,
+							 &hidden_ntwk))
+				return -ENOMEM;
+
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+				   "Trigger Scan Request\n");
+			ret = wilc_scan(vif, USER_SCAN, ACTIVE_SCAN,
+					scan_ch_list,
+					request->n_channels,
+					(const u8 *)request->ie,
+					request->ie_len, cfg_scan_result,
+					(void *)priv, &hidden_ntwk);
+		} else {
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+				   "Trigger Scan Request\n");
+			ret = wilc_scan(vif, USER_SCAN, ACTIVE_SCAN,
+					scan_ch_list,
+					request->n_channels,
+					(const u8 *)request->ie,
+					request->ie_len, cfg_scan_result,
+					(void *)priv, NULL);
+		}
+	} else {
+		PRINT_ER(priv->dev, "Requested scanned channels over\n");
+	}
+
+	if (ret != 0) {
+		ret = -EBUSY;
+		PRINT_WRN(vif->ndev, CFG80211_DBG,
+			  "Device is busy: Error(%d)\n", ret);
+	}
+
+	return ret;
+}
+
+static int connect(struct wiphy *wiphy, struct net_device *dev,
+		   struct cfg80211_connect_params *sme)
+{
+	s32 ret = 0;
+	u32 i;
+	u32 sel_bssi_idx = UINT_MAX;
+	u8 u8security = NO_ENCRYPT;
+	enum AUTHTYPE auth_type = ANY;
+
+	struct wilc_priv *priv;
+	struct host_if_drv *wfi_drv;
+	struct network_info *nw_info = NULL;
+	struct wilc_vif *vif;
+
+	wilc_connecting = 1;
+	priv = wiphy_priv(wiphy);
+	vif = netdev_priv(priv->dev);
+	wfi_drv = (struct host_if_drv *)priv->hif_drv;
+
+	PRINT_INFO(vif->ndev, CFG80211_DBG,
+		   "Connecting to SSID [%s] on netdev [%p] host if [%x]\n",
+		   sme->ssid,dev, (u32)priv->hif_drv);
+	if (!(strncmp(sme->ssid, "DIRECT-", 7))) {
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Connected to Direct network,OBSS disabled\n");
+		wfi_drv->p2p_connect = 1;
+	} else {
+		wfi_drv->p2p_connect = 0;
+	}
+	PRINT_D(vif->ndev, CFG80211_DBG, "Required SSID= %s\n, AuthType= %d\n",
+		sme->ssid, sme->auth_type);
+
+	for (i = 0; i < last_scanned_cnt; i++) {
+		if (sme->ssid_len == last_scanned_shadow[i].ssid_len &&
+		    memcmp(last_scanned_shadow[i].ssid,
+			   sme->ssid,
+			   sme->ssid_len) == 0) {
+			PRINT_D(vif->ndev, CFG80211_DBG,
+				"Network with required SSID is found %s\n",
+				sme->ssid);
+			if (!sme->bssid) {
+				PRINT_D(vif->ndev, CFG80211_DBG,
+					"BSSID is not passed from the user\n");
+				if (sel_bssi_idx == UINT_MAX ||
+				    last_scanned_shadow[i].rssi >
+				    last_scanned_shadow[sel_bssi_idx].rssi)
+					sel_bssi_idx = i;
+			} else {
+				if (memcmp(last_scanned_shadow[i].bssid,
+					   sme->bssid,
+					   ETH_ALEN) == 0) {
+					PRINT_D(vif->ndev, CFG80211_DBG,
+						"BSSID is passed from the user and matched\n");
+					sel_bssi_idx = i;
+					break;
+				}
+			}
+		}
+	}
+
+	if (sel_bssi_idx < last_scanned_cnt) {
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Required bss is in scan results\n");
+		nw_info = &last_scanned_shadow[sel_bssi_idx];
+		PRINT_D(vif->ndev, CFG80211_DBG,
+			"network BSSID to be associated: %x%x%x%x%x%x\n",
+			nw_info->bssid[0], nw_info->bssid[1],
+			nw_info->bssid[2], nw_info->bssid[3],
+			nw_info->bssid[4], nw_info->bssid[5]);
+	} else {
+		ret = -ENOENT;
+		wilc_connecting = 0;
+		if (last_scanned_cnt == 0)
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+				   "No Scan results yet\n");
+		else
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+				   "Required bss not in scan results: Error(%d)\n",
+				   ret);
+		return ret;
+	}
+
+	memset(priv->wep_key, 0, sizeof(priv->wep_key));
+	memset(priv->wep_key_len, 0, sizeof(priv->wep_key_len));
+
+	PRINT_D(vif->ndev, CFG80211_DBG, "sme->crypto.wpa_versions=%x\n",
+		sme->crypto.wpa_versions);
+	PRINT_D(vif->ndev, CFG80211_DBG, "sme->crypto.cipher_group=%x\n",
+		sme->crypto.cipher_group);
+	PRINT_D(vif->ndev, CFG80211_DBG, "sme->crypto.n_ciphers_pairwise=%d\n",
+		sme->crypto.n_ciphers_pairwise);
+	for (i = 0; i < sme->crypto.n_ciphers_pairwise; i++)
+		PRINT_D(vif->ndev, CORECONFIG_DBG,
+			"sme->crypto.ciphers_pairwise[%d]=%x\n", i,
+			sme->crypto.ciphers_pairwise[i]);
+
+	if (sme->crypto.cipher_group != NO_ENCRYPT) {
+		PRINT_INFO(vif->ndev, CORECONFIG_DBG,
+			   ">> sme->crypto.wpa_versions: %x\n",
+			   sme->crypto.wpa_versions);
+		if (sme->crypto.cipher_group == WLAN_CIPHER_SUITE_WEP40) {
+			u8security = ENCRYPT_ENABLED | WEP;
+			PRINT_D(vif->ndev, CFG80211_DBG,
+				"WEP Default Key Idx = %d\n", sme->key_idx);
+
+			for (i = 0; i < sme->key_len; i++)
+				PRINT_D(vif->ndev, CORECONFIG_DBG,
+				"WEP Key Value[%d] = %d\n", i, sme->key[i]);
+		
+			priv->wep_key_len[sme->key_idx] = sme->key_len;
+			memcpy(priv->wep_key[sme->key_idx], sme->key, sme->key_len);
+
+			wilc_set_wep_default_keyid(vif, sme->key_idx);
+			wilc_add_wep_key_bss_sta(vif, sme->key, sme->key_len,
+						 sme->key_idx);
+		} else if (sme->crypto.cipher_group == WLAN_CIPHER_SUITE_WEP104)   {
+			u8security = ENCRYPT_ENABLED | WEP | WEP_EXTENDED;
+
+			priv->wep_key_len[sme->key_idx] = sme->key_len;
+			memcpy(priv->wep_key[sme->key_idx], sme->key, sme->key_len);
+
+			wilc_set_wep_default_keyid(vif, sme->key_idx);
+			wilc_add_wep_key_bss_sta(vif, sme->key, sme->key_len,
+						 sme->key_idx);
+		} else if (sme->crypto.wpa_versions & NL80211_WPA_VERSION_2)   {
+			if (sme->crypto.cipher_group == WLAN_CIPHER_SUITE_TKIP)
+				u8security = ENCRYPT_ENABLED | WPA2 | TKIP;
+			else
+				u8security = ENCRYPT_ENABLED | WPA2 | AES;
+		} else if (sme->crypto.wpa_versions & NL80211_WPA_VERSION_1)   {
+			if (sme->crypto.cipher_group == WLAN_CIPHER_SUITE_TKIP)
+				u8security = ENCRYPT_ENABLED | WPA | TKIP;
+			else
+				u8security = ENCRYPT_ENABLED | WPA | AES;
+		} else {
+			ret = -ENOTSUPP;
+			PRINT_ER(dev, "Not supported cipher\n");
+			wilc_connecting = 0;
+			return ret;
+		}
+	}
+
+	if ((sme->crypto.wpa_versions & NL80211_WPA_VERSION_1) ||
+	    (sme->crypto.wpa_versions & NL80211_WPA_VERSION_2)) {
+		for (i = 0; i < sme->crypto.n_ciphers_pairwise; i++) {
+			if (sme->crypto.ciphers_pairwise[i] == WLAN_CIPHER_SUITE_TKIP)
+				u8security = u8security | TKIP;
+			else
+				u8security = u8security | AES;
+		}
+	}
+
+	PRINT_INFO(vif->ndev, CFG80211_DBG,"Adding key with cipher group %x\n",
+		   sme->crypto.cipher_group);
+
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "Authentication Type = %d\n",
+		   sme->auth_type);
+	switch (sme->auth_type)	{
+	case NL80211_AUTHTYPE_OPEN_SYSTEM:
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "In OPEN SYSTEM\n");
+		auth_type = OPEN_SYSTEM;
+		break;
+
+	case NL80211_AUTHTYPE_SHARED_KEY:
+		auth_type = SHARED_KEY;
+   		PRINT_INFO(vif->ndev, CFG80211_DBG, "In SHARED KEY\n");
+		break;
+
+	default:
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Automatic Authentication type= %d\n",
+			   sme->auth_type);
+		break;
+	}
+
+	if (sme->crypto.n_akm_suites) {
+		if (sme->crypto.akm_suites[0] == WLAN_AKM_SUITE_8021X)
+			auth_type = IEEE8021;
+	}
+
+	PRINT_D(vif->ndev, CFG80211_DBG, "Required Channel = %d\n",
+		nw_info->ch);
+	curr_channel = nw_info->ch;
+
+	if (!wfi_drv->p2p_connect)
+		wlan_channel = nw_info->ch;
+
+	wilc_wlan_set_bssid(dev, nw_info->bssid, STATION_MODE);
+
+	ret = wilc_set_join_req(vif, nw_info->bssid, sme->ssid,
+				sme->ssid_len, sme->ie, sme->ie_len,
+				cfg_connect_result, (void *)priv,
+				u8security, auth_type,
+				nw_info->ch,
+				nw_info->join_params);
+	if (ret != 0) {
+		PRINT_ER(dev, "wilc_set_join_req(): Error(%d)\n", ret);
+		ret = -ENOENT;
+		wilc_connecting = 0;
+		return ret;
+	}
+
+	return ret;
+}
+
+static int disconnect(struct wiphy *wiphy, struct net_device *dev,
+		      u16 reason_code)
+{
+	s32 ret = 0;
+	struct wilc_priv *priv;
+	struct host_if_drv *wfi_drv;
+	struct wilc_vif *vif;
+	struct wilc *wilc;
+	u8 null_bssid[ETH_ALEN] = {0};
+
+	wilc_connecting = 0;
+	priv = wiphy_priv(wiphy);
+	vif = netdev_priv(priv->dev);
+	wilc = vif->wilc;
+
+	if (!wilc)
+		return -EIO;
+	wfi_drv = (struct host_if_drv *)priv->hif_drv;
+	if (!wfi_drv->p2p_connect)
+		wlan_channel = INVALID_CHANNEL;
+	wilc_wlan_set_bssid(priv->dev, null_bssid, STATION_MODE);
+
+	PRINT_INFO(vif->ndev, CFG80211_DBG,
+		   "Disconnecting with reason code(%d)\n", reason_code);
+	p2p_local_random = 0x01;
+	p2p_recv_random = 0x00;
+	wilc_ie = false;
+	wfi_drv->p2p_timeout = 0;
+
+	ret = wilc_disconnect(vif, reason_code);
+	if (ret != 0) {
+		PRINT_ER(priv->dev, "Error in disconnecting (%d)\n", ret);
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static inline void wilc_wfi_cfg_copy_wep_info(struct wilc_priv *priv,
+					      u8 key_index,
+					      struct key_params *params)
+{
+	priv->wep_key_len[key_index] = params->key_len;
+	memcpy(priv->wep_key[key_index], params->key, params->key_len);
+}
+
+static int wilc_wfi_cfg_allocate_wpa_entry(struct wilc_priv *priv, u8 idx)
+{
+	if (!priv->wilc_gtk[idx]) {
+		priv->wilc_gtk[idx] = kzalloc(sizeof(*priv->wilc_gtk[idx]),
+					      GFP_KERNEL);
+		if (!priv->wilc_gtk[idx])
+			return -ENOMEM;
+	}
+
+	if (!priv->wilc_ptk[idx]) {
+		priv->wilc_ptk[idx] = kzalloc(sizeof(*priv->wilc_ptk[idx]),
+					      GFP_KERNEL);
+		if (!priv->wilc_ptk[idx])
+			return -ENOMEM;
+	}
+
+	return 0;
+}
+
+static int wilc_wfi_cfg_copy_wpa_info(struct wilc_wfi_key *key_info,
+				      struct key_params *params)
+{
+	kfree(key_info->key);
+
+	key_info->key = kmemdup(params->key, params->key_len, GFP_KERNEL);
+	if (!key_info->key)
+		return -ENOMEM;
+
+	kfree(key_info->seq);
+
+	if (params->seq_len > 0) {
+		key_info->seq = kmemdup(params->seq, params->seq_len,
+					GFP_KERNEL);
+		if (!key_info->seq)
+			return -ENOMEM;
+	}
+
+	key_info->cipher = params->cipher;
+	key_info->key_len = params->key_len;
+	key_info->seq_len = params->seq_len;
+
+	return 0;
+}
+
+static int add_key(struct wiphy *wiphy, struct net_device *netdev, u8 key_index,
+		   bool pairwise,
+		   const u8 *mac_addr, struct key_params *params)
+
+{
+	s32 ret = 0, keylen = params->key_len;
+	struct wilc_priv *priv;
+	const u8 *rx_mic = NULL;
+	const u8 *tx_mic = NULL;
+	u8 mode = NO_ENCRYPT;
+	u8 op_mode;
+	struct wilc *wl;
+	struct wilc_vif *vif;
+	int i;
+
+	priv = wiphy_priv(wiphy);
+	vif = netdev_priv(netdev);
+	wl = vif->wilc;
+
+	PRINT_INFO(vif->ndev, CFG80211_DBG,
+		   "Adding key with cipher suite = %x\n", params->cipher);
+	PRINT_INFO(vif->ndev, CFG80211_DBG,"%x %x %d\n",(u32)wiphy,
+		   (u32)netdev, key_index);
+	PRINT_INFO(vif->ndev, CFG80211_DBG,"key %x %x %x\n",params->key[0],
+		   params->key[1],
+		   params->key[2]);
+	switch (params->cipher) {
+	case WLAN_CIPHER_SUITE_WEP40:
+	case WLAN_CIPHER_SUITE_WEP104:
+		if (priv->wdev->iftype == NL80211_IFTYPE_AP) {
+			wilc_wfi_cfg_copy_wep_info(priv, key_index, params);
+
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+				   "Adding AP WEP Default key Idx = %d\n",
+				   key_index);
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+				   "Adding AP WEP Key len= %d\n",
+				   params->key_len);
+
+			for (i = 0; i < params->key_len; i++)
+				PRINT_INFO(vif->ndev, CFG80211_DBG,
+					   "WEP AP key val[%d] = %x\n", i,
+					   params->key[i]);
+
+			if (params->cipher == WLAN_CIPHER_SUITE_WEP40)
+				mode = ENCRYPT_ENABLED | WEP;
+			else
+				mode = ENCRYPT_ENABLED | WEP | WEP_EXTENDED;
+
+			ret = wilc_add_wep_key_bss_ap(vif, params->key,
+						      params->key_len,
+						      key_index, mode,
+						      OPEN_SYSTEM);
+			break;
+		}
+		if (memcmp(params->key, priv->wep_key[key_index],
+			   params->key_len)) {
+			wilc_wfi_cfg_copy_wep_info(priv, key_index, params);
+
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+				   "Adding WEP Default key Idx = %d\n",
+				   key_index);
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+				   "Adding WEP Key length = %d\n",
+				   params->key_len);
+			ret = wilc_add_wep_key_bss_sta(vif, params->key,
+						       params->key_len,
+						       key_index);
+		}
+
+		break;
+
+	case WLAN_CIPHER_SUITE_TKIP:
+	case WLAN_CIPHER_SUITE_CCMP:
+		if (priv->wdev->iftype == NL80211_IFTYPE_AP ||
+		    priv->wdev->iftype == NL80211_IFTYPE_P2P_GO) {
+			ret = wilc_wfi_cfg_allocate_wpa_entry(priv, key_index);
+			if (ret)
+				return -ENOMEM;
+
+			if (params->key_len > 16 &&
+			    params->cipher == WLAN_CIPHER_SUITE_TKIP) {
+				tx_mic = params->key + 24;
+				rx_mic = params->key + 16;
+				keylen = params->key_len - 16;
+			}
+
+			if (!pairwise) {
+				if (params->cipher == WLAN_CIPHER_SUITE_TKIP)
+					mode = ENCRYPT_ENABLED | WPA | TKIP;
+				else
+					mode = ENCRYPT_ENABLED | WPA2 | AES;
+
+				priv->wilc_groupkey = mode;
+
+				ret = wilc_wfi_cfg_copy_wpa_info(priv->wilc_gtk[key_index],
+								 params);
+				if (ret)
+					return -ENOMEM;
+			} else {
+				PRINT_D(vif->ndev, CFG80211_DBG,
+					"STA Address: %x%x%x%x%x\n",
+					mac_addr[0], mac_addr[1], mac_addr[2],
+					mac_addr[3], mac_addr[4]);
+				if (params->cipher == WLAN_CIPHER_SUITE_TKIP)
+					mode = ENCRYPT_ENABLED | WPA | TKIP;
+				else
+					mode = priv->wilc_groupkey | AES;
+
+				ret = wilc_wfi_cfg_copy_wpa_info(priv->wilc_ptk[key_index],
+								 params);
+				if (ret)
+					return -ENOMEM;
+			}
+			op_mode = AP_MODE;
+		} else {
+			if (params->key_len > 16 &&
+			    params->cipher == WLAN_CIPHER_SUITE_TKIP) {
+				rx_mic = params->key + 24;
+				tx_mic = params->key + 16;
+				keylen = params->key_len - 16;
+			}
+
+			op_mode = STATION_MODE;
+		}
+
+		if (!pairwise)
+			ret = wilc_add_rx_gtk(vif, params->key, keylen,
+					      key_index, params->seq_len,
+					      params->seq, rx_mic, tx_mic,
+					      op_mode, mode);
+		else
+			ret = wilc_add_ptk(vif, params->key, keylen, mac_addr,
+					   rx_mic, tx_mic, op_mode, mode,
+					   key_index);
+
+		break;
+
+	default:
+		PRINT_ER(netdev, "Not supported cipher: Error(%d)\n", ret);
+		ret = -ENOTSUPP;
+	}
+
+	return ret;
+}
+
+static int del_key(struct wiphy *wiphy, struct net_device *netdev,
+		   u8 key_index,
+		   bool pairwise,
+		   const u8 *mac_addr)
+{
+	struct wilc_priv *priv;
+	struct wilc *wl;
+	struct wilc_vif *vif;
+	int ret = 0;
+
+	priv = wiphy_priv(wiphy);
+	vif = netdev_priv(netdev);
+	wl = vif->wilc;
+
+	if (netdev == wl->vif[0]->ndev) {
+		if (priv->wilc_gtk[key_index] != NULL) {
+			kfree(priv->wilc_gtk[key_index]->key);
+			priv->wilc_gtk[key_index]->key = NULL;
+			kfree(priv->wilc_gtk[key_index]->seq);
+			priv->wilc_gtk[key_index]->seq = NULL;
+
+			kfree(priv->wilc_gtk[key_index]);
+			priv->wilc_gtk[key_index] = NULL;
+		}
+
+		if (priv->wilc_ptk[key_index] != NULL) {
+			kfree(priv->wilc_ptk[key_index]->key);
+			priv->wilc_ptk[key_index]->key = NULL;
+			kfree(priv->wilc_ptk[key_index]->seq);
+			priv->wilc_ptk[key_index]->seq = NULL;
+			kfree(priv->wilc_ptk[key_index]);
+			priv->wilc_ptk[key_index] = NULL;
+		}
+	}
+
+	if (key_index >= 0 && key_index <= 3) {
+		if (priv->wep_key_len[key_index]) {
+			memset(priv->wep_key[key_index], 0,
+			       priv->wep_key_len[key_index]);
+			priv->wep_key_len[key_index] = 0;
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+				   "Removing WEP key with index = %d\n",
+				   key_index);
+			ret = wilc_remove_wep_key(vif, key_index);
+		}
+	} else {
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Removing all installed keys\n");
+		ret = wilc_remove_key(vif, mac_addr);
+	}
+
+	return ret;
+}
+
+static int get_key(struct wiphy *wiphy, struct net_device *netdev, u8 key_index,
+		   bool pairwise, const u8 *mac_addr, void *cookie,
+		   void (*callback)(void *cookie, struct key_params *))
+{
+	struct wilc_priv *priv;
+	struct  key_params key_params;
+	struct wilc_vif *vif;
+
+	priv = wiphy_priv(wiphy);
+	vif = netdev_priv(netdev);
+
+	if (!pairwise) {
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Getting group key idx: %x\n", key_index);
+		key_params.key = priv->wilc_gtk[key_index]->key;
+		key_params.cipher = priv->wilc_gtk[key_index]->cipher;
+		key_params.key_len = priv->wilc_gtk[key_index]->key_len;
+		key_params.seq = priv->wilc_gtk[key_index]->seq;
+		key_params.seq_len = priv->wilc_gtk[key_index]->seq_len;
+	} else {
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "Getting pairwise key\n");
+		key_params.key = priv->wilc_ptk[key_index]->key;
+		key_params.cipher = priv->wilc_ptk[key_index]->cipher;
+		key_params.key_len = priv->wilc_ptk[key_index]->key_len;
+		key_params.seq = priv->wilc_ptk[key_index]->seq;
+		key_params.seq_len = priv->wilc_ptk[key_index]->seq_len;
+	}
+
+	callback(cookie, &key_params);
+
+	return 0;
+}
+
+static int set_default_key(struct wiphy *wiphy, struct net_device *netdev,
+			   u8 key_index, bool unicast, bool multicast)
+{
+	struct wilc_priv *priv;
+	struct wilc_vif *vif;
+
+	priv = wiphy_priv(wiphy);
+	vif = netdev_priv(priv->dev);
+
+	wilc_set_wep_default_keyid(vif, key_index);
+
+	return 0;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,16,0)
+static int get_station(struct wiphy *wiphy, struct net_device *dev,
+		       const u8 *mac, struct station_info *sinfo)
+#else
+static int get_station(struct wiphy *wiphy, struct net_device *dev,
+		       u8 *mac, struct station_info *sinfo)
+#endif
+{
+	struct wilc_priv *priv;
+	struct wilc_vif *vif;
+	struct wilc *wilc;
+	u32 i = 0;
+	u32 associatedsta = ~0;
+	u32 inactive_time = 0;
+
+	priv = wiphy_priv(wiphy);
+	vif = netdev_priv(dev);
+	wilc = vif->wilc;
+
+	if (vif->iftype == AP_MODE || vif->iftype == GO_MODE) {
+		PRINT_INFO(vif->ndev, HOSTAPD_DBG,
+			   "Getting station parameters\n");
+		for (i = 0; i < NUM_STA_ASSOCIATED; i++) {
+			if (!(memcmp(mac, priv->assoc_stainfo.sta_associated_bss[i], ETH_ALEN))) {
+				associatedsta = i;
+				break;
+			}
+		}
+
+		if (associatedsta == ~0) {
+			PRINT_ER(dev, "sta required is not associated\n");
+			return -ENOENT;
+		}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 19, 0)
+		sinfo->filled |= BIT(NL80211_STA_INFO_INACTIVE_TIME);
+#else
+		sinfo->filled |= STATION_INFO_INACTIVE_TIME;
+#endif
+
+		wilc_get_inactive_time(vif, mac, &inactive_time);
+		sinfo->inactive_time = 1000 * inactive_time;
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "Inactive time %d\n",
+			   sinfo->inactive_time);
+	}
+
+	if (vif->iftype == STATION_MODE) {
+		struct rf_info stats;
+		if (!wilc->initialized) {
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+				   "driver not initialized\n");
+			return -EBUSY;
+		}
+		wilc_get_statistics(vif, &stats);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 19, 0)
+		sinfo->filled |= BIT(NL80211_STA_INFO_SIGNAL) |
+			      BIT(NL80211_STA_INFO_RX_PACKETS) |
+			      BIT(NL80211_STA_INFO_TX_PACKETS) |
+			      BIT(NL80211_STA_INFO_TX_FAILED) |
+			      BIT(NL80211_STA_INFO_TX_BITRATE);
+#else
+		sinfo->filled |= STATION_INFO_SIGNAL |
+			      STATION_INFO_RX_PACKETS |
+			      STATION_INFO_TX_PACKETS |
+			      STATION_INFO_TX_FAILED |
+			      STATION_INFO_TX_BITRATE;
+#endif
+		sinfo->signal = stats.rssi;
+		sinfo->rx_packets = stats.rx_cnt;
+		sinfo->tx_packets = stats.tx_cnt + stats.tx_fail_cnt;
+		sinfo->tx_failed = stats.tx_fail_cnt;
+		sinfo->txrate.legacy = stats.link_speed * 10;
+
+		if (stats.link_speed > TCP_ACK_FILTER_LINK_SPEED_THRESH &&
+		    stats.link_speed != DEFAULT_LINK_SPEED)
+			wilc_enable_tcp_ack_filter(true);
+		else if (stats.link_speed != DEFAULT_LINK_SPEED)
+			wilc_enable_tcp_ack_filter(false);
+
+		PRINT_INFO(vif->ndev, CORECONFIG_DBG,
+			   "*** stats[%d][%d][%d][%d][%d]\n",sinfo->signal,
+			   sinfo->rx_packets,sinfo->tx_packets,
+			   sinfo->tx_failed, sinfo->txrate.legacy);
+	}
+	return 0;
+}
+
+static int change_bss(struct wiphy *wiphy, struct net_device *dev,
+		      struct bss_parameters *params)
+{
+	PRINT_INFO(dev, CFG80211_DBG, "Changing Bss parametrs\n");
+	return 0;
+}
+
+static int set_wiphy_params(struct wiphy *wiphy, u32 changed)
+{
+	s32 ret = 0;
+	struct cfg_param_attr cfg_param_val;
+	struct wilc_priv *priv;
+	struct wilc_vif *vif;
+
+	priv = wiphy_priv(wiphy);
+	vif = netdev_priv(priv->dev);
+
+	cfg_param_val.flag = 0;
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "Setting Wiphy params\n");
+
+	if (changed & WIPHY_PARAM_RETRY_SHORT) {
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Setting WIPHY_PARAM_RETRY_SHORT %d\n",
+			   wiphy->retry_short);
+		cfg_param_val.flag  |= RETRY_SHORT;
+		cfg_param_val.short_retry_limit = wiphy->retry_short;
+	}
+	if (changed & WIPHY_PARAM_RETRY_LONG) {
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Setting WIPHY_PARAM_RETRY_LONG %d\n",
+			   wiphy->retry_long);
+		cfg_param_val.flag |= RETRY_LONG;
+		cfg_param_val.long_retry_limit = wiphy->retry_long;
+	}
+	if (changed & WIPHY_PARAM_FRAG_THRESHOLD) {
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Setting WIPHY_PARAM_FRAG_THRESHOLD %d\n",
+			   wiphy->frag_threshold);
+		cfg_param_val.flag |= FRAG_THRESHOLD;
+		cfg_param_val.frag_threshold = wiphy->frag_threshold;
+	}
+
+	if (changed & WIPHY_PARAM_RTS_THRESHOLD) {
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Setting WIPHY_PARAM_RTS_THRESHOLD %d\n",
+			   wiphy->rts_threshold);
+		cfg_param_val.flag |= RTS_THRESHOLD;
+		cfg_param_val.rts_threshold = wiphy->rts_threshold;
+	}
+
+	PRINT_INFO(vif->ndev, CFG80211_DBG,
+		   "Setting CFG params in the host interface\n");
+	ret = wilc_hif_set_cfg(vif, &cfg_param_val);
+	if (ret)
+		PRINT_ER(priv->dev, "Error in setting WIPHY PARAMS\n");
+
+	return ret;
+}
+
+static int set_pmksa(struct wiphy *wiphy, struct net_device *netdev,
+		     struct cfg80211_pmksa *pmksa)
+{
+	u32 i;
+	s32 ret = 0;
+	u8 flag = 0;
+	struct wilc_vif *vif;
+	struct wilc_priv *priv = wiphy_priv(wiphy);
+
+	vif = netdev_priv(priv->dev);
+	
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "Setting PMKSA\n");
+
+	for (i = 0; i < priv->pmkid_list.numpmkid; i++)	{
+		if (!memcmp(pmksa->bssid, priv->pmkid_list.pmkidlist[i].bssid,
+			    ETH_ALEN)) {
+			flag = PMKID_FOUND;
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+				   "PMKID already exists\n");
+			break;
+		}
+	}
+	if (i < WILC_MAX_NUM_PMKIDS) {
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Setting PMKID in private structure\n");
+		memcpy(priv->pmkid_list.pmkidlist[i].bssid, pmksa->bssid,
+		       ETH_ALEN);
+		memcpy(priv->pmkid_list.pmkidlist[i].pmkid, pmksa->pmkid,
+		       PMKID_LEN);
+		if (!(flag == PMKID_FOUND))
+			priv->pmkid_list.numpmkid++;
+	} else {
+		PRINT_ER(netdev, "Invalid PMKID index\n");
+		ret = -EINVAL;
+	}
+
+	if (!ret) {
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Setting pmkid in the host interface\n");
+		ret = wilc_set_pmkid_info(vif, &priv->pmkid_list);
+	}
+	return ret;
+}
+
+static int del_pmksa(struct wiphy *wiphy, struct net_device *netdev,
+		     struct cfg80211_pmksa *pmksa)
+{
+	u32 i;
+	s32 ret = 0;
+
+	struct wilc_priv *priv = wiphy_priv(wiphy);
+
+	PRINT_INFO(netdev, CFG80211_DBG, "Deleting PMKSA keys\n");
+
+	for (i = 0; i < priv->pmkid_list.numpmkid; i++)	{
+		if (!memcmp(pmksa->bssid, priv->pmkid_list.pmkidlist[i].bssid,
+			    ETH_ALEN)) {
+			PRINT_INFO(netdev, CFG80211_DBG,
+				   "Reseting PMKID values\n");
+			memset(&priv->pmkid_list.pmkidlist[i], 0,
+			       sizeof(struct host_if_pmkid));
+			break;
+		}
+	}
+
+	if (i < priv->pmkid_list.numpmkid && priv->pmkid_list.numpmkid > 0) {
+		for (; i < (priv->pmkid_list.numpmkid - 1); i++) {
+			memcpy(priv->pmkid_list.pmkidlist[i].bssid,
+			       priv->pmkid_list.pmkidlist[i + 1].bssid,
+			       ETH_ALEN);
+			memcpy(priv->pmkid_list.pmkidlist[i].pmkid,
+			       priv->pmkid_list.pmkidlist[i + 1].pmkid,
+			       PMKID_LEN);
+		}
+		priv->pmkid_list.numpmkid--;
+	} else {
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static int flush_pmksa(struct wiphy *wiphy, struct net_device *netdev)
+{
+	struct wilc_priv *priv = wiphy_priv(wiphy);
+
+	PRINT_INFO(netdev, CFG80211_DBG, "Flushing  PMKID key values\n");
+	memset(&priv->pmkid_list, 0, sizeof(struct host_if_pmkid_attr));
+
+	return 0;
+}
+
+static inline void wilc_wfi_cfg_parse_ch_attr(struct wilc_vif *vif, u8 *buf,
+					      u8 ch_list_attr_idx,
+					      u8 op_ch_attr_idx)
+{
+	int i = 0;
+	int j = 0;
+
+	if (ch_list_attr_idx) {
+		u8 limit = ch_list_attr_idx + 3 + buf[ch_list_attr_idx + 1];
+
+		PRINT_INFO(vif->ndev, GENERIC_DBG,
+			   "Modify channel list attribute\n");
+		for (i = ch_list_attr_idx + 3; i < limit; i++) {
+			if (buf[i] == 0x51) {
+				for (j = i + 2; j < ((i + 2) + buf[i + 1]); j++)
+					buf[j] = wlan_channel;
+				break;
+			}
+		}
+	}
+
+	if (op_ch_attr_idx) {
+		PRINT_INFO(vif->ndev, GENERIC_DBG,
+			   "Modify operating channel attribute\n");
+		buf[op_ch_attr_idx + 6] = 0x51;
+		buf[op_ch_attr_idx + 7] = wlan_channel;
+	}
+}
+
+static void wilc_wfi_cfg_parse_rx_action(struct wilc_vif *vif, u8 * buf,
+					 u32 len, bool p2p_mode)
+{
+	u32 index = 0;
+
+	u8 op_channel_attr_index = 0;
+	u8 channel_list_attr_index = 0;
+
+	while (index < len) {
+		if (buf[index] == GO_INTENT_ATTR_ID) {
+			if(!p2p_mode)
+				buf[index + 3] = (buf[index + 3]  & 0x01) | (0x0f << 1);
+			else
+				buf[index + 3] = (buf[index + 3]  & 0x01) | (0x00 << 1);
+		}
+		if (buf[index] ==  CHANLIST_ATTR_ID)
+			channel_list_attr_index = index;
+		else if (buf[index] ==  OPERCHAN_ATTR_ID)
+			op_channel_attr_index = index;
+		index += buf[index + 1] + 3;
+	}
+	if (wlan_channel != INVALID_CHANNEL)
+		wilc_wfi_cfg_parse_ch_attr(vif, buf, channel_list_attr_index,
+					   op_channel_attr_index);
+}
+
+static void wilc_wfi_cfg_parse_tx_action(struct wilc_vif *vif, u8 * buf,
+					 u32 len,bool oper_ch, u8 p2p_mode)
+{
+	u32 index = 0;
+
+	u8 op_channel_attr_index = 0;
+	u8 channel_list_attr_index = 0;
+
+	while (index < len) {
+		if (buf[index] == GO_INTENT_ATTR_ID) {
+			if(!p2p_mode)
+				buf[index + 3] = (buf[index + 3]  & 0x01) | (0x00 << 1);
+			else
+				buf[index + 3] = (buf[index + 3]  & 0x01) | (0x0f << 1);
+			break;
+		}
+
+		if (buf[index] ==  CHANLIST_ATTR_ID)
+			channel_list_attr_index = index;
+		else if (buf[index] ==  OPERCHAN_ATTR_ID)
+			op_channel_attr_index = index;
+		index += buf[index + 1] + 3;
+	}
+	if (wlan_channel != INVALID_CHANNEL && oper_ch)
+		wilc_wfi_cfg_parse_ch_attr(vif, buf, channel_list_attr_index,
+					   op_channel_attr_index);
+}
+
+static void wilc_wfi_cfg_parse_rx_vendor_spec(struct wilc_priv *priv, u8 *buff,
+					      u32 size)
+{
+	int i;
+	u8 subtype;
+	struct wilc_vif *vif = netdev_priv(priv->dev);
+
+	subtype = buff[P2P_PUB_ACTION_SUBTYPE];
+	if ((subtype == GO_NEG_REQ || subtype == GO_NEG_RSP) && !wilc_ie) {
+		for (i = P2P_PUB_ACTION_SUBTYPE; i < size; i++) {
+			if (!memcmp(p2p_vendor_spec, &buff[i], 6)) {
+				p2p_recv_random = buff[i + 6];
+				wilc_ie = true;
+				PRINT_INFO(vif->ndev, GENERIC_DBG,
+					   "WILC Vendor specific IE:%02x\n",
+					   p2p_recv_random);
+				break;
+			}
+		}
+	}
+
+	if (p2p_local_random <= p2p_recv_random) {
+		PRINT_INFO(vif->ndev, GENERIC_DBG,
+			   "PEER WILL BE GO LocaRand=%02x RecvRand %02x\n",
+			   p2p_local_random, p2p_recv_random);
+		return;
+	}
+
+	if (subtype == GO_NEG_REQ || subtype == GO_NEG_RSP ||
+	    subtype == P2P_INV_REQ || subtype == P2P_INV_RSP) {
+		for (i = P2P_PUB_ACTION_SUBTYPE + 2; i < size; i++) {
+			if (buff[i] == P2PELEM_ATTR_ID &&
+			    !(memcmp(p2p_oui, &buff[i + 2], 4))) {
+			    	bool p2p_mode = vif->attr_sysfs.p2p_mode;
+				wilc_wfi_cfg_parse_rx_action(vif, &buff[i + 6],
+							     size - (i + 6),
+							     p2p_mode);
+				break;
+			}
+		}
+	}
+}
+
+void wilc_wfi_p2p_rx(struct net_device *dev, u8 *buff, u32 size)
+{
+	struct wilc_priv *priv;
+	struct wilc_vif *vif;
+	u32 header, pkt_offset;
+	struct host_if_drv *wfi_drv;
+	s32 s32Freq;
+
+	vif = netdev_priv(dev);
+	priv = wiphy_priv(dev->ieee80211_ptr->wiphy);
+	wfi_drv = (struct host_if_drv *)priv->hif_drv;
+
+	memcpy(&header, (buff - HOST_HDR_OFFSET), HOST_HDR_OFFSET);
+
+	pkt_offset = GET_PKT_OFFSET(header);
+
+	if (pkt_offset & IS_MANAGMEMENT_CALLBACK) {
+		bool ack = false;
+
+		if (buff[FRAME_TYPE_ID] == IEEE80211_STYPE_PROBE_RESP ||
+		    pkt_offset & IS_MGMT_STATUS_SUCCES)
+			ack = true;
+
+		cfg80211_mgmt_tx_status(priv->wdev, priv->tx_cookie, buff, size,
+					ack, GFP_KERNEL);
+		return;
+	}
+
+	PRINT_D(vif->ndev, GENERIC_DBG, "Rx Frame Type:%x\n",
+		   buff[FRAME_TYPE_ID]);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,7,0)
+	s32Freq = ieee80211_channel_to_frequency(curr_channel, NL80211_BAND_2GHZ);
+ #else
+	s32Freq = ieee80211_channel_to_frequency(curr_channel, IEEE80211_BAND_2GHZ);
+ #endif
+	if (!ieee80211_is_action(buff[FRAME_TYPE_ID])) {
+		cfg80211_rx_mgmt(priv->wdev, s32Freq, 0, buff, size, 0);
+		return;
+	}
+
+	PRINT_D(vif->ndev, GENERIC_DBG,
+		   "Rx Action Frame Type: %x %x\n",
+		   buff[ACTION_SUBTYPE_ID],
+		   buff[P2P_PUB_ACTION_SUBTYPE]);
+	if (priv->cfg_scanning &&
+	    time_after_eq(jiffies, (unsigned long)wfi_drv->p2p_timeout)) {
+		PRINT_WRN(dev, GENERIC_DBG, "Receiving action wrong ch\n");
+		return;
+	}
+	if (buff[ACTION_CAT_ID] == PUB_ACTION_ATTR_ID) {
+		u8 subtype = buff[P2P_PUB_ACTION_SUBTYPE];
+
+		switch (buff[ACTION_SUBTYPE_ID]) {
+		case GAS_INITIAL_REQ:
+			PRINT_D(vif->ndev, GENERIC_DBG, 
+				   "GAS INITIAL REQ %x\n",
+				   buff[ACTION_SUBTYPE_ID]);
+			break;
+
+		case GAS_INITIAL_RSP:
+			PRINT_D(vif->ndev, GENERIC_DBG,
+				   "GAS INITIAL RSP %x\n",
+				   buff[ACTION_SUBTYPE_ID]);
+			break;
+
+		case PUBLIC_ACT_VENDORSPEC:
+			if (!memcmp(p2p_oui, &buff[ACTION_SUBTYPE_ID + 1], 4))
+				wilc_wfi_cfg_parse_rx_vendor_spec(priv, buff,
+								  size);
+
+			if ((subtype == GO_NEG_REQ || subtype == GO_NEG_RSP) &&
+			    wilc_ie)
+				size -= 7;
+
+			break;
+
+		default:
+			PRINT_WRN(dev, GENERIC_DBG, 
+				   "NOT HANDLED PUBLIC ACTION FRAME TYPE:%x\n",
+				   buff[ACTION_SUBTYPE_ID]);
+			break;
+		}
+	}
+
+	cfg80211_rx_mgmt(priv->wdev, s32Freq, 0, buff, size, 0);
+}
+
+static void wilc_wfi_mgmt_tx_complete(void *priv, int status)
+{
+	struct p2p_mgmt_data *pv_data = priv;
+
+	kfree(pv_data->buff);
+	kfree(pv_data);
+}
+
+static void wilc_wfi_remain_on_channel_ready(void *priv_data)
+{
+	struct wilc_priv *priv;
+
+	priv = priv_data;
+
+	PRINT_INFO(priv->dev, HOSTINF_DBG, "Remain on channel ready\n");
+	priv->p2p_listen_state = true;
+
+	cfg80211_ready_on_channel(priv->wdev,
+				  priv->remain_on_ch_params.listen_cookie,
+				  priv->remain_on_ch_params.listen_ch,
+				  priv->remain_on_ch_params.listen_duration,
+				  GFP_KERNEL);
+}
+
+static void wilc_wfi_remain_on_channel_expired(void *data, u32 session_id)
+{
+	struct wilc_priv *priv;
+
+	priv = data;
+
+	if (session_id == priv->remain_on_ch_params.listen_session_id) {
+		PRINT_INFO(priv->dev, GENERIC_DBG,
+			   "Remain on channel expired\n");
+		priv->p2p_listen_state = false;
+
+		cfg80211_remain_on_channel_expired(priv->wdev,
+						   priv->remain_on_ch_params.listen_cookie,
+						   priv->remain_on_ch_params.listen_ch,
+						   GFP_KERNEL);
+	} else {
+		PRINT_INFO(priv->dev, GENERIC_DBG,
+			   "Received ID 0x%x Expected ID 0x%x (No match)\n",
+			   session_id,
+			   priv->remain_on_ch_params.listen_session_id);
+	}
+}
+
+static int remain_on_channel(struct wiphy *wiphy,
+			     struct wireless_dev *wdev,
+			     struct ieee80211_channel *chan,
+			     unsigned int duration, u64 *cookie)
+{
+	s32 ret = 0;
+	struct wilc_priv *priv;
+	struct wilc_vif *vif;
+
+	priv = wiphy_priv(wiphy);
+	vif = netdev_priv(priv->dev);
+	PRINT_INFO(vif->ndev, GENERIC_DBG, "Remaining on channel %d\n", chan->hw_value);
+
+	if (wdev->iftype == NL80211_IFTYPE_AP) {
+		PRINT_INFO(vif->ndev, GENERIC_DBG, "Required while in AP mode\n");
+		return ret;
+	}
+
+	curr_channel = chan->hw_value;
+
+	priv->remain_on_ch_params.listen_ch = chan;
+	priv->remain_on_ch_params.listen_cookie = *cookie;
+	priv->remain_on_ch_params.listen_duration = duration;
+	priv->remain_on_ch_params.listen_session_id++;
+
+	return wilc_remain_on_channel(vif,
+				priv->remain_on_ch_params.listen_session_id,
+				duration, chan->hw_value,
+				wilc_wfi_remain_on_channel_expired,
+				wilc_wfi_remain_on_channel_ready, (void *)priv);
+}
+
+static int cancel_remain_on_channel(struct wiphy *wiphy,
+				    struct wireless_dev *wdev,
+				    u64 cookie)
+{
+	struct wilc_priv *priv;
+	struct wilc_vif *vif;
+
+	priv = wiphy_priv(wiphy);
+	vif = netdev_priv(priv->dev);
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "Cancel remain on channel\n");
+
+	return wilc_listen_state_expired(vif,
+			priv->remain_on_ch_params.listen_session_id);
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,14,0)
+static void wilc_wfi_cfg_tx_vendor_spec(struct wilc_vif *vif,
+					struct p2p_mgmt_data *mgmt_tx,
+					struct cfg80211_mgmt_tx_params *params,
+					u8 iftype, u32 buf_len)
+#else
+static void wilc_wfi_cfg_tx_vendor_spec(struct wilc_vif *vif,
+					struct p2p_mgmt_data *mgmt_tx,
+					const u8 *buf, size_t len,
+					u8 iftype, u32 buf_len)
+#endif
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,14,0)
+	const u8 *buf = params->buf;
+	size_t len = params->len;
+#endif
+	u32 i;
+	u8 subtype = buf[P2P_PUB_ACTION_SUBTYPE];
+
+	if (subtype == GO_NEG_REQ || subtype == GO_NEG_RSP) {
+		if (p2p_local_random == 1 &&
+		    p2p_recv_random < p2p_local_random) {
+			get_random_bytes(&p2p_local_random, 1);
+			p2p_local_random++;
+		}
+	}
+
+	if (p2p_local_random <= p2p_recv_random || !(subtype == GO_NEG_REQ ||
+						     subtype == GO_NEG_RSP ||
+						     subtype == P2P_INV_REQ ||
+						     subtype == P2P_INV_RSP))
+		return;
+
+	PRINT_INFO(vif->ndev, GENERIC_DBG, 
+		   "LOCAL WILL BE GO LocaRand=%02x RecvRand %02x\n",
+		   p2p_local_random, p2p_recv_random);
+	for (i = P2P_PUB_ACTION_SUBTYPE + 2; i < len; i++) {
+		if (buf[i] == P2PELEM_ATTR_ID &&
+		    !memcmp(p2p_oui, &buf[i + 2], 4)) {
+			if (subtype == P2P_INV_REQ || subtype == P2P_INV_RSP)
+				wilc_wfi_cfg_parse_tx_action(vif,
+							     &mgmt_tx->buff[i + 6],
+							     len - (i + 6),
+							     true,
+							     vif->attr_sysfs.p2p_mode);
+			else
+				wilc_wfi_cfg_parse_tx_action(vif,
+							     &mgmt_tx->buff[i + 6],
+							     len - (i + 6),
+							     false,
+							     vif->attr_sysfs.p2p_mode);
+			break;
+		}
+	}
+
+	if (subtype != P2P_INV_REQ && subtype != P2P_INV_RSP) {
+		int vendor_spec_len = sizeof(p2p_vendor_spec);
+
+		memcpy(&mgmt_tx->buff[len], p2p_vendor_spec,
+		       vendor_spec_len);
+		mgmt_tx->buff[len + vendor_spec_len] = p2p_local_random;
+		mgmt_tx->size = buf_len;
+	}
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,14,0)
+static int mgmt_tx(struct wiphy *wiphy,
+		   struct wireless_dev *wdev,
+		   struct cfg80211_mgmt_tx_params *params,
+		   u64 *cookie)
+#else
+static int mgmt_tx(struct wiphy *wiphy,
+		   struct wireless_dev *wdev,
+		   struct ieee80211_channel *chan, bool offchan,
+		   unsigned int wait, const u8 *buf, size_t len,
+		   bool no_cck, bool dont_wait_for_ack, u64 *cookie)
+#endif
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,14,0)
+	struct ieee80211_channel *chan = params->chan;
+	unsigned int wait = params->wait;
+	const u8 *buf = params->buf;
+	size_t len = params->len;
+#endif
+	const struct ieee80211_mgmt *mgmt;
+	struct p2p_mgmt_data *mgmt_tx;
+	struct wilc_priv *priv;
+	struct host_if_drv *wfi_drv;
+	struct wilc_vif *vif;
+	u32 buf_len = len + sizeof(p2p_vendor_spec) + sizeof(p2p_local_random);
+	int ret = 0;
+
+	vif = netdev_priv(wdev->netdev);
+	priv = wiphy_priv(wiphy);
+	wfi_drv = (struct host_if_drv *)priv->hif_drv;
+
+	*cookie = (unsigned long)buf;
+	priv->tx_cookie = *cookie;
+	mgmt = (const struct ieee80211_mgmt *)buf;
+
+	if (!ieee80211_is_mgmt(mgmt->frame_control)) {
+		PRINT_INFO(vif->ndev, GENERIC_DBG,
+			   "This function transmits only management frames\n");
+		goto out;
+	}
+
+	mgmt_tx = kmalloc(sizeof(struct p2p_mgmt_data), GFP_KERNEL);
+	if (!mgmt_tx) {
+		PRINT_ER(vif->ndev,
+			 "Failed to allocate memory for mgmt_tx structure\n");
+		return -ENOMEM;
+	}
+
+	mgmt_tx->buff = kmalloc(buf_len, GFP_KERNEL);
+	if (!mgmt_tx->buff) {
+		ret = -ENOMEM;
+		PRINT_ER(vif->ndev,
+			 "Failed to allocate memory for mgmt_tx buff\n");
+		kfree(mgmt_tx);
+		goto out;
+	}
+
+	memcpy(mgmt_tx->buff, buf, len);
+	mgmt_tx->size = len;
+
+	if (ieee80211_is_probe_resp(mgmt->frame_control)) {
+		PRINT_INFO(vif->ndev, GENERIC_DBG, "TX: Probe Response\n");
+		PRINT_INFO(vif->ndev, GENERIC_DBG, "Setting channel: %d\n",
+			   chan->hw_value);
+		wilc_set_mac_chnl_num(vif, chan->hw_value);
+		curr_channel = chan->hw_value;
+		goto out_txq_add_pkt;
+	}
+
+	if (!ieee80211_is_action(mgmt->frame_control))
+		goto out_txq_add_pkt;
+
+	PRINT_INFO(vif->ndev, GENERIC_DBG, "ACTION FRAME:%x\n",
+		   (u16)mgmt->frame_control);
+	if (buf[ACTION_CAT_ID] == PUB_ACTION_ATTR_ID) {
+		if (buf[ACTION_SUBTYPE_ID] != PUBLIC_ACT_VENDORSPEC ||
+		    buf[P2P_PUB_ACTION_SUBTYPE] != GO_NEG_CONF) {
+			PRINT_INFO(vif->ndev, GENERIC_DBG, 
+				   "Setting channel: %d\n",
+				   chan->hw_value);
+			wilc_set_mac_chnl_num(vif,
+					      chan->hw_value);
+			curr_channel = chan->hw_value;
+		}
+		switch (buf[ACTION_SUBTYPE_ID]) {
+		case GAS_INITIAL_REQ:
+			PRINT_INFO(vif->ndev, GENERIC_DBG,
+				   "GAS INITIAL REQ %x\n",
+				   buf[ACTION_SUBTYPE_ID]);
+			break;
+
+		case GAS_INITIAL_RSP:
+			PRINT_INFO(vif->ndev, GENERIC_DBG,
+				   "GAS INITIAL RSP %x\n",
+				   buf[ACTION_SUBTYPE_ID]);
+			break;
+
+		case PUBLIC_ACT_VENDORSPEC:
+			if (!memcmp(p2p_oui, &buf[ACTION_SUBTYPE_ID + 1], 4))
+			#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,14,0)
+				wilc_wfi_cfg_tx_vendor_spec(vif, mgmt_tx,
+							    params,
+							    vif->iftype,
+							    buf_len);
+			#else
+				wilc_wfi_cfg_tx_vendor_spec(vif, mgmt_tx, buf,
+							    len, vif->iftype,
+							    buf_len);
+			#endif
+			else
+				PRINT_INFO(vif->ndev, GENERIC_DBG, "Not a P2P public action frame\n");
+
+			break;
+
+		default:
+			PRINT_INFO(vif->ndev, GENERIC_DBG,
+				   "NOT HANDLED PUBLIC ACTION FRAME TYPE:%x\n",
+				   buf[ACTION_SUBTYPE_ID]);
+			break;
+		}
+	}
+
+	PRINT_INFO(vif->ndev, GENERIC_DBG,
+		   "TX: ACTION FRAME Type:%x : Chan:%d\n",
+		   buf[ACTION_SUBTYPE_ID], chan->hw_value);
+	wfi_drv->p2p_timeout = (jiffies + msecs_to_jiffies(wait));
+
+out_txq_add_pkt:
+
+	wilc_wlan_txq_add_mgmt_pkt(wdev->netdev, mgmt_tx,
+				   mgmt_tx->buff, mgmt_tx->size,
+				   wilc_wfi_mgmt_tx_complete);
+
+out:
+
+	return ret;
+}
+
+static int mgmt_tx_cancel_wait(struct wiphy *wiphy,
+			       struct wireless_dev *wdev,
+			       u64 cookie)
+{
+	struct wilc_priv *priv;
+	struct host_if_drv *wfi_drv;
+
+	priv = wiphy_priv(wiphy);
+	wfi_drv = (struct host_if_drv *)priv->hif_drv;
+	PRINT_INFO(priv->dev, CFG80211_DBG, "Tx Cancel wait :%lu\n", jiffies);
+	wfi_drv->p2p_timeout = jiffies;
+
+	if (!priv->p2p_listen_state) {
+		struct wilc_wfi_p2p_listen_params *params;
+
+		params = &priv->remain_on_ch_params;
+
+		cfg80211_remain_on_channel_expired(priv->wdev,
+						   params->listen_cookie,
+						   params->listen_ch,
+						   GFP_KERNEL);
+	}
+
+	return 0;
+}
+
+void wilc_mgmt_frame_register(struct wiphy *wiphy, struct wireless_dev *wdev,
+			      u16 frame_type, bool reg)
+{
+	struct wilc_priv *priv;
+	struct wilc_vif *vif;
+	struct wilc *wl;
+
+	priv = wiphy_priv(wiphy);
+	vif = netdev_priv(priv->wdev->netdev);
+	wl = vif->wilc;
+
+	if (!frame_type)
+		return;
+
+	PRINT_INFO(vif->ndev, GENERIC_DBG,
+		   "Frame registering Frame Type: %x: Boolean: %d\n",
+		   frame_type,reg);
+	switch (frame_type) {
+	case PROBE_REQ:
+	{
+		vif->frame_reg[0].type = frame_type;
+		vif->frame_reg[0].reg = reg;
+	}
+	break;
+
+	case ACTION:
+	{
+		vif->frame_reg[1].type = frame_type;
+		vif->frame_reg[1].reg = reg;
+	}
+	break;
+
+	default:
+	{
+		break;
+	}
+	}
+
+	if (!wl->initialized) {
+		PRINT_INFO(vif->ndev, GENERIC_DBG,
+			   "Return since mac is closed\n");
+		return;
+	}
+	wilc_frame_register(vif, frame_type, reg);
+}
+
+static int set_cqm_rssi_config(struct wiphy *wiphy, struct net_device *dev,
+			       s32 rssi_thold, u32 rssi_hyst)
+{
+	PRINT_INFO(dev, CFG80211_DBG, "Setting CQM RSSi Function\n");
+	return 0;
+}
+
+static int dump_station(struct wiphy *wiphy, struct net_device *dev,
+			int idx, u8 *mac, struct station_info *sinfo)
+{
+	struct wilc_priv *priv;
+	struct wilc_vif *vif;
+
+	if (idx != 0)
+		return -ENOENT;
+
+	priv = wiphy_priv(wiphy);
+	vif = netdev_priv(priv->dev);
+
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "Dumping station information\n");
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 19, 0))
+	sinfo->filled |= BIT(NL80211_STA_INFO_SIGNAL);
+#else
+	sinfo->filled |= STATION_INFO_SIGNAL;
+#endif
+
+	wilc_get_rssi(vif, &sinfo->signal);
+
+	return 0;
+}
+
+static int set_power_mgmt(struct wiphy *wiphy, struct net_device *dev,
+			  bool enabled, int timeout)
+{
+	struct wilc_priv *priv;
+	struct wilc_vif *vif;
+
+	if (!wiphy)
+		return -ENOENT;
+
+	priv = wiphy_priv(wiphy);
+	vif = netdev_priv(priv->dev);
+	if (!priv->hif_drv) {
+		PRINT_ER(dev, "Driver is NULL\n");
+		return -EIO;
+	}
+
+	/* Can't set PS during obtaining IP */
+	if (wilc_optaining_ip == true)
+	{
+		PRINT_ER(dev, "Device obtaining IP, Power Managment will be handled after IP Obtained\n");
+		PRINT_INFO(vif->ndev, GENERIC_DBG,
+			   "Save the Current state of the PS = %d\n", enabled);
+
+		/* Save the current status of the PS */
+		store_power_save_current_state(vif, enabled);
+			
+		return 0;
+	}
+
+	PRINT_INFO(vif->ndev, CFG80211_DBG, " Power save Enabled= %d , TimeOut = %d\n", enabled, timeout);
+
+	if (wilc_enable_ps)
+		wilc_set_power_mgmt(vif, enabled, timeout);
+
+	return 0;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,11,0)
+static int change_virtual_intf(struct wiphy *wiphy, struct net_device *dev,
+			       enum nl80211_iftype type,
+			       struct vif_params *params)
+#else
+static int change_virtual_intf(struct wiphy *wiphy, struct net_device *dev,
+			       enum nl80211_iftype type, u32 *flags, 
+			       struct vif_params *params)
+#endif
+{
+	struct wilc_priv *priv;
+	struct wilc_vif *vif;
+	struct wilc_vif *vif_1;
+	struct wilc_vif *vif_2;
+	struct wilc *wl;
+	struct net_device *net_device_1;
+	struct net_device *net_device_2;
+	struct wilc_priv* priv_1;
+	struct wilc_priv* priv_2;
+
+	vif = netdev_priv(dev);
+	priv = wiphy_priv(wiphy);
+	wl = vif->wilc;
+	net_device_1 = wilc_get_if_netdev(wl, P2P_IFC);
+	net_device_2 = wilc_get_if_netdev(wl, WLAN_IFC);
+	priv_1 = wdev_priv(net_device_1->ieee80211_ptr);
+	priv_2 = wdev_priv(net_device_2->ieee80211_ptr);
+	vif_1 = netdev_priv(net_device_1);
+	vif_2 = netdev_priv(net_device_2);
+	
+	PRINT_INFO(vif->ndev, HOSTAPD_DBG,
+		   "In Change virtual interface function\n");
+	PRINT_INFO(vif->ndev, HOSTAPD_DBG,
+		   "Wireless interface name =%s\n", dev->name);
+	p2p_local_random = 0x01;
+	p2p_recv_random = 0x00;
+	wilc_ie = false;
+#ifdef DISABLE_PWRSAVE_AND_SCAN_DURING_IP
+	PRINT_INFO(vif->ndev, GENERIC_DBG,
+		   "Changing virtual interface, enable scan\n");
+	handle_pwrsave_during_obtainingIP(vif, IP_STATE_DEFAULT);
+#endif
+
+	switch (type) {
+	case NL80211_IFTYPE_STATION:
+		wilc_connecting = 0;
+		PRINT_INFO(vif->ndev, HOSTAPD_DBG,
+			   "Interface type = NL80211_IFTYPE_STATION\n");
+		dev->ieee80211_ptr->iftype = type;
+		priv->wdev->iftype = type;
+		vif->monitor_flag = 0;
+		vif->iftype = STATION_MODE;
+		wilc_set_wfi_drv_handler(vif, wilc_get_vif_idx(vif),
+					 STATION_MODE, vif->ifc_id);
+		wilc_set_operation_mode(vif, STATION_MODE);
+
+		memset(priv->assoc_stainfo.sta_associated_bss, 0,
+		       MAX_NUM_STA * ETH_ALEN);
+
+		wilc_enable_ps = true;
+		wilc_set_power_mgmt(vif_1, 1, 0);
+		wilc_set_power_mgmt(vif_2, 1, 0);
+		break;
+
+	case NL80211_IFTYPE_P2P_CLIENT:
+		wilc_connecting = 0;
+		PRINT_INFO(vif->ndev, HOSTAPD_DBG,
+			   "Interface type = NL80211_IFTYPE_P2P_CLIENT\n");
+		dev->ieee80211_ptr->iftype = type;
+		priv->wdev->iftype = type;
+		vif->monitor_flag = 0;
+		vif->iftype = CLIENT_MODE;
+		wilc_enable_ps = false;
+		wilc_set_wfi_drv_handler(vif, wilc_get_vif_idx(vif),
+					 STATION_MODE, vif->ifc_id);
+		wilc_set_operation_mode(vif, STATION_MODE);
+
+		wilc_set_power_mgmt(vif_1, 0, 0);
+		wilc_set_power_mgmt(vif_2, 0, 0);
+		break;
+
+	case NL80211_IFTYPE_AP:
+		PRINT_INFO(vif->ndev, HOSTAPD_DBG,
+			   "Interface type = NL80211_IFTYPE_AP\n");
+		dev->ieee80211_ptr->iftype = type;
+		priv->wdev->iftype = type;
+		vif->iftype = AP_MODE;
+		wilc_enable_ps = false;
+		if (wl->initialized) {
+			wilc_set_wfi_drv_handler(vif, wilc_get_vif_idx(vif),
+						 AP_MODE, vif->ifc_id);
+			wilc_set_operation_mode(vif, AP_MODE);
+			wilc_set_power_mgmt(vif_1, 0, 0);
+			wilc_set_power_mgmt(vif_2, 0, 0);
+		}
+		break;
+
+	case NL80211_IFTYPE_P2P_GO:
+		PRINT_INFO(vif->ndev, HOSTAPD_DBG,
+			   "Interface type = NL80211_IFTYPE_GO\n");
+		PRINT_INFO(vif->ndev, GENERIC_DBG, "start duringIP timer\n");
+
+#ifdef DISABLE_PWRSAVE_AND_SCAN_DURING_IP
+		handle_pwrsave_during_obtainingIP(vif, IP_STATE_GO_ASSIGNING);
+#endif
+		dev->ieee80211_ptr->iftype = type;
+		priv->wdev->iftype = type;
+		vif->iftype = GO_MODE;
+		wilc_set_wfi_drv_handler(vif, wilc_get_vif_idx(vif),
+						 AP_MODE, vif->ifc_id);
+		wilc_set_operation_mode(vif, AP_MODE);
+		wilc_enable_ps = false;
+		wilc_set_power_mgmt(vif_1, 0, 0);
+		wilc_set_power_mgmt(vif_2, 0, 0);
+		break;
+
+	default:
+		PRINT_ER(dev, "Unknown interface type= %d\n", type);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int start_ap(struct wiphy *wiphy, struct net_device *dev,
+		    struct cfg80211_ap_settings *settings)
+{
+	struct cfg80211_beacon_data *beacon = &settings->beacon;
+	struct wilc_priv *priv;
+	s32 ret = 0;
+	struct wilc_vif *vif;
+
+	priv = wiphy_priv(wiphy);
+	vif = netdev_priv(dev);
+	PRINT_INFO(vif->ndev, HOSTAPD_DBG,"Starting ap\n");
+
+	PRINT_INFO(vif->ndev, CFG80211_DBG,
+		   "Interval= %d\n DTIM period= %d\n Head length= %d Tail length= %d\n",
+		   settings->beacon_interval, settings->dtim_period,
+		   beacon->head_len,beacon->tail_len);
+	ret = set_channel(wiphy, &settings->chandef);
+
+	if (ret != 0)
+		PRINT_ER(dev, "Error in setting channel\n");
+
+	wilc_wlan_set_bssid(dev,vif->src_addr,AP_MODE);
+	wilc_set_power_mgmt(vif, 0, 0);
+
+	return wilc_add_beacon(vif, settings->beacon_interval,
+				   settings->dtim_period, beacon->head_len,
+				   (u8 *)beacon->head, beacon->tail_len,
+				   (u8 *)beacon->tail);
+}
+
+static int change_beacon(struct wiphy *wiphy, struct net_device *dev,
+			 struct cfg80211_beacon_data *beacon)
+{
+	struct wilc_priv *priv;
+	struct wilc_vif *vif;
+
+	priv = wiphy_priv(wiphy);
+	vif = netdev_priv(priv->dev);
+	PRINT_INFO(vif->ndev, HOSTAPD_DBG, "Setting beacon\n");
+
+	return wilc_add_beacon(vif, 0, 0, beacon->head_len,
+				   (u8 *)beacon->head, beacon->tail_len,
+				   (u8 *)beacon->tail);
+}
+
+static int stop_ap(struct wiphy *wiphy, struct net_device *dev)
+{
+	s32 ret = 0;
+	struct wilc_priv *priv;
+	struct wilc_vif *vif;
+	u8 null_bssid[ETH_ALEN] = {0};
+
+	if (!wiphy)
+		return -EFAULT;
+
+	priv = wiphy_priv(wiphy);
+	vif = netdev_priv(priv->dev);
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "Deleting beacon\n");
+
+	wilc_wlan_set_bssid(dev, null_bssid, AP_MODE);
+
+	ret = wilc_del_beacon(vif);
+
+	if (ret)
+		PRINT_ER(dev, "Host delete beacon fail\n");
+
+	return ret;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,16,0)
+static int add_station(struct wiphy *wiphy, struct net_device *dev,
+		       const u8 *mac, struct station_parameters *params)
+#else
+static int add_station(struct wiphy *wiphy, struct net_device *dev,
+		       u8 *mac, struct station_parameters *params)
+#endif
+{
+	s32 ret = 0;
+	struct wilc_priv *priv;
+	struct add_sta_param sta_params = { {0} };
+	struct wilc_vif *vif;
+
+	if (!wiphy)
+		return -EFAULT;
+
+	priv = wiphy_priv(wiphy);
+	vif = netdev_priv(dev);
+
+	if (vif->iftype == AP_MODE || vif->iftype == GO_MODE) {
+		memcpy(sta_params.bssid, mac, ETH_ALEN);
+		memcpy(priv->assoc_stainfo.sta_associated_bss[params->aid], mac,
+		       ETH_ALEN);
+		sta_params.aid = params->aid;
+		sta_params.rates_len = params->supported_rates_len;
+		sta_params.rates = params->supported_rates;
+
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Adding station parameters %d\n", params->aid);
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "BSSID = %x%x%x%x%x%x\n",
+			   priv->assoc_stainfo.sta_associated_bss[params->aid][0],
+			   priv->assoc_stainfo.sta_associated_bss[params->aid][1],
+			   priv->assoc_stainfo.sta_associated_bss[params->aid][2],
+			   priv->assoc_stainfo.sta_associated_bss[params->aid][3],
+			   priv->assoc_stainfo.sta_associated_bss[params->aid][4],
+			   priv->assoc_stainfo.sta_associated_bss[params->aid][5]);
+		PRINT_INFO(vif->ndev, HOSTAPD_DBG, "ASSOC ID = %d\n",
+			   sta_params.aid);
+		PRINT_INFO(vif->ndev, HOSTAPD_DBG,
+			   "Number of supported rates = %d\n",
+			   sta_params.rates_len);
+		if (!params->ht_capa) {
+			sta_params.ht_supported = false;
+		} else {
+			sta_params.ht_supported = true;
+			sta_params.ht_capa = *params->ht_capa;
+		}
+
+		sta_params.flags_mask = params->sta_flags_mask;
+		sta_params.flags_set = params->sta_flags_set;
+
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "IS HT supported = %d\n",
+			   sta_params.ht_supported);
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "Capability Info = %d\n",
+			   sta_params.ht_capa.cap_info);
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "AMPDU Params = %d\n",
+			   sta_params.ht_capa.ampdu_params_info);
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "HT Extended params= %d\n",
+			   sta_params.ht_capa.extended_ht_cap_info);
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "Tx Beamforming Cap= %d\n",
+			   sta_params.ht_capa.tx_BF_cap_info);
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Antenna selection info = %d\n",
+			   sta_params.ht_capa.antenna_selection_info);
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "Flag Mask = %d\n",
+			   sta_params.flags_mask);
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "Flag Set = %d\n",
+			   sta_params.flags_set);
+		ret = wilc_add_station(vif, &sta_params);
+		if (ret)
+			PRINT_ER(dev, "Host add station fail\n");
+	}
+
+	return ret;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 19, 0)
+static int del_station(struct wiphy *wiphy, struct net_device *dev,
+		       struct station_del_parameters *params)
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(3, 16, 0)
+static int del_station(struct wiphy *wiphy, struct net_device *dev,
+		       const u8 *mac)
+#else
+static int del_station(struct wiphy *wiphy, struct net_device *dev,
+		       u8 *mac)
+#endif
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 19, 0)
+	const u8 *mac = params->mac;
+#endif
+	s32 ret = 0;
+	struct wilc_priv *priv;
+	struct wilc_vif *vif;
+
+	if (!wiphy)
+		return -EFAULT;
+
+	priv = wiphy_priv(wiphy);
+	vif = netdev_priv(dev);
+
+	if (vif->iftype == AP_MODE || vif->iftype == GO_MODE) {
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "Deleting station\n");
+		if (!mac) {
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+				   "All associated stations\n");
+			ret = wilc_del_allstation(vif,
+				     priv->assoc_stainfo.sta_associated_bss);
+		} else {
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+				   "With mac address: %x%x%x%x%x%x\n",
+				   mac[0], mac[1], mac[2], mac[3], mac[4],
+				   mac[5]);
+		}
+
+		ret = wilc_del_station(vif, mac);
+
+		if (ret)
+			PRINT_ER(dev, "Host delete station fail\n");
+	}
+	return ret;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 16, 0)
+static int change_station(struct wiphy *wiphy, struct net_device *dev,
+			  const u8 *mac, struct station_parameters *params)
+#else
+static int change_station(struct wiphy *wiphy, struct net_device *dev,
+			  u8 *mac, struct station_parameters *params)
+#endif
+{
+	s32 ret = 0;
+	struct wilc_priv *priv;
+	struct add_sta_param sta_params = { {0} };
+	struct wilc_vif *vif;
+
+	PRINT_D(vif->ndev, CFG80211_DBG, "Change station paramters\n");
+
+	if (!wiphy)
+		return -EFAULT;
+
+	priv = wiphy_priv(wiphy);
+	vif = netdev_priv(dev);
+
+	if (vif->iftype == AP_MODE || vif->iftype == GO_MODE) {
+		memcpy(sta_params.bssid, mac, ETH_ALEN);
+		sta_params.aid = params->aid;
+		sta_params.rates_len = params->supported_rates_len;
+		sta_params.rates = params->supported_rates;
+
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "BSSID = %x%x%x%x%x%x\n",
+			  sta_params.bssid[0], sta_params.bssid[1],
+			  sta_params.bssid[2], sta_params.bssid[3],
+			  sta_params.bssid[4],
+			  sta_params.bssid[5]);
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "ASSOC ID = %d\n",
+			   sta_params.aid);
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Number of supported rates = %d\n",
+			   sta_params.rates_len);
+		if (!params->ht_capa) {
+			sta_params.ht_supported = false;
+		} else {
+			sta_params.ht_supported = true;
+			sta_params.ht_capa = *params->ht_capa;
+		}
+
+		sta_params.flags_mask = params->sta_flags_mask;
+		sta_params.flags_set = params->sta_flags_set;
+
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "IS HT supported = %d\n",
+			   sta_params.ht_supported);
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "Capability Info = %d\n",
+			   sta_params.ht_capa.cap_info);
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "AMPDU Params = %d\n",
+			   sta_params.ht_capa.ampdu_params_info);
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "HT Extended params= %d\n",
+			   sta_params.ht_capa.extended_ht_cap_info);
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "Tx Beamforming Cap= %d\n",
+			   sta_params.ht_capa.tx_BF_cap_info);
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Antenna selection info = %d\n",
+			   sta_params.ht_capa.antenna_selection_info);
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "Flag Mask = %d\n",
+			   sta_params.flags_mask);
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "Flag Set = %d\n",
+			   sta_params.flags_set);
+		ret = wilc_edit_station(vif, &sta_params);
+		if (ret)
+			PRINT_ER(dev, "Host edit station fail\n");
+	}
+	return ret;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 12, 0)
+static struct wireless_dev *add_virtual_intf(struct wiphy *wiphy,
+					     const char *name,
+					     unsigned char name_assign_type,
+					     enum nl80211_iftype type,
+					     struct vif_params *params)
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(4, 1, 0)
+static struct wireless_dev *add_virtual_intf(struct wiphy *wiphy,
+					     const char *name,
+					     unsigned char name_assign_type,
+					     enum nl80211_iftype type,
+					     u32 *flags,
+					     struct vif_params *params)
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(3, 7, 0)
+static struct wireless_dev *add_virtual_intf(struct wiphy *wiphy,
+					     const char *name,
+					     enum nl80211_iftype type,
+					     u32 *flags,
+					     struct vif_params *params)
+#else
+static struct wireless_dev *add_virtual_intf(struct wiphy *wiphy,
+					     char *name,
+					     enum nl80211_iftype type,
+					     u32 *flags,
+					     struct vif_params *params)
+#endif
+{
+	struct wilc_vif *vif;
+	struct wilc_priv *priv;
+	struct net_device *new_ifc = NULL;
+
+	priv = wiphy_priv(wiphy);
+	vif = netdev_priv(priv->wdev->netdev);
+
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "Adding monitor interface[%p]\n",
+		   priv->wdev->netdev);
+
+	if (type == NL80211_IFTYPE_MONITOR) {
+		PRINT_INFO(vif->ndev, CFG80211_DBG,
+			   "Initializing mon ifc virtual device driver\n");
+		PRINT_INFO(vif->ndev, CFG80211_DBG, "Adding monitor interface[%p]\n", vif->ndev);
+		new_ifc = WILC_WFI_init_mon_interface(name, vif->ndev);
+		if (new_ifc) {
+			PRINT_INFO(vif->ndev, CFG80211_DBG,
+			"Setting monitor flag in private structure\n");
+			vif = netdev_priv(priv->wdev->netdev);
+			vif->monitor_flag = 1;
+		} else {
+			PRINT_ER(vif->ndev,
+				 "Error in initializing monitor interface\n");
+		}
+	}
+	return priv->wdev;
+}
+
+static int del_virtual_intf(struct wiphy *wiphy, struct wireless_dev *wdev)
+{
+	struct wilc_priv *priv = wiphy_priv(wiphy);
+	
+	PRINT_INFO(priv->dev, HOSTAPD_DBG, "Deleting virtual interface\n");
+	return 0;
+}
+
+static int wilc_suspend(struct wiphy *wiphy, struct cfg80211_wowlan *wow)
+{
+	struct wilc_priv *priv = wiphy_priv(wiphy);
+
+	if(!wow)
+		PRINT_INFO(priv->dev, GENERIC_DBG, "No wake up triggers defined\n");
+	else if(wow->any == 0)
+		PRINT_INFO(priv->dev, GENERIC_DBG,
+			   "The only supported wake up trigger (any) is not set\n");
+
+	return 0;
+}
+
+static int wilc_resume(struct wiphy *wiphy)
+{
+	struct wilc_priv *priv = wiphy_priv(wiphy);
+	struct wilc_vif *vif = netdev_priv(priv->dev);
+
+	PRINT_INFO(vif->ndev, GENERIC_DBG, "cfg resume\n");
+	return 0;
+}
+
+static void wilc_set_wakeup(struct wiphy *wiphy, bool enabled)
+{
+	struct wilc_priv *priv = wiphy_priv(wiphy);
+	struct wilc_vif *vif = netdev_priv(priv->dev);
+
+	PRINT_INFO(vif->ndev, GENERIC_DBG, "cfg set wake up = %d\n", enabled);
+	host_int_set_wowlan_trigger(vif,(u8)enabled);
+}
+
+static int set_tx_power(struct wiphy *wiphy, struct wireless_dev *wdev,
+			enum nl80211_tx_power_setting type, int mbm)
+{
+	int ret;
+	s32 tx_power = MBM_TO_DBM(mbm);
+	struct wilc_priv *priv = wiphy_priv(wiphy);
+	struct wilc_vif *vif = netdev_priv(priv->dev);
+
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "Setting tx power %d\n", tx_power);
+	if (tx_power < 0)
+		tx_power = 0;
+	else if (tx_power > 18)
+		tx_power = 18;
+	ret = wilc_set_tx_power(vif, tx_power);
+	if (ret)
+		PRINT_ER(vif->ndev, "Failed to set tx power\n");
+
+	return ret;
+}
+
+static int get_tx_power(struct wiphy *wiphy, struct wireless_dev *wdev,
+			int *dbm)
+{
+	int ret;
+	struct wilc_priv *priv = wiphy_priv(wiphy);
+	struct wilc_vif *vif = netdev_priv(priv->dev);
+	struct wilc *wl;
+
+	wl = vif->wilc;
+
+	/* If firmware is not started, return. */
+	if (!wl->initialized)
+		return -EIO;
+	*dbm=0;
+	ret = wilc_get_tx_power(vif, (u8 *)dbm);
+	if (ret)
+		PRINT_ER(vif->ndev, "Failed to get tx power\n");
+
+	PRINT_INFO(vif->ndev, CFG80211_DBG, "Got tx power %d\n", *dbm);
+
+	return ret;
+}
+
+static int set_antenna(struct wiphy *wiphy, u32 tx_ant, u32 rx_ant)
+{
+	int ret;
+	struct wilc_priv *priv = wiphy_priv(wiphy);
+	struct wilc_vif *vif = netdev_priv(priv->dev);
+
+	PRINT_INFO(vif->ndev, CFG80211_DBG,"Select antenna mode %d\n",tx_ant);
+	if (!tx_ant || !rx_ant)
+		return -EINVAL;
+
+	ret = wilc_set_antenna(vif, (u8)(tx_ant-1));
+	if (ret)
+		PRINT_ER(vif->ndev, "Failed to set tx antenna\n");
+
+	return ret;
+}
+
+static const struct cfg80211_ops wilc_cfg80211_ops = {
+	.set_monitor_channel = set_channel,
+	.scan = scan,
+	.connect = connect,
+	.disconnect = disconnect,
+	.add_key = add_key,
+	.del_key = del_key,
+	.get_key = get_key,
+	.set_default_key = set_default_key,
+	.add_virtual_intf = add_virtual_intf,
+	.del_virtual_intf = del_virtual_intf,
+	.change_virtual_intf = change_virtual_intf,
+
+	.start_ap = start_ap,
+	.change_beacon = change_beacon,
+	.stop_ap = stop_ap,
+	.add_station = add_station,
+	.del_station = del_station,
+	.change_station = change_station,
+	.get_station = get_station,
+	.dump_station = dump_station,
+	.change_bss = change_bss,
+	.set_wiphy_params = set_wiphy_params,
+
+	.set_pmksa = set_pmksa,
+	.del_pmksa = del_pmksa,
+	.flush_pmksa = flush_pmksa,
+	.remain_on_channel = remain_on_channel,
+	.cancel_remain_on_channel = cancel_remain_on_channel,
+	.mgmt_tx_cancel_wait = mgmt_tx_cancel_wait,
+	.mgmt_tx = mgmt_tx,
+	.mgmt_frame_register = wilc_mgmt_frame_register,
+	.set_power_mgmt = set_power_mgmt,
+	.set_cqm_rssi_config = set_cqm_rssi_config,
+
+	.suspend = wilc_suspend,
+	.resume = wilc_resume,
+	.set_wakeup = wilc_set_wakeup,
+	.set_tx_power = set_tx_power,
+	.get_tx_power = get_tx_power,
+	.set_antenna = set_antenna,
+};
+
+static struct wireless_dev *wilc_wfi_cfg_alloc(struct net_device *net)
+{
+	struct wireless_dev *wdev;
+
+	PRINT_INFO(net, CFG80211_DBG, "Allocating wireless device\n");
+	wdev = kzalloc(sizeof(struct wireless_dev), GFP_KERNEL);
+	if (!wdev) {
+		PRINT_ER(net, "Cannot allocate wireless device\n");
+		goto _fail_;
+	}
+
+	wdev->wiphy = wiphy_new(&wilc_cfg80211_ops, sizeof(struct wilc_priv));
+	if (!wdev->wiphy) {
+		PRINT_ER(net, "Cannot allocate wiphy\n");
+		goto _fail_mem_;
+	}
+
+	WILC_WFI_band_2ghz.ht_cap.ht_supported = 1;
+	WILC_WFI_band_2ghz.ht_cap.cap |= (1 << IEEE80211_HT_CAP_RX_STBC_SHIFT);
+	WILC_WFI_band_2ghz.ht_cap.mcs.rx_mask[0] = 0xff;
+	WILC_WFI_band_2ghz.ht_cap.ampdu_factor = IEEE80211_HT_MAX_AMPDU_8K;
+	WILC_WFI_band_2ghz.ht_cap.ampdu_density = IEEE80211_HT_MPDU_DENSITY_NONE;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+	wdev->wiphy->bands[NL80211_BAND_2GHZ] = &WILC_WFI_band_2ghz;
+#else
+	wdev->wiphy->bands[IEEE80211_BAND_2GHZ] = &WILC_WFI_band_2ghz;
+#endif
+	return wdev;
+
+_fail_mem_:
+	kfree(wdev);
+_fail_:
+	return NULL;
+}
+
+struct wireless_dev *wilc_create_wiphy(struct net_device *net,
+				       struct device *dev)
+{
+	struct wilc_priv *priv;
+	struct wireless_dev *wdev;
+	s32 ret = 0;
+
+	PRINT_INFO(net, CFG80211_DBG, "Registering wifi device\n");
+	wdev = wilc_wfi_cfg_alloc(net);
+	if (!wdev) {
+		PRINT_ER(net, "wiphy new allocate failed\n");
+		return NULL;
+	}
+
+	priv = wdev_priv(wdev);
+	priv->wdev = wdev;
+	wdev->wiphy->max_scan_ssids = MAX_NUM_PROBED_SSID;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,11,0)
+	wdev->wiphy->wowlan = &wowlan_support;
+#else
+	wdev->wiphy->wowlan = wowlan_support;
+#endif
+	wdev->wiphy->max_num_pmkids = WILC_MAX_NUM_PMKIDS;
+	PRINT_D(net, CFG80211_DBG, "Max number of PMKIDs = %d\n",
+		wdev->wiphy->max_num_pmkids);
+	wdev->wiphy->max_scan_ie_len = 1000;
+	wdev->wiphy->signal_type = CFG80211_SIGNAL_TYPE_MBM;
+	wdev->wiphy->cipher_suites = cipher_suites;
+	wdev->wiphy->n_cipher_suites = ARRAY_SIZE(cipher_suites);
+	wdev->wiphy->available_antennas_tx = 0x3;
+	wdev->wiphy->available_antennas_rx = 0x3;
+	wdev->wiphy->mgmt_stypes = wilc_wfi_cfg80211_mgmt_types;
+
+	wdev->wiphy->max_remain_on_channel_duration = 500;
+	wdev->wiphy->interface_modes = BIT(NL80211_IFTYPE_STATION) |
+					BIT(NL80211_IFTYPE_AP) |
+					BIT(NL80211_IFTYPE_MONITOR) |
+					BIT(NL80211_IFTYPE_P2P_GO) |
+					BIT(NL80211_IFTYPE_P2P_CLIENT);
+	wdev->wiphy->flags |= WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL;
+	wdev->iftype = NL80211_IFTYPE_STATION;
+
+	PRINT_D(net, CFG80211_DBG,
+		"Max scan ids= %d,Max scan IE len= %d,Signal Type= %d,Interface Modes= %d,Interface Type= %d\n",
+		wdev->wiphy->max_scan_ssids, wdev->wiphy->max_scan_ie_len, wdev->wiphy->signal_type,
+		wdev->wiphy->interface_modes, wdev->iftype);
+
+	set_wiphy_dev(wdev->wiphy, dev);
+
+	ret = wiphy_register(wdev->wiphy);
+	if (ret)
+		PRINT_ER(net, "Cannot register wiphy device\n");
+	else
+		PRINT_INFO(net, CFG80211_DBG, "Successful Registering\n");
+
+	priv->dev = net;
+	return wdev;
+}
+
+int wilc_init_host_int(struct net_device *net)
+{
+	int ret = 0;
+	struct wilc_priv *priv;
+
+	PRINT_INFO(net, INIT_DBG, "Host[%p][%p]\n", net, net->ieee80211_ptr);
+	priv = wdev_priv(net->ieee80211_ptr);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,15,0)
+	#ifdef DISABLE_PWRSAVE_AND_SCAN_DURING_IP
+	timer_setup(&priv->during_ip_timer, clear_duringIP, 0);
+	#endif
+	timer_setup(&priv->eap_buff_timer, eap_buff_timeout, 0);
+#else
+	#ifdef DISABLE_PWRSAVE_AND_SCAN_DURING_IP
+	setup_timer(&priv->during_ip_timer, clear_duringIP, 0);
+	#endif
+	setup_timer(&priv->eap_buff_timer, eap_buff_timeout, 0);
+#endif
+	op_ifcs++;
+
+	priv->auto_rate_adjusted = false;
+
+	priv->p2p_listen_state = false;
+
+	mutex_init(&priv->scan_req_lock);
+	ret = wilc_init(net, &priv->hif_drv);
+	if (ret)
+		PRINT_ER(net, "Error while initializing hostinterface\n");
+
+	return ret;
+}
+
+int wilc_deinit_host_int(struct net_device *net)
+{
+	int ret = 0;
+	struct wilc_vif *vif;
+	struct wilc_priv *priv;
+
+	priv = wdev_priv(net->ieee80211_ptr);
+	vif = netdev_priv(priv->dev);
+
+	priv->auto_rate_adjusted = false;
+
+	priv->p2p_listen_state = false;
+
+	op_ifcs--;
+
+	mutex_destroy(&priv->scan_req_lock);
+	ret = wilc_deinit(vif);
+
+	clear_shadow_scan(vif);
+#ifdef DISABLE_PWRSAVE_AND_SCAN_DURING_IP
+	del_timer_sync(&priv->during_ip_timer);
+#endif
+	del_timer_sync(&priv->eap_buff_timer);
+
+	if (ret)
+		PRINT_ER(net, "Error while deinitializing host interface\n");
+
+	return ret;
+}
+
+void wilc_free_wiphy(struct net_device *net)
+{
+	PRINT_INFO(net, CFG80211_DBG, "Unregistering wiphy\n");
+	if (!net) {
+		PRINT_INFO(net, INIT_DBG, "net_device is NULL\n");
+		return;
+	}
+
+	if (!net->ieee80211_ptr) {
+		PRINT_INFO(net, INIT_DBG, "ieee80211_ptr is NULL\n");
+		return;
+	}
+
+	if (!net->ieee80211_ptr->wiphy) {
+		PRINT_INFO(net, INIT_DBG, "wiphy is NULL\n");
+		return;
+	}
+
+	wiphy_unregister(net->ieee80211_ptr->wiphy);
+
+	PRINT_INFO(net, INIT_DBG, "Freeing wiphy\n");
+	wiphy_free(net->ieee80211_ptr->wiphy);
+	kfree(net->ieee80211_ptr);
+}
diff --git a/drivers/staging/wilc1000/wilc_wfi_cfgoperations.h b/drivers/staging/wilc/wilc_wfi_cfgoperations.h
similarity index 69%
rename from drivers/staging/wilc1000/wilc_wfi_cfgoperations.h
rename to drivers/staging/wilc/wilc_wfi_cfgoperations.h
index dfb7ec2..d835d4a 100644
--- a/drivers/staging/wilc1000/wilc_wfi_cfgoperations.h
+++ b/drivers/staging/wilc/wilc_wfi_cfgoperations.h
@@ -11,14 +11,23 @@
 #define NM_WFI_CFGOPERATIONS
 #include "wilc_wfi_netdevice.h"
 
+#define NO_ENCRYPT		0
+
 struct wireless_dev *wilc_create_wiphy(struct net_device *net, struct device *dev);
 void wilc_free_wiphy(struct net_device *net);
 int wilc_deinit_host_int(struct net_device *net);
 int wilc_init_host_int(struct net_device *net);
-void WILC_WFI_monitor_rx(u8 *buff, u32 size);
+void WILC_WFI_monitor_rx(struct wilc_vif *vif, u8 *buff, u32 size);
 int WILC_WFI_deinit_mon_interface(void);
 struct net_device *WILC_WFI_init_mon_interface(const char *name, struct net_device *real_dev);
 void wilc_mgmt_frame_register(struct wiphy *wiphy, struct wireless_dev *wdev,
 			      u16 frame_type, bool reg);
+void wilc_sysfs_init(struct wilc_vif *vif1, struct wilc_vif *vif2);
+void wilc_sysfs_exit(void);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,15,0)
+void remove_network_from_shadow(struct timer_list *t);
+#else
+void remove_network_from_shadow(unsigned long arg);
+#endif
 
 #endif
diff --git a/drivers/staging/wilc1000/wilc_wfi_netdevice.h b/drivers/staging/wilc/wilc_wfi_netdevice.h
similarity index 69%
rename from drivers/staging/wilc1000/wilc_wfi_netdevice.h
rename to drivers/staging/wilc/wilc_wfi_netdevice.h
index e6f4d84..af82f51 100644
--- a/drivers/staging/wilc1000/wilc_wfi_netdevice.h
+++ b/drivers/staging/wilc/wilc_wfi_netdevice.h
@@ -9,10 +9,6 @@
 #ifndef WILC_WFI_NETDEVICE
 #define WILC_WFI_NETDEVICE
 
-#define WILC_WFI_RX_INTR 0x0001
-#define WILC_WFI_TX_INTR 0x0002
-
-#define WILC_WFI_TIMEOUT 5
 #define WILC_MAX_NUM_PMKIDS  16
 #define PMKID_LEN  16
 #define PMKID_FOUND 1
@@ -42,6 +38,7 @@
 #include <asm/checksum.h>
 #include "host_interface.h"
 #include "wilc_wlan.h"
+#include "wilc_wlan_if.h"
 #include <linux/wireless.h>
 #include <linux/completion.h>
 #include <linux/mutex.h>
@@ -49,12 +46,11 @@
 #define FLOW_CONTROL_LOWER_THRESHOLD	128
 #define FLOW_CONTROL_UPPER_THRESHOLD	256
 
-enum stats_flags {
-	WILC_WFI_RX_PKT = BIT(0),
-	WILC_WFI_TX_PKT = BIT(1),
-};
+#define ANT_SWTCH_INVALID_GPIO_CTRL 	0
+#define ANT_SWTCH_SNGL_GPIO_CTRL 	1
+#define ANT_SWTCH_DUAL_GPIO_CTRL	2
 
-struct WILC_WFI_stats {
+struct wilc_wfi_stats {
 	unsigned long rx_packets;
 	unsigned long tx_packets;
 	unsigned long rx_bytes;
@@ -64,12 +60,7 @@ struct WILC_WFI_stats {
 
 };
 
-/*
- * This structure is private to each device. It is used to pass
- * packets in and out, so there is place for a packet
- */
-
-#define num_reg_frame 2
+#define NUM_REG_FRAME 2
 
 struct wilc_wfi_key {
 	u8 *key;
@@ -86,59 +77,60 @@ struct wilc_wfi_wep_key {
 };
 
 struct sta_info {
-	u8 au8Sta_AssociatedBss[MAX_NUM_STA][ETH_ALEN];
+	u8 sta_associated_bss[MAX_NUM_STA][ETH_ALEN];
 };
 
 /*Parameters needed for host interface for  remaining on channel*/
-struct wilc_wfi_p2pListenParams {
-	struct ieee80211_channel *pstrListenChan;
-	enum nl80211_channel_type tenuChannelType;
-	u32 u32ListenDuration;
-	u64 u64ListenCookie;
-	u32 u32ListenSessionID;
+struct wilc_wfi_p2p_listen_params {
+	struct ieee80211_channel *listen_ch;
+	u32 listen_duration;
+	u64 listen_cookie;
+	u32 listen_session_id;
+};
+
+/* Struct to buffer eapol 1/4 frame */
+struct wilc_buffered_eap {
+	unsigned int size;
+	unsigned int pkt_offset;
+	u8 *buff;
 };
 
 struct wilc_priv {
 	struct wireless_dev *wdev;
-	struct cfg80211_scan_request *pstrScanReq;
-
-	struct wilc_wfi_p2pListenParams strRemainOnChanParams;
-	u64 u64tx_cookie;
+	struct cfg80211_scan_request *scan_req;
+	struct wilc_wfi_p2p_listen_params remain_on_ch_params;
+	u64 tx_cookie;
+	bool cfg_scanning;
+	u32 rcvd_ch_cnt;
 
-	bool bCfgScanning;
-	u32 u32RcvdChCount;
-
-	u8 au8AssociatedBss[ETH_ALEN];
+	u8 associated_bss[ETH_ALEN];
 	struct sta_info assoc_stainfo;
 	struct net_device_stats stats;
 	u8 monitor_flag;
 	int status;
-	struct WILC_WFI_packet *ppool;
-	struct WILC_WFI_packet *rx_queue; /* List of incoming packets */
-	int rx_int_enabled;
-	int tx_packetlen;
-	u8 *tx_packetdata;
 	struct sk_buff *skb;
 	spinlock_t lock;
 	struct net_device *dev;
-	struct napi_struct napi;
 	struct host_if_drv *hif_drv;
 	struct host_if_pmkid_attr pmkid_list;
-	struct WILC_WFI_stats netstats;
-	u8 WILC_WFI_wep_key[4][WLAN_KEY_LEN_WEP104];
-	u8 WILC_WFI_wep_key_len[4];
+	struct wilc_wfi_stats netstats;
+	u8 wep_key[4][WLAN_KEY_LEN_WEP104];
+	u8 wep_key_len[4];
 	/* The real interface that the monitor is on */
 	struct net_device *real_ndev;
 	struct wilc_wfi_key *wilc_gtk[MAX_NUM_STA];
 	struct wilc_wfi_key *wilc_ptk[MAX_NUM_STA];
 	u8 wilc_groupkey;
-	/* mutexes */
+
 	struct mutex scan_req_lock;
 	/*  */
-	bool gbAutoRateAdjusted;
+	bool auto_rate_adjusted;
 
-	bool bInP2PlistenState;
+	bool p2p_listen_state;
+	struct wilc_buffered_eap *buffered_eap;
 
+	struct timer_list eap_buff_timer;
+	struct timer_list during_ip_timer;
 };
 
 struct frame_reg {
@@ -146,27 +138,40 @@ struct frame_reg {
 	bool reg;
 };
 
+typedef struct {
+	bool p2p_mode;
+	u8 ant_swtch_mode;
+	u8 antenna1;
+	u8 antenna2;
+} sysfs_attr_group;
+
 struct wilc_vif {
 	u8 idx;
 	u8 iftype;
 	int monitor_flag;
 	int mac_opened;
-	struct frame_reg frame_reg[num_reg_frame];
+	struct frame_reg frame_reg[NUM_REG_FRAME];
 	struct net_device_stats netstats;
 	struct wilc *wilc;
 	u8 src_addr[ETH_ALEN];
 	u8 bssid[ETH_ALEN];
 	struct host_if_drv *hif_drv;
 	struct net_device *ndev;
-	u8 mode;
 	u8 ifc_id;
+
+	sysfs_attr_group attr_sysfs;
+#ifdef DISABLE_PWRSAVE_AND_SCAN_DURING_IP
+	bool pwrsave_current_state;
+#endif
 };
 
 struct wilc {
 	const struct wilc_hif_func *hif_func;
 	int io_type;
 	int mac_status;
-	int gpio;
+	int gpio_irq;
+	int gpio_reset;
+	int gpio_chip_en;
 	bool initialized;
 	int dev_irq_num;
 	int close;
@@ -184,8 +189,9 @@ struct wilc {
 	struct completion sync_event;
 	struct completion txq_event;
 	struct completion txq_thread_started;
-
+	struct completion debug_thread_started;
 	struct task_struct *txq_thread;
+	struct task_struct *debug_thread;
 
 	int quit;
 	int cfg_frame_in_use;
@@ -201,6 +207,7 @@ struct wilc {
 
 	struct txq_entry_t *txq_head;
 	struct txq_entry_t *txq_tail;
+	struct txq_handle txq[NQUEUES];
 	int txq_entries;
 	int txq_exit;
 
@@ -214,25 +221,30 @@ struct wilc {
 	const struct firmware *firmware;
 
 	struct device *dev;
-	bool suspend_event;
 
 	struct rf_info dummy_statistics;
+
+	enum wilc_chip_type chip;
+
+	uint8_t power_status[PWR_DEV_SRC_MAX];
+	uint8_t keep_awake[PWR_DEV_SRC_MAX];
+	struct mutex cs;
+
+	struct timer_list aging_timer;
+	struct wilc_vif *aging_timer_vif;
 };
 
 struct WILC_WFI_mon_priv {
 	struct net_device *real_ndev;
 };
 
-int wilc1000_wlan_init(struct net_device *dev, struct wilc_vif *vif);
-
-void wilc_frmw_to_linux(struct wilc *wilc, u8 *buff, u32 size, u32 pkt_offset);
+void wilc_frmw_to_linux(struct wilc *wilc, u8 *buff, u32 size, u32 pkt_offset,
+			u8 status);
 void wilc_mac_indicate(struct wilc *wilc, int flag);
 void wilc_netdev_cleanup(struct wilc *wilc);
 int wilc_netdev_init(struct wilc **wilc, struct device *dev, int io_type,
-		     int gpio, const struct wilc_hif_func *ops);
-void wilc1000_wlan_deinit(struct net_device *dev);
-void WILC_WFI_mgmt_rx(struct wilc *wilc, u8 *buff, u32 size);
-int wilc_wlan_get_firmware(struct net_device *dev);
+		     const struct wilc_hif_func *ops);
+void wilc_wfi_mgmt_rx(struct wilc *wilc, u8 *buff, u32 size);
 int wilc_wlan_set_bssid(struct net_device *wilc_netdev, u8 *bssid, u8 mode);
 
 #endif
diff --git a/drivers/staging/wilc/wilc_wlan.c b/drivers/staging/wilc/wilc_wlan.c
new file mode 100644
index 0000000..480d90e
--- /dev/null
+++ b/drivers/staging/wilc/wilc_wlan.c
@@ -0,0 +1,2077 @@
+// SPDX-License-Identifier: GPL-2.0
+#include <linux/completion.h>
+#include "wilc_wlan_if.h"
+#include "wilc_wlan.h"
+#include "linux_wlan.h"
+#include "wilc_wfi_netdevice.h"
+#include "wilc_wlan_cfg.h"
+
+#define WAKUP_TRAILS_TIMEOUT		(10000)
+
+extern void wilc_frmw_to_linux(struct wilc *wilc, u8 *buff, u32 size,
+				u32 pkt_offset, u8 status);
+
+void acquire_bus(struct wilc *wilc, enum bus_acquire acquire, int source)
+{
+	mutex_lock(&wilc->hif_cs);
+	if (acquire == ACQUIRE_AND_WAKEUP)
+		chip_wakeup(wilc, source);
+}
+
+void release_bus(struct wilc *wilc, enum bus_release release, int source)
+{
+	if (release == RELEASE_ALLOW_SLEEP)
+		chip_allow_sleep(wilc, source);
+	mutex_unlock(&wilc->hif_cs);
+}
+
+uint8_t reset_bus(struct wilc *wilc)
+{
+	uint8_t ret = 0;
+	if(wilc->io_type == HIF_SPI)
+		return wilc->hif_func->hif_reset(wilc);
+	return ret;
+}
+
+static void wilc_wlan_txq_remove(struct wilc *wilc, u8 q_num,
+				 struct txq_entry_t *tqe)
+{
+	if (tqe == wilc->txq[q_num].txq_head) {
+		wilc->txq[q_num].txq_head = tqe->next;
+		if (wilc->txq[q_num].txq_head)
+			wilc->txq[q_num].txq_head->prev = NULL;
+	} else if (tqe == wilc->txq[q_num].txq_tail) {
+		wilc->txq[q_num].txq_tail = tqe->prev;
+		if (wilc->txq[q_num].txq_tail)
+			wilc->txq[q_num].txq_tail->next = NULL;
+	} else {
+		tqe->prev->next = tqe->next;
+		tqe->next->prev = tqe->prev;
+	}
+	wilc->txq_entries -= 1;
+	wilc->txq[q_num].count--;
+}
+
+static struct txq_entry_t *
+wilc_wlan_txq_remove_from_head(struct net_device *dev, u8 q_num)
+{
+	struct txq_entry_t *tqe;
+	unsigned long flags;
+	struct wilc_vif *vif;
+	struct wilc *wilc;
+
+	vif = netdev_priv(dev);
+	wilc = vif->wilc;
+
+	spin_lock_irqsave(&wilc->txq_spinlock, flags);
+	if (wilc->txq[q_num].txq_head) {
+		tqe = wilc->txq[q_num].txq_head;
+		wilc->txq[q_num].txq_head = tqe->next;
+		if (wilc->txq[q_num].txq_head)
+			wilc->txq[q_num].txq_head->prev = NULL;
+
+		wilc->txq_entries -= 1;
+		wilc->txq[q_num].count--;
+	} else {
+		tqe = NULL;
+	}
+	spin_unlock_irqrestore(&wilc->txq_spinlock, flags);
+	return tqe;
+}
+
+static void wilc_wlan_txq_add_to_tail(struct net_device *dev, u8 q_num,
+				      struct txq_entry_t *tqe)
+{
+	unsigned long flags;
+	struct wilc_vif *vif;
+	struct wilc *wilc;
+
+	vif = netdev_priv(dev);
+	wilc = vif->wilc;
+
+	spin_lock_irqsave(&wilc->txq_spinlock, flags);
+
+	if (!wilc->txq[q_num].txq_head) {
+		tqe->next = NULL;
+		tqe->prev = NULL;
+		wilc->txq[q_num].txq_head = tqe;
+		wilc->txq[q_num].txq_tail= tqe;
+	} else {
+		tqe->next = NULL;
+		tqe->prev = wilc->txq[q_num].txq_tail;
+		wilc->txq[q_num].txq_tail->next = tqe;
+		wilc->txq[q_num].txq_tail = tqe;
+	}
+	wilc->txq_entries += 1;
+	wilc->txq[q_num].count++;
+	PRINT_INFO(vif->ndev, TX_DBG, "Number of entries in TxQ = %d\n",
+		   wilc->txq_entries);
+
+	spin_unlock_irqrestore(&wilc->txq_spinlock, flags);
+
+	PRINT_INFO(vif->ndev, TX_DBG, "Wake the txq_handling\n");
+	complete(&wilc->txq_event);
+}
+
+static int wilc_wlan_txq_add_to_head(struct wilc_vif *vif, u8 q_num,
+				     struct txq_entry_t *tqe)
+{
+	unsigned long flags;
+	struct wilc *wilc = vif->wilc;
+
+	mutex_lock(&wilc->txq_add_to_head_cs);
+
+	spin_lock_irqsave(&wilc->txq_spinlock, flags);
+
+	if (!wilc->txq[q_num].txq_head) {
+		tqe->next = NULL;
+		tqe->prev = NULL;
+		wilc->txq[q_num].txq_head = tqe;
+		wilc->txq[q_num].txq_tail = tqe;
+	} else {
+		tqe->next = wilc->txq[q_num].txq_head;
+		tqe->prev = NULL;
+		wilc->txq[q_num].txq_head->prev = tqe;
+		wilc->txq[q_num].txq_head = tqe;
+	}
+	wilc->txq_entries += 1;
+	wilc->txq[q_num].count++;
+	PRINT_INFO(vif->ndev, TX_DBG,"Number of entries in TxQ = %d\n",wilc->txq_entries);
+
+	spin_unlock_irqrestore(&wilc->txq_spinlock, flags);
+	mutex_unlock(&wilc->txq_add_to_head_cs);
+	complete(&wilc->txq_event);
+	PRINT_INFO(vif->ndev, TX_DBG, "Wake up the txq_handler\n");
+
+	return 0;
+}
+
+struct ack_session_info;
+struct ack_session_info {
+	u32 seq_num;
+	u32 bigger_ack_num;
+	u16 src_port;
+	u16 dst_port;
+	u16 status;
+};
+
+struct pending_acks_info {
+	u32 ack_num;
+	u32 session_index;
+	struct txq_entry_t  *txqe;
+};
+
+#define NOT_TCP_ACK			(-1)
+
+#define MAX_TCP_SESSION		25
+#define MAX_PENDING_ACKS		256
+static struct ack_session_info ack_session_info[2 * MAX_TCP_SESSION];
+static struct pending_acks_info pending_acks_info[MAX_PENDING_ACKS];
+
+static u32 pending_base;
+static u32 tcp_session;
+static u32 pending_acks;
+
+static inline int add_tcp_session(struct wilc_vif *vif, u32 src_prt,
+				  u32 dst_prt, u32 seq)
+{
+	if (tcp_session < 2 * MAX_TCP_SESSION) {
+		ack_session_info[tcp_session].seq_num = seq;
+		ack_session_info[tcp_session].bigger_ack_num = 0;
+		ack_session_info[tcp_session].src_port = src_prt;
+		ack_session_info[tcp_session].dst_port = dst_prt;
+		tcp_session++;
+		PRINT_INFO(vif->ndev, TCP_ENH, "TCP Session %d to Ack %d\n",
+			   tcp_session, seq);
+	}
+	return 0;
+}
+
+static inline int update_tcp_session(struct wilc_vif *vif, u32 index, u32 ack)
+{
+	if (index < 2 * MAX_TCP_SESSION &&
+	    ack > ack_session_info[index].bigger_ack_num)
+		ack_session_info[index].bigger_ack_num = ack;
+	return 0;
+}
+
+static inline int add_tcp_pending_ack(struct wilc_vif *vif, u32 ack,
+				      u32 session_index,
+				      struct txq_entry_t *txqe)
+{
+	u32 i = pending_base + pending_acks;
+
+	if (i < MAX_PENDING_ACKS) {
+		pending_acks_info[i].ack_num = ack;
+		pending_acks_info[i].txqe = txqe;
+		pending_acks_info[i].session_index = session_index;
+		txqe->tcp_pending_ack_idx = i;
+		pending_acks++;
+	}
+	return 0;
+}
+
+static inline void tcp_process(struct net_device *dev, struct txq_entry_t *tqe)
+{
+	u8 *eth_hdr_ptr;
+	u8 *buffer = tqe->buffer;
+	unsigned short h_proto;
+	int i;
+	unsigned long flags;
+	struct wilc_vif *vif;
+	struct wilc *wilc;
+
+	vif = netdev_priv(dev);
+	wilc = vif->wilc;
+
+	spin_lock_irqsave(&wilc->txq_spinlock, flags);
+
+	eth_hdr_ptr = &buffer[0];
+	h_proto = ntohs(*((unsigned short *)&eth_hdr_ptr[12]));
+	if (h_proto == ETH_P_IP) {
+		u8 *ip_hdr_ptr;
+		u8 protocol;
+
+		ip_hdr_ptr = &buffer[ETHERNET_HDR_LEN];
+		protocol = ip_hdr_ptr[9];
+
+		if (protocol == 0x06) {
+			u8 *tcp_hdr_ptr;
+			u32 IHL, total_length, data_offset;
+
+			tcp_hdr_ptr = &ip_hdr_ptr[IP_HDR_LEN];
+			IHL = (ip_hdr_ptr[0] & 0xf) << 2;
+			total_length = ((u32)ip_hdr_ptr[2] << 8) +
+					(u32)ip_hdr_ptr[3];
+			data_offset = ((u32)tcp_hdr_ptr[12] & 0xf0) >> 2;
+			if (total_length == (IHL + data_offset)) {
+				u32 seq_no, ack_no;
+
+				seq_no = ((u32)tcp_hdr_ptr[4] << 24) +
+					 ((u32)tcp_hdr_ptr[5] << 16) +
+					 ((u32)tcp_hdr_ptr[6] << 8) +
+					 (u32)tcp_hdr_ptr[7];
+
+				ack_no = ((u32)tcp_hdr_ptr[8] << 24) +
+					 ((u32)tcp_hdr_ptr[9] << 16) +
+					 ((u32)tcp_hdr_ptr[10] << 8) +
+					 (u32)tcp_hdr_ptr[11];
+
+				for (i = 0; i < tcp_session; i++) {
+					u32 j = ack_session_info[i].seq_num;
+
+					if (i < 2 * MAX_TCP_SESSION &&
+					    j == seq_no) {
+						update_tcp_session(vif, i,
+								   ack_no);
+						break;
+					}
+				}
+				if (i == tcp_session)
+					add_tcp_session(vif, 0, 0, seq_no);
+
+				add_tcp_pending_ack(vif, ack_no, i, tqe);
+			}
+		}
+	}
+	spin_unlock_irqrestore(&wilc->txq_spinlock, flags);
+}
+
+static int wilc_wlan_txq_filter_dup_tcp_ack(struct net_device *dev)
+{
+	struct wilc_vif *vif;
+	struct wilc *wilc;
+	u32 i = 0;
+	u32 dropped = 0;
+
+	vif = netdev_priv(dev);
+	wilc = vif->wilc;
+
+	spin_lock_irqsave(&wilc->txq_spinlock, wilc->txq_spinlock_flags);
+	for (i = pending_base; i < (pending_base + pending_acks); i++) {
+		u32 session_index;
+		u32 bigger_ack_num;
+
+		if (i >= MAX_PENDING_ACKS)
+			break;
+
+		session_index = pending_acks_info[i].session_index;
+
+		if (session_index >= 2 * MAX_TCP_SESSION)
+			break;
+
+		bigger_ack_num = ack_session_info[session_index].bigger_ack_num;
+
+		if (pending_acks_info[i].ack_num < bigger_ack_num) {
+			struct txq_entry_t *tqe;
+
+			PRINT_INFO(vif->ndev, TCP_ENH, "DROP ACK: %u\n",
+				   pending_acks_info[i].ack_num);
+			tqe = pending_acks_info[i].txqe;
+			if (tqe) {
+				wilc_wlan_txq_remove(wilc, tqe->q_num, tqe);
+				tqe->status = 1;
+				if (tqe->tx_complete_func)
+					tqe->tx_complete_func(tqe->priv,
+							      tqe->status);
+				kfree(tqe);
+				dropped++;
+			}
+		}
+	}
+	pending_acks = 0;
+	tcp_session = 0;
+
+	if (pending_base == 0)
+		pending_base = MAX_TCP_SESSION;
+	else
+		pending_base = 0;
+
+	spin_unlock_irqrestore(&wilc->txq_spinlock, wilc->txq_spinlock_flags);
+
+	while (dropped > 0) {
+		if(!wait_for_completion_timeout(&wilc->txq_event,
+						msecs_to_jiffies(1)))
+			PRINT_ER(vif->ndev, "completion timedout\n");
+		dropped--;
+	}
+
+	return 1;
+}
+
+static bool ack_filter_enabled;
+
+void wilc_enable_tcp_ack_filter(bool value)
+{
+	ack_filter_enabled = value;
+}
+
+static int wilc_wlan_txq_add_cfg_pkt(struct wilc_vif *vif, u8 *buffer,
+				     u32 buffer_size)
+{
+	struct txq_entry_t *tqe;
+	struct wilc *wilc = vif->wilc;
+
+	PRINT_INFO(vif->ndev, TX_DBG, "Adding config packet ...\n");
+	if (wilc->quit) {
+		PRINT_INFO(vif->ndev, TX_DBG, "Return due to clear function\n");
+		complete(&wilc->cfg_event);
+		return 0;
+	}
+
+	if (!(wilc->initialized)) {
+		PRINT_INFO(vif->ndev, TX_DBG, "wilc not initialized\n");
+		complete(&wilc->cfg_event);
+		return 0;
+	}
+	tqe = kmalloc(sizeof(*tqe), GFP_KERNEL);
+	if (!tqe) {
+		complete(&wilc->cfg_event);
+		return 0;
+	}
+	tqe->type = WILC_CFG_PKT;
+	tqe->buffer = buffer;
+	tqe->buffer_size = buffer_size;
+	tqe->tx_complete_func = NULL;
+	tqe->priv = NULL;
+	tqe->q_num = AC_VO_Q;
+	tqe->tcp_pending_ack_idx = NOT_TCP_ACK;
+
+	PRINT_INFO(vif->ndev, TX_DBG,
+		   "Adding the config packet at the Queue tail\n");
+
+	if (wilc_wlan_txq_add_to_head(vif, AC_VO_Q, tqe)) {
+		complete(&wilc->cfg_event);
+		kfree(tqe);
+		return 0;
+	}
+
+	return 1;
+}
+
+static void ac_q_limit(struct wilc *wilc, u8 ac, u16 *q_limit)
+{
+	static u8 buffer[AC_BUFFER_SIZE];
+	static u16 end_index;
+	static bool initialized;
+	static u16 cnt[NQUEUES];
+	u8 factors[NQUEUES] = {1, 1, 1, 1};
+	static u16 sum;
+	u16 i;
+
+	spin_lock_irqsave(&wilc->txq_spinlock, wilc->txq_spinlock_flags);
+	if (!initialized) {
+		for (i = 0; i < AC_BUFFER_SIZE; i++)
+			buffer[i] = i % NQUEUES;
+
+		for (i = 0; i < NQUEUES; i++) {
+			cnt[i] = AC_BUFFER_SIZE * factors[i] / NQUEUES;
+			sum += cnt[i];
+		}
+		end_index = AC_BUFFER_SIZE - 1;
+		initialized = 1;
+	}
+
+	cnt[buffer[end_index]] -= factors[buffer[end_index]];
+	cnt[ac] += factors[ac];
+	sum += (factors[ac] - factors[buffer[end_index]]);
+
+	buffer[end_index] = ac;
+	if (end_index > 0)
+		end_index--;
+	else
+		end_index = AC_BUFFER_SIZE - 1;
+
+	for (i = 0; i < NQUEUES; i++){
+		if(!sum)
+			q_limit[i] = 1;
+		else
+			q_limit[i] = (cnt[i] * FLOW_CONTROL_UPPER_THRESHOLD / sum) + 1;
+	}
+	spin_unlock_irqrestore(&wilc->txq_spinlock, wilc->txq_spinlock_flags);
+	return;
+}
+
+static inline u8 ac_classify(struct wilc *wilc, struct txq_entry_t *tqe)
+{
+	u8 *eth_hdr_ptr;
+	u8 *buffer = tqe->buffer;
+	u8 ac;
+	u16 h_proto;
+
+	spin_lock_irqsave(&wilc->txq_spinlock, wilc->txq_spinlock_flags);
+
+	eth_hdr_ptr = &buffer[0];
+	h_proto = ntohs(*((unsigned short *)&eth_hdr_ptr[12]));
+	if (h_proto == ETH_P_IP) {
+		u8 *ip_hdr_ptr;
+		u32 IHL, DSCP;
+
+		ip_hdr_ptr = &buffer[ETHERNET_HDR_LEN];
+		IHL = (ip_hdr_ptr[0] & 0xf) << 2;
+		DSCP = (ip_hdr_ptr[1] & 0xfc);
+
+		switch (DSCP) {
+		case 0x20:
+		case 0x40:
+		case 0x08:
+			ac = AC_BK_Q;
+			break;
+		case 0x80:
+		case 0xA0:
+		case 0x28:
+			ac = AC_VI_Q;
+			break;
+		case 0xC0:
+		case 0xd0:
+		case 0xE0:
+		case 0x88:
+		case 0xB8:
+			ac = AC_VO_Q;
+			break;
+		default:
+			ac = AC_BE_Q;
+			break;
+		}
+	} else {
+		ac  = AC_BE_Q;
+	}
+
+	tqe->q_num = ac;
+	spin_unlock_irqrestore(&wilc->txq_spinlock, wilc->txq_spinlock_flags);
+
+	return ac;
+}
+
+static inline int ac_balance(u8 *count, u8 *ratio)
+{
+	u8 i, max_count = 0;
+
+	if (!count || !ratio)
+		return -1;
+
+	for (i = 0; i < NQUEUES; i++)
+		if (count[i] > max_count)
+			max_count = count[i];
+
+	for (i = 0; i < NQUEUES; i++)
+		ratio[i] = max_count - count[i];
+
+	return 0;
+}
+
+static inline void ac_pkt_count(u32 reg, u8 *pkt_count)
+{
+	pkt_count[AC_BK_Q] = (reg & 0x000000fa) >> BK_AC_COUNT_POS;
+	pkt_count[AC_BE_Q] = (reg & 0x0000fe00) >> BE_AC_COUNT_POS;
+	pkt_count[AC_VI_Q] = (reg & 0x00fe0000) >> VI_AC_COUNT_POS;
+	pkt_count[AC_VO_Q] = (reg & 0xfe000000) >> VO_AC_COUNT_POS;
+}
+
+static inline u8 ac_change(struct wilc *wilc, u8 *ac)
+{
+	do {
+		if (wilc->txq[*ac].acm == 0)
+			return 0;
+		(*ac)++;
+	} while (*ac < NQUEUES);
+	return 1;
+}
+
+static inline void ac_acm_bit(struct wilc *wilc, u32 reg)
+{
+	wilc->txq[AC_BK_Q].acm = (reg & 0x00000002) >> BK_AC_ACM_STAT_POS;
+	wilc->txq[AC_BE_Q].acm = (reg & 0x00000100) >> BE_AC_ACM_STAT_POS;
+	wilc->txq[AC_VI_Q].acm = (reg & 0x00010000) >> VI_AC_ACM_STAT_POS;
+	wilc->txq[AC_VO_Q].acm = (reg & 0x01000000) >> VO_AC_ACM_STAT_POS;
+}
+
+int wilc_wlan_txq_add_net_pkt(struct net_device *dev, void *priv, u8 *buffer,
+			      u32 buffer_size, wilc_tx_complete_func_t func)
+{
+	struct txq_entry_t *tqe;
+	struct wilc_vif *vif = netdev_priv(dev);
+	struct wilc *wilc;
+	u8 q_num;
+	u16 q_limit[NQUEUES] = {0, 0, 0, 0};
+
+	if(!vif){
+		pr_info("%s vif is NULL\n", __func__);
+		return -1;
+	}
+
+	wilc = vif->wilc;
+
+	if (wilc->quit) {
+		PRINT_INFO(vif->ndev, TX_DBG,
+			   "drv is quitting, return from net_pkt\n");
+		func(priv, 0);
+		return 0;
+	}
+
+	if (!(wilc->initialized)) {
+		PRINT_INFO(vif->ndev, TX_DBG,
+			   "not_init, return from net_pkt\n");
+		func(priv, 0);
+		return 0;
+	}
+
+	tqe = kmalloc(sizeof(*tqe), GFP_KERNEL);
+
+	if (!tqe) {
+		PRINT_INFO(vif->ndev, TX_DBG,
+			   "malloc failed, return from net_pkt\n");
+		func(priv, 0);
+		return 0;
+	}
+	tqe->type = WILC_NET_PKT;
+	tqe->buffer = buffer;
+	tqe->buffer_size = buffer_size;
+	tqe->tx_complete_func = func;
+	tqe->priv = priv;
+
+	q_num = ac_classify(wilc, tqe);
+	if (ac_change(wilc, &q_num)) {
+		PRINT_INFO(vif->ndev, GENERIC_DBG,
+			   "No suitable non-ACM queue\n");
+		kfree(tqe);
+		return 0;
+	}
+	ac_q_limit(wilc, q_num, q_limit);
+
+	if ((q_num == AC_VO_Q && wilc->txq[q_num].count <= q_limit[AC_VO_Q]) ||
+	    (q_num == AC_VI_Q && wilc->txq[q_num].count <= q_limit[AC_VI_Q]) ||
+	    (q_num == AC_BE_Q && wilc->txq[q_num].count <= q_limit[AC_BE_Q]) ||
+	    (q_num == AC_BK_Q && wilc->txq[q_num].count <= q_limit[AC_BK_Q])) {
+		PRINT_INFO(vif->ndev, TX_DBG,
+			   "Adding mgmt packet at the Queue tail\n");
+		tqe->tcp_pending_ack_idx = NOT_TCP_ACK;
+		if (ack_filter_enabled)
+			tcp_process(dev, tqe);
+		wilc_wlan_txq_add_to_tail(dev, q_num, tqe);
+	} else {
+		tqe->status = 0;
+		if (tqe->tx_complete_func)
+			tqe->tx_complete_func(tqe->priv, tqe->status);
+		kfree(tqe);
+	}
+
+	return wilc->txq_entries;
+}
+
+int wilc_wlan_txq_add_mgmt_pkt(struct net_device *dev, void *priv, u8 *buffer,
+			       u32 buffer_size, wilc_tx_complete_func_t func)
+{
+	struct txq_entry_t *tqe;
+	struct wilc_vif *vif = netdev_priv(dev);
+	struct wilc *wilc;
+
+	wilc = vif->wilc;
+
+	if (wilc->quit) {
+		PRINT_INFO(vif->ndev, TX_DBG, "drv is quitting\n");
+		func(priv, 0);
+		return 0;
+	}
+
+	if (!(wilc->initialized)) {
+		PRINT_INFO(vif->ndev, TX_DBG, "wilc not_init\n");
+		func(priv, 0);
+		return 0;
+	}
+	tqe = kmalloc(sizeof(*tqe), GFP_KERNEL);
+
+	if (!tqe) {
+		PRINT_INFO(vif->ndev, TX_DBG, "Queue malloc failed\n");
+		func(priv, 0);
+		return 0;
+	}
+	tqe->type = WILC_MGMT_PKT;
+	tqe->buffer = buffer;
+	tqe->buffer_size = buffer_size;
+	tqe->tx_complete_func = func;
+	tqe->priv = priv;
+	tqe->q_num = AC_BE_Q;
+	tqe->tcp_pending_ack_idx = NOT_TCP_ACK;
+
+	PRINT_INFO(vif->ndev, TX_DBG, "Adding Mgmt packet to Queue tail\n");
+	wilc_wlan_txq_add_to_tail(dev, AC_BE_Q, tqe);
+	return 1;
+}
+
+static struct txq_entry_t *wilc_wlan_txq_get_first(struct wilc *wilc, u8 q_num)
+{
+	struct txq_entry_t *tqe;
+	unsigned long flags;
+
+	spin_lock_irqsave(&wilc->txq_spinlock, flags);
+
+	tqe = wilc->txq[q_num].txq_head;
+
+	spin_unlock_irqrestore(&wilc->txq_spinlock, flags);
+
+	return tqe;
+}
+
+static struct txq_entry_t *wilc_wlan_txq_get_next(struct wilc *wilc,
+						  struct txq_entry_t *tqe)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&wilc->txq_spinlock, flags);
+
+	tqe = tqe->next;
+	spin_unlock_irqrestore(&wilc->txq_spinlock, flags);
+
+	return tqe;
+}
+
+static int wilc_wlan_rxq_add(struct wilc *wilc, struct rxq_entry_t *rqe)
+{
+	struct wilc_vif *vif = wilc->vif[0];
+	
+	if (wilc->quit)
+		return 0;
+
+	mutex_lock(&wilc->rxq_cs);
+	if (!wilc->rxq_head) {
+		PRINT_INFO(vif->ndev, RX_DBG,"Add to Queue head\n");
+		rqe->next = NULL;
+		wilc->rxq_head = rqe;
+		wilc->rxq_tail = rqe;
+	} else {
+		PRINT_INFO(vif->ndev, RX_DBG,"Add to Queue tail\n");
+		wilc->rxq_tail->next = rqe;
+		rqe->next = NULL;
+		wilc->rxq_tail = rqe;
+	}
+	wilc->rxq_entries += 1;
+	PRINT_INFO(vif->ndev, RX_DBG,"Number of queue entries: %d\n",
+		   wilc->rxq_entries);
+	mutex_unlock(&wilc->rxq_cs);
+	return wilc->rxq_entries;
+}
+
+static struct rxq_entry_t *wilc_wlan_rxq_remove(struct wilc *wilc)
+{
+	struct wilc_vif *vif = wilc->vif[0];
+	
+	PRINT_INFO(vif->ndev, RX_DBG,"Getting rxQ element\n");
+	if (wilc->rxq_head) {
+		struct rxq_entry_t *rqe;
+
+		mutex_lock(&wilc->rxq_cs);
+		rqe = wilc->rxq_head;
+		wilc->rxq_head = wilc->rxq_head->next;
+		wilc->rxq_entries -= 1;
+		PRINT_INFO(vif->ndev, RX_DBG,"RXQ entries decreased\n");
+		mutex_unlock(&wilc->rxq_cs);
+		return rqe;
+	}
+	PRINT_INFO(vif->ndev, RX_DBG,"Nothing to get from Q\n");
+	return NULL;
+}
+
+void chip_allow_sleep(struct wilc *wilc, int source)
+{
+	u32 reg = 0;
+
+	if (((source == PWR_DEV_SRC_WIFI) &&
+	    (wilc->keep_awake[PWR_DEV_SRC_BT] == true)) ||
+	    ((source == PWR_DEV_SRC_BT) &&
+	    (wilc->keep_awake[PWR_DEV_SRC_WIFI] == true))) {
+		pr_warn("Another device is preventing allow sleep operation. request source is %s\n",
+			  (source == PWR_DEV_SRC_WIFI ? "Wifi" : "BT"));
+	} else {
+		int ret;
+		if(wilc->chip == WILC_1000) {
+			u32 wakeup_reg, wakeup_bit;
+			u32 to_host_from_fw_reg, to_host_from_fw_bit;
+			u32 from_host_to_fw_reg, from_host_to_fw_bit;
+			u32 trials =100;
+			
+			if(wilc->io_type == HIF_SDIO ||
+				wilc->io_type == HIF_SDIO_GPIO_IRQ) {
+				wakeup_reg = 0xf0;
+				wakeup_bit = BIT(0);
+				from_host_to_fw_reg = 0xfa;
+				from_host_to_fw_bit = BIT(0);
+				to_host_from_fw_reg = 0xfc;
+				to_host_from_fw_bit = BIT(0);		
+			} else {
+				wakeup_reg = 0x1;
+				wakeup_bit = BIT(1);
+				from_host_to_fw_reg = 0x0b;
+				from_host_to_fw_bit = BIT(0);
+				to_host_from_fw_reg = 0xfc;
+				to_host_from_fw_bit = BIT(0);
+			}
+
+			while(trials--){
+				ret = wilc->hif_func->hif_read_reg(wilc, to_host_from_fw_reg,&reg);
+				if(!ret) goto _fail_;
+				if((reg & to_host_from_fw_bit) == 0)
+					break;	
+			}
+			if(!trials)
+				pr_warn("FW not responding\n");
+
+			/* Clear bit 1 */
+			ret = wilc->hif_func->hif_read_reg(wilc, wakeup_reg, &reg);
+			if(!ret) goto _fail_;
+			if(reg & wakeup_bit)
+			{
+				reg &=~wakeup_bit;
+				ret = wilc->hif_func->hif_write_reg(wilc, wakeup_reg, reg);
+				if(!ret) goto _fail_;
+			}
+
+			ret = wilc->hif_func->hif_read_reg(wilc, from_host_to_fw_reg, &reg);
+			if(!ret) goto _fail_;
+			if(reg & from_host_to_fw_bit)
+			{
+				reg &= ~from_host_to_fw_bit;
+				ret = wilc->hif_func->hif_write_reg(wilc, from_host_to_fw_reg, reg);
+				if(!ret) goto _fail_;
+			}
+		} else {
+			if(wilc->io_type == HIF_SDIO ||
+				wilc->io_type == HIF_SDIO_GPIO_IRQ) {
+				wilc->hif_func->hif_read_reg(wilc, 0xf0, &reg);
+				wilc->hif_func->hif_write_reg(wilc, 0xf0, reg & ~BIT(0));
+			} else {
+				wilc->hif_func->hif_read_reg(wilc, 0x1, &reg);
+				wilc->hif_func->hif_write_reg(wilc, 0x1, reg & ~BIT(1));
+			}
+		}
+	}
+
+	wilc->keep_awake[source] = false;
+_fail_:
+	return;
+}
+
+void chip_wakeup_wilc1000(struct wilc *wilc, int source)
+{
+	u32 ret = 0;
+	u32 reg = 0, clk_status_val = 0, trials = 0;
+	u32 wakeup_reg, wakeup_bit;
+	u32 clk_status_reg, clk_status_bit;
+	u32 to_host_from_fw_reg, to_host_from_fw_bit;
+	u32 from_host_to_fw_reg, from_host_to_fw_bit;
+	
+	if(wilc->io_type == HIF_SDIO ||
+		wilc->io_type == HIF_SDIO_GPIO_IRQ) {
+		wakeup_reg = 0xf0;
+		clk_status_reg = 0xf1;
+		wakeup_bit = BIT(0);
+		clk_status_bit = BIT(0);
+		from_host_to_fw_reg = 0xfa;
+		from_host_to_fw_bit = BIT(0);
+		to_host_from_fw_reg = 0xfc;
+		to_host_from_fw_bit = BIT(0);		
+	} else {
+		wakeup_reg = 0x1;
+		clk_status_reg = 0x0f;
+		wakeup_bit = BIT(1);
+		clk_status_bit = BIT(2);
+		from_host_to_fw_reg = 0x0b;
+		from_host_to_fw_bit = BIT(0);
+		to_host_from_fw_reg = 0xfc;
+		to_host_from_fw_bit = BIT(0);
+	}
+
+	ret = wilc->hif_func->hif_read_reg(wilc, from_host_to_fw_reg, &reg);
+	if(!ret) goto _fail_;
+	
+	if(!(reg & from_host_to_fw_bit)) {
+		/*USE bit 0 to indicate host wakeup*/
+		ret = wilc->hif_func->hif_write_reg(wilc, from_host_to_fw_reg, reg|from_host_to_fw_bit);
+		if(!ret) goto _fail_;
+	}
+	
+	ret = wilc->hif_func->hif_read_reg(wilc, wakeup_reg, &reg);
+	if(!ret) goto _fail_;
+	/* Set bit 1 */
+	if(!(reg & wakeup_bit)) {
+		ret = wilc->hif_func->hif_write_reg(wilc, wakeup_reg, reg | wakeup_bit);
+		if(!ret) goto _fail_;	
+	}
+
+	do {
+		ret = wilc->hif_func->hif_read_reg(wilc, clk_status_reg, &clk_status_val);
+		if(!ret) {
+			pr_err("Bus error (5).%d %x\n",ret,clk_status_val);
+			goto _fail_;
+		}
+		if(clk_status_val & clk_status_bit) {
+			break;
+		}
+		//nm_bsp_sleep(2);
+		trials++;
+		if(trials > WAKUP_TRAILS_TIMEOUT) {
+			pr_err("Failed to wakup the chip\n");
+			ret = -1;
+			goto _fail_;
+		}
+	} while(1);
+
+	if(wilc_get_chipid(wilc, false) < 0x1002b0) {
+		uint32_t val32;
+		/* Enable PALDO back right after wakeup */
+		wilc->hif_func->hif_read_reg(wilc, 0x1e1c , &val32);
+		val32 |= BIT(6);
+		wilc->hif_func->hif_write_reg(wilc, 0x1e1c , val32);
+
+		wilc->hif_func->hif_read_reg(wilc, 0x1e9c , &val32);
+		val32 |= BIT(6);
+		wilc->hif_func->hif_write_reg(wilc, 0x1e9c , val32);
+	}
+	/*workaround sometimes spi fail to read clock regs after reading/writing clockless registers*/
+	reset_bus(wilc);
+
+_fail_:
+	return;
+}
+
+void chip_wakeup_wilc3000(struct wilc *wilc, int source)
+{
+	u32 wakeup_reg_val, clk_status_reg_val, trials = 0;
+	u32 wakeup_register, wakeup_bit;
+	u32 clk_status_register, clk_status_bit;
+	int wake_seq_trials = 5;
+
+	if(wilc->io_type == HIF_SDIO ||
+		wilc->io_type == HIF_SDIO_GPIO_IRQ) {
+		wakeup_register = 0xf0;
+		clk_status_register = 0xf0;
+		wakeup_bit = BIT(0);
+		clk_status_bit = BIT(4);
+	} else {
+		wakeup_register = 0x1;
+		clk_status_register = 0x13;
+		wakeup_bit = BIT(1);
+		clk_status_bit = BIT(2);
+	}
+		
+	wilc->hif_func->hif_read_reg(wilc, wakeup_register, &wakeup_reg_val);
+	do {
+		wilc->hif_func->hif_write_reg(wilc, wakeup_register, wakeup_reg_val | wakeup_bit);
+		/* Check the clock status */
+		wilc->hif_func->hif_read_reg(wilc, clk_status_register, &clk_status_reg_val);
+
+		/*
+		 * in case of clocks off, wait 1ms, and check it again.
+		 * if still off, wait for another 1ms, for a total wait of 3ms.
+		 * If still off, redo the wake up sequence
+		 */
+		while (((clk_status_reg_val & clk_status_bit) == 0) &&
+		       (((++trials) % 3) == 0)) {
+			/* Wait for the chip to stabilize*/
+			usleep_range(1000, 1000);
+
+			/*
+			 * Make sure chip is awake. This is an extra step that can be removed
+			 * later to avoid the bus access overhead
+			 * g_wlan.hif_func.hif_read_reg(0xf0, &clk_status_reg_val);
+			 */
+			wilc->hif_func->hif_read_reg(wilc, clk_status_register,
+						      &clk_status_reg_val);
+
+		}
+		/* in case of failure, Reset the wakeup bit to introduce a new edge on the next loop */
+		if ((clk_status_reg_val & clk_status_bit) == 0) {
+			dev_warn(wilc->dev, "clocks still OFF. Retrying\n");
+			wilc->hif_func->hif_write_reg(wilc, wakeup_register,
+						      wakeup_reg_val & (~wakeup_bit));
+		}
+	} while (((clk_status_reg_val & clk_status_bit) == 0)
+		 && (wake_seq_trials-- > 0));
+	if(!wake_seq_trials)
+		dev_err(wilc->dev, "clocks still OFF. Wake up failed\n");
+	wilc->keep_awake[source] = true;
+}
+
+void chip_wakeup(struct wilc *wilc, int source)
+{
+	if(wilc->chip == WILC_1000)
+		chip_wakeup_wilc1000(wilc, source);
+	else
+		chip_wakeup_wilc3000(wilc, source);
+}
+
+void host_wakeup_notify(struct wilc *wilc, int source)
+{
+	acquire_bus(wilc, ACQUIRE_ONLY,source);
+	if (wilc->chip == WILC_1000)
+		wilc->hif_func->hif_write_reg(wilc, 0x10b0, 1);
+	else
+		wilc->hif_func->hif_write_reg(wilc, 0x10c0, 1);
+	release_bus(wilc, RELEASE_ONLY, source);
+}
+
+void host_sleep_notify(struct wilc *wilc, int source)
+{
+	acquire_bus(wilc, ACQUIRE_ONLY,source);
+	if (wilc->chip == WILC_1000)
+		wilc->hif_func->hif_write_reg(wilc, 0x10ac, 1);
+	else
+		wilc->hif_func->hif_write_reg(wilc, 0x10bc, 1);
+	release_bus(wilc, RELEASE_ONLY,source);
+}
+
+static u8 ac_fw_count[NQUEUES] = {0, 0, 0, 0};
+int wilc_wlan_handle_txq(struct net_device *dev, u32 *txq_count)
+{
+	int i, entries = 0;
+	u8 k, ac;
+	u32 sum;
+	u32 reg;
+	u8 ac_desired_ratio[NQUEUES] = {0, 0, 0, 0};
+	u8 ac_preserve_ratio[NQUEUES] = {1, 1, 1, 1};
+	u8 *num_pkts_to_add;
+	u8 vmm_entries_ac[WILC_VMM_TBL_SIZE];
+	u8 *txb;
+	u32 offset = 0;
+	bool max_size_over = 0, ac_exist = 0;
+	int vmm_sz = 0;
+	struct txq_entry_t *tqe_q[NQUEUES];
+	int ret = 0;
+	int counter;
+	int timeout;
+	u32 vmm_table[WILC_VMM_TBL_SIZE];
+	u8 ac_pkt_num_to_chip[NQUEUES] = {0, 0, 0, 0};
+	struct wilc_vif *vif;
+	struct wilc *wilc;
+	const struct wilc_hif_func *func;
+
+	vif = netdev_priv(dev);
+	wilc = vif->wilc;
+
+	txb = wilc->tx_buffer;
+	wilc->txq_exit = 0;
+	if (!wilc->txq_entries) {
+		wilc->txq_exit = 1;
+		*txq_count = 0;
+		return 0;
+	}
+
+	if (wilc->quit)
+		goto out;
+	if (ac_balance(ac_fw_count, ac_desired_ratio))
+		return -1;
+	
+	mutex_lock(&wilc->txq_add_to_head_cs);
+	wilc_wlan_txq_filter_dup_tcp_ack(dev);
+
+	PRINT_INFO(vif->ndev, TX_DBG,"Getting the head of the TxQ\n");
+	for(ac = 0; ac < NQUEUES; ac++)
+		tqe_q[ac] = wilc_wlan_txq_get_first(wilc, ac);
+	i = 0;
+	sum = 0;
+	max_size_over = 0;
+	num_pkts_to_add = ac_desired_ratio;
+	do {
+		ac_exist = 0;
+		for(ac = 0; (ac < NQUEUES) && (!max_size_over); ac++) {
+			if (tqe_q[ac]) {
+				ac_exist = 1;
+				for(k = 0; (k < num_pkts_to_add[ac]) && (!max_size_over) && tqe_q[ac]; k++) {
+					if (i < (WILC_VMM_TBL_SIZE - 1)) {
+						if (tqe_q[ac]->type == WILC_CFG_PKT)
+							vmm_sz = ETH_CONFIG_PKT_HDR_OFFSET;
+						else if (tqe_q[ac]->type == WILC_NET_PKT)
+							vmm_sz = ETH_ETHERNET_HDR_OFFSET;
+						else
+							vmm_sz = HOST_HDR_OFFSET;
+
+						vmm_sz += tqe_q[ac]->buffer_size;
+						PRINT_INFO(vif->ndev, TX_DBG,"VMM Size before alignment = %d\n",vmm_sz);
+						if (vmm_sz & 0x3)
+							vmm_sz = (vmm_sz + 4) & ~0x3;
+
+						if ((sum + vmm_sz) > LINUX_TX_SIZE) {
+							max_size_over = 1;
+							break;
+						}
+						PRINT_INFO(vif->ndev, TX_DBG,"VMM Size AFTER alignment = %d\n",vmm_sz);
+						vmm_table[i] = vmm_sz / 4;
+						PRINT_INFO(vif->ndev, TX_DBG,"VMMTable entry size = %d\n",vmm_table[i]);
+						if (tqe_q[ac]->type == WILC_CFG_PKT) {
+							vmm_table[i] |= BIT(10);
+							PRINT_INFO(vif->ndev, TX_DBG,"VMMTable entry changed for CFG packet = %d\n",vmm_table[i]);
+						}
+						vmm_table[i] = cpu_to_le32(vmm_table[i]);
+						vmm_entries_ac[i] = ac;
+
+						i++;
+						sum += vmm_sz;
+						PRINT_INFO(vif->ndev, TX_DBG,"sum = %d\n",sum);
+						tqe_q[ac] = wilc_wlan_txq_get_next(wilc, tqe_q[ac]);
+					} else {
+						max_size_over = 1;
+						break;
+					}
+				}
+			}
+		}
+		num_pkts_to_add = ac_preserve_ratio;
+	} while (!max_size_over && ac_exist);
+
+	if (i == 0) {
+		PRINT_INFO(vif->ndev, TX_DBG,"Nothing in TX-Q\n");
+		goto out;
+	} 
+	vmm_table[i] = 0x0;
+
+	acquire_bus(wilc, ACQUIRE_AND_WAKEUP, PWR_DEV_SRC_WIFI);
+	counter = 0;
+	func = wilc->hif_func;
+	do {
+		ret = func->hif_read_reg(wilc, WILC_HOST_TX_CTRL, &reg);
+		if (!ret) {
+			PRINT_ER(vif->ndev, "fail read reg vmm_tbl_entry..\n");
+			break;
+		}
+		if ((reg & 0x1) == 0){
+			ac_pkt_count(reg, ac_fw_count);
+			ac_acm_bit(wilc, reg);
+			break;
+		}
+
+		counter++;
+		if (counter > 200) {
+			counter = 0;
+			PRINT_INFO(vif->ndev, TX_DBG,
+				    "Looping in tx ctrl , force quit\n");
+			ret = func->hif_write_reg(wilc, WILC_HOST_TX_CTRL, 0);
+			break;
+		}
+	} while (!wilc->quit);
+
+	if (!ret)
+		goto out_release_bus;
+
+	timeout = 200;
+	do {
+		ret = func->hif_block_tx(wilc,
+					 WILC_VMM_TBL_RX_SHADOW_BASE,
+					 (u8 *)vmm_table,
+					 ((i + 1) * 4));
+		if (!ret) {
+			PRINT_ER(vif->ndev, "ERR block TX of VMM table.\n");
+			break;
+		}
+		
+		if (wilc->chip == WILC_1000) {
+			ret = wilc->hif_func->hif_write_reg(wilc,
+							    WILC_HOST_VMM_CTL,
+							    0x2);
+			if (!ret) {
+				PRINT_ER(vif->ndev, 
+					  "fail write reg host_vmm_ctl..\n");
+				break;
+			}
+
+			do {
+				ret = func->hif_read_reg(wilc,
+						      WILC_HOST_VMM_CTL,
+						      &reg);
+				if (!ret)
+					break;
+				if ((reg >> 2) & 0x1) {
+					entries = ((reg >> 3) & 0x3f);
+					break;
+				}
+			} while (--timeout);
+		} else {
+			ret = func->hif_write_reg(wilc,
+					      WILC_HOST_VMM_CTL,
+					      0);
+			if (!ret) {
+				PRINT_ER(vif->ndev, 
+					  "fail write reg host_vmm_ctl..\n");
+				break;
+			}
+			/* interrupt firmware */
+			ret = func->hif_write_reg(wilc,
+					      WILC_INTERRUPT_CORTUS_0,
+					      1);
+			if (!ret) {
+				PRINT_ER(vif->ndev,
+					  "fail write reg WILC_INTERRUPT_CORTUS_0..\n");
+				break;
+			}
+
+			do {
+				ret = func->hif_read_reg(wilc,
+						      WILC_INTERRUPT_CORTUS_0,
+						      &reg);
+				if (!ret) {
+					PRINT_ER(vif->ndev,
+						  "fail read reg WILC_INTERRUPT_CORTUS_0..\n");
+					break;
+				}
+				if (reg == 0) {
+					// Get the entries
+
+					ret = func->hif_read_reg(wilc,
+							      WILC_HOST_VMM_CTL,
+							      &reg);
+					if (!ret) {
+						PRINT_ER(vif->ndev,
+							  "fail read reg host_vmm_ctl..\n");
+						break;
+					}
+					entries = ((reg >> 3) & 0x3f);
+					break;
+				}
+			} while (--timeout);
+		}
+		if (timeout <= 0) {
+			ret = func->hif_write_reg(wilc, WILC_HOST_VMM_CTL, 0x0);
+			break;
+		}
+
+		if (!ret)
+			break;
+
+		if (entries == 0) {
+			PRINT_INFO(vif->ndev, TX_DBG,
+				   "no buffer in the chip (reg: %08x), retry later [[ %d, %x ]] \n",
+				   reg, i, vmm_table[i-1]);
+			ret = func->hif_read_reg(wilc, WILC_HOST_TX_CTRL, &reg);
+			if (!ret) {
+				PRINT_ER(vif->ndev,
+					  "fail read reg WILC_HOST_TX_CTRL..\n");
+				break;
+			}
+			reg &= ~BIT(0);
+			ret = func->hif_write_reg(wilc, WILC_HOST_TX_CTRL, reg);
+			if (!ret) {
+				PRINT_ER(vif->ndev,
+					  "fail write reg WILC_HOST_TX_CTRL..\n");
+				break;
+			}
+			break;
+		}
+		break;
+	} while (1);
+
+	if (!ret)
+		goto out_release_bus;
+
+	if (entries == 0) {
+		ret = WILC_TX_ERR_NO_BUF;
+		goto out_release_bus;
+	}
+
+	release_bus(wilc, RELEASE_ALLOW_SLEEP, PWR_DEV_SRC_WIFI);
+	schedule();
+	offset = 0;
+	i = 0;
+	do {
+		struct txq_entry_t *tqe;
+		u32 header, buffer_offset;
+
+		tqe = wilc_wlan_txq_remove_from_head(dev, vmm_entries_ac[i]);
+		ac_pkt_num_to_chip[vmm_entries_ac[i]]++;
+		if (!tqe)
+			break;
+		if (vmm_table[i] == 0)
+			break;
+
+		vmm_table[i] = cpu_to_le32(vmm_table[i]);
+		vmm_sz = (vmm_table[i] & 0x3ff);
+		vmm_sz *= 4;
+		header = (tqe->type << 31) |
+			 (tqe->buffer_size << 15) |
+			 vmm_sz;
+		if (tqe->type == WILC_MGMT_PKT)
+			header |= BIT(30);
+		else
+			header &= ~BIT(30);
+
+		header = cpu_to_le32(header);
+		memcpy(&txb[offset], &header, 4);
+		if (tqe->type == WILC_CFG_PKT) {
+			buffer_offset = ETH_CONFIG_PKT_HDR_OFFSET;
+		} else if (tqe->type == WILC_NET_PKT) {
+			char *bssid = ((struct tx_complete_data *)(tqe->priv))->bssid;
+			int prio = tqe->q_num;
+
+			buffer_offset = ETH_ETHERNET_HDR_OFFSET;
+			memcpy(&txb[offset + 4], &prio, sizeof(prio));
+			memcpy(&txb[offset + 8], bssid, 6);
+		} else {
+			buffer_offset = HOST_HDR_OFFSET;
+		}
+
+		memcpy(&txb[offset + buffer_offset],
+		       tqe->buffer, tqe->buffer_size);
+		offset += vmm_sz;
+		i++;
+		tqe->status = 1;
+		if (tqe->tx_complete_func)
+			tqe->tx_complete_func(tqe->priv,
+					      tqe->status);
+		if (tqe->tcp_pending_ack_idx != NOT_TCP_ACK &&
+		    tqe->tcp_pending_ack_idx < MAX_PENDING_ACKS)
+			pending_acks_info[tqe->tcp_pending_ack_idx].txqe = NULL;
+		kfree(tqe);
+	} while (--entries);
+	for(i = 0; i < NQUEUES; i++)
+		ac_fw_count[i] += ac_pkt_num_to_chip[i];
+
+	acquire_bus(wilc, ACQUIRE_AND_WAKEUP, PWR_DEV_SRC_WIFI);
+
+	ret = func->hif_clear_int_ext(wilc, ENABLE_TX_VMM);
+	if (!ret) {
+		PRINT_ER(vif->ndev, "fail start tx VMM ...\n");
+		goto out_release_bus;
+	}
+
+	ret = func->hif_block_tx_ext(wilc, 0, txb, offset);
+	if(!ret)
+		PRINT_ER(vif->ndev, "fail block tx ext...\n");
+
+out_release_bus:
+	release_bus(wilc, RELEASE_ALLOW_SLEEP, PWR_DEV_SRC_WIFI);
+	schedule();
+
+out:
+	mutex_unlock(&wilc->txq_add_to_head_cs);
+
+	wilc->txq_exit = 1;
+	PRINT_INFO(vif->ndev, TX_DBG,"THREAD: Exiting txq\n");
+	*txq_count = wilc->txq_entries;
+	if(ret == 1)
+		cfg_packet_timeout = 0;
+	return ret;
+}
+
+static void wilc_wlan_handle_rx_buff(struct wilc *wilc, u8 *buffer, int size)
+{
+	int offset = 0;
+	u32 header;
+	u32 pkt_len, pkt_offset, tp_len;
+	int is_cfg_packet;
+	u8 *buff_ptr;
+	struct wilc_vif *vif = wilc->vif[0];
+
+	do {
+		PRINT_INFO(vif->ndev, RX_DBG, "Handling rx buffer\n");
+		buff_ptr = buffer + offset;
+		memcpy(&header, buff_ptr, 4);
+		header = cpu_to_le32(header);
+		PRINT_INFO(vif->ndev, RX_DBG,
+			   "Header = %04x - Offset = %d\n",header,offset);
+
+		is_cfg_packet = (header >> 31) & 0x1;
+		pkt_offset = (header >> 22) & 0x1ff;
+		tp_len = (header >> 11) & 0x7ff;
+		pkt_len = header & 0x7ff;
+
+		if (pkt_len == 0 || tp_len == 0) {
+			PRINT_INFO(vif->ndev, RX_DBG, 
+				   "Data corrupted %d, %d\n",
+				   pkt_len, tp_len);
+			break;
+		}
+
+		if (pkt_offset & IS_MANAGMEMENT) {
+			pkt_offset &= ~(IS_MANAGMEMENT |
+					IS_MANAGMEMENT_CALLBACK |
+					IS_MGMT_STATUS_SUCCES);
+			buff_ptr += HOST_HDR_OFFSET;
+			wilc_wfi_mgmt_rx(wilc, buff_ptr, pkt_len);
+		} else {
+			if (!is_cfg_packet) {
+				if (pkt_len > 0) {
+					wilc_frmw_to_linux(wilc, buff_ptr,
+							   pkt_len,
+							   pkt_offset,
+							   PKT_STATUS_NEW);
+				}
+			} else {
+				struct wilc_cfg_rsp rsp;
+
+				buff_ptr += pkt_offset;
+
+				wilc_wlan_cfg_indicate_rx(wilc, buff_ptr,
+							  pkt_len,
+							  &rsp);
+				if (rsp.type == WILC_CFG_RSP) {
+					PRINT_INFO(vif->ndev, RX_DBG, 
+						   "cfg_seq %d rsp.seq %d\n",
+						   wilc->cfg_seq_no,
+						   rsp.seq_no);
+					if (wilc->cfg_seq_no == rsp.seq_no)
+						complete(&wilc->cfg_event);
+				} else if (rsp.type == WILC_CFG_RSP_STATUS) {
+					wilc_mac_indicate(wilc,
+							  WILC_MAC_INDICATE_STATUS);
+
+				} else if (rsp.type == WILC_CFG_RSP_SCAN) {
+					wilc_mac_indicate(wilc,
+							  WILC_MAC_INDICATE_SCAN);
+				}
+			}
+		}
+		offset += tp_len;
+		if (offset >= size)
+			break;
+	} while (1);
+}
+
+static void wilc_wlan_handle_rxq(struct wilc *wilc)
+{
+	int size;
+	u8 *buffer;
+	struct rxq_entry_t *rqe;
+	struct wilc_vif *vif = wilc->vif[0];
+
+	wilc->rxq_exit = 0;
+
+	do {
+		if (wilc->quit) {
+			PRINT_INFO(vif->ndev, RX_DBG,
+				   "Quitting. Exit handle RX queue\n");
+			complete(&wilc->cfg_event);
+			break;
+		}
+		rqe = wilc_wlan_rxq_remove(wilc);
+		if (!rqe) {
+			PRINT_INFO(vif->ndev, RX_DBG,
+				   "nothing in RX queue\n");
+			break;
+		}
+
+		buffer = rqe->buffer;
+		size = rqe->buffer_size;
+		PRINT_INFO(vif->ndev, RX_DBG,
+			   "rxQ entery Size = %d - Address = %p\n",
+			   size,buffer);
+
+		wilc_wlan_handle_rx_buff(wilc, buffer, size);
+
+		kfree(rqe);
+	} while (1);
+
+	wilc->rxq_exit = 1;
+	PRINT_INFO(vif->ndev, RX_DBG,"THREAD: Exiting RX thread \n");
+}
+
+static void wilc_unknown_isr_ext(struct wilc *wilc)
+{
+	wilc->hif_func->hif_clear_int_ext(wilc, 0);
+}
+
+static void wilc_wlan_handle_isr_ext(struct wilc *wilc, u32 int_status)
+{
+	u32 offset = wilc->rx_buffer_offset;
+	u8 *buffer = NULL;
+	u32 size;
+	u32 retries = 0;
+	int ret = 0;
+	struct rxq_entry_t *rqe;
+	struct wilc_vif *vif = wilc->vif[0];
+
+	size = (int_status & 0x7fff) << 2;
+
+	while (!size && retries < 10) {
+		PRINT_ER(vif->ndev,
+			 "RX Size equal zero Trying to read it again\n");
+		wilc->hif_func->hif_read_size(wilc, &size);
+		size = (size & 0x7fff) << 2;
+		retries++;
+	}
+
+	if (size > 0) {
+		if (LINUX_RX_SIZE - offset < size)
+			offset = 0;
+
+		if (wilc->rx_buffer) {
+			buffer = &wilc->rx_buffer[offset];
+		} else {
+			PRINT_ER(vif->ndev,
+				 "Rx Buffer is NULL. drop the packets (%d)\n",
+				 size);
+			goto _end_;
+		}
+		wilc->hif_func->hif_clear_int_ext(wilc,
+					      DATA_INT_CLR | ENABLE_RX_VMM);
+		ret = wilc->hif_func->hif_block_rx_ext(wilc, 0, buffer, size);
+
+		if (!ret)
+			PRINT_ER(vif->ndev, "fail block rx\n");
+_end_:
+		if (ret) {
+			offset += size;
+			wilc->rx_buffer_offset = offset;
+			rqe = kmalloc(sizeof(*rqe), GFP_KERNEL);
+			if (rqe) {
+				rqe->buffer = buffer;
+				rqe->buffer_size = size;
+				PRINT_INFO(vif->ndev, RX_DBG,
+					   "rxq entery Size= %d Address= %p\n",
+					   rqe->buffer_size, rqe->buffer);
+				wilc_wlan_rxq_add(wilc, rqe);
+			}
+		}
+	}
+	if (ret)
+		wilc_wlan_handle_rxq(wilc);
+}
+
+void wilc_handle_isr(struct wilc *wilc)
+{
+	u32 int_status;
+	struct wilc_vif *vif = wilc->vif[0];
+
+	acquire_bus(wilc, ACQUIRE_AND_WAKEUP, PWR_DEV_SRC_WIFI);
+	wilc->hif_func->hif_read_int(wilc, &int_status);
+
+	if (int_status & DATA_INT_EXT)
+		wilc_wlan_handle_isr_ext(wilc, int_status);
+
+	if (!(int_status & (ALL_INT_EXT))) {
+		PRINT_WRN(vif->ndev, TX_DBG, ">> UNKNOWN_INTERRUPT - 0x%08x\n",
+			  int_status);
+		wilc_unknown_isr_ext(wilc);
+	}
+
+	release_bus(wilc, RELEASE_ALLOW_SLEEP, PWR_DEV_SRC_WIFI);
+}
+
+int wilc_wlan_firmware_download(struct wilc *wilc, const u8 *buffer,
+				u32 buffer_size)
+{
+	u32 offset;
+	u32 addr, size, size2, blksz;
+	u8 *dma_buffer;
+	int ret = 0;
+	u32 reg = 0;
+	struct wilc_vif *vif = wilc->vif[0];
+
+	blksz = BIT(12);
+
+	dma_buffer = kmalloc(blksz, GFP_KERNEL);
+	if (!dma_buffer) {
+		PRINT_ER(vif->ndev,
+			 "Can't allocate buffer for fw download IO error\n");
+		return -EIO;
+	}
+
+	offset = 0;
+	PRINT_INFO(vif->ndev, INIT_DBG, "Downloading firmware size = %d\n",
+		   buffer_size);
+
+	acquire_bus(wilc, ACQUIRE_AND_WAKEUP, PWR_DEV_SRC_WIFI);
+
+	wilc->hif_func->hif_read_reg(wilc, WILC_GLB_RESET_0, &reg);
+	reg &= ~(1ul << 10);
+	ret = wilc->hif_func->hif_write_reg(wilc, WILC_GLB_RESET_0, reg);
+	wilc->hif_func->hif_read_reg(wilc, WILC_GLB_RESET_0, &reg);
+	if ((reg & (1ul << 10)) != 0)
+		PRINT_ER(vif->ndev, "Failed to reset Wifi CPU\n");
+
+	release_bus(wilc, RELEASE_ONLY, PWR_DEV_SRC_WIFI);
+	do {
+		memcpy(&addr, &buffer[offset], 4);
+		memcpy(&size, &buffer[offset + 4], 4);
+		addr = cpu_to_le32(addr);
+		size = cpu_to_le32(size);
+		acquire_bus(wilc, ACQUIRE_AND_WAKEUP, PWR_DEV_SRC_WIFI);
+		offset += 8;
+		while (((int)size) && (offset < buffer_size)) {
+			if (size <= blksz)
+				size2 = size;
+			else
+				size2 = blksz;
+
+			memcpy(dma_buffer, &buffer[offset], size2);
+			ret = wilc->hif_func->hif_block_tx(wilc, addr,
+							   dma_buffer, size2);
+			if (!ret)
+				break;
+
+			addr += size2;
+			offset += size2;
+			size -= size2;
+		}
+		release_bus(wilc, RELEASE_ALLOW_SLEEP, PWR_DEV_SRC_WIFI);
+
+		if (!ret) {
+			ret = -EIO;
+			PRINT_ER(vif->ndev, "Bus error\n");
+			goto fail;
+		}
+		PRINT_INFO(vif->ndev, INIT_DBG, "Offset = %d\n", offset);
+	} while (offset < buffer_size);
+
+fail:
+
+	kfree(dma_buffer);
+
+	return (ret < 0) ? ret : 0;
+}
+
+int wilc_wlan_start(struct wilc *wilc)
+{
+	u32 reg = 0;
+	int ret;
+	struct wilc_vif *vif = wilc->vif[0];
+
+	if (wilc->io_type == HIF_SDIO ||
+	    wilc->io_type == HIF_SDIO_GPIO_IRQ)
+		reg |= BIT(3);
+	else if (wilc->io_type == HIF_SPI)
+		reg = 1;
+
+	acquire_bus(wilc, ACQUIRE_AND_WAKEUP,PWR_DEV_SRC_WIFI);
+	ret = wilc->hif_func->hif_write_reg(wilc, WILC_VMM_CORE_CFG, reg);
+	if (!ret) {
+		PRINT_ER(vif->ndev,
+			 "[wilc start]: fail write reg vmm_core_cfg...\n");
+		release_bus(wilc, RELEASE_ALLOW_SLEEP, PWR_DEV_SRC_WIFI);
+		return -EIO;
+	}
+	reg = 0;
+	if (wilc->io_type == HIF_SDIO_GPIO_IRQ)
+		reg |= WILC_HAVE_SDIO_IRQ_GPIO;
+
+	if(wilc->chip == WILC_3000)
+		reg |= WILC_HAVE_SLEEP_CLK_SRC_RTC;
+
+	ret = wilc->hif_func->hif_write_reg(wilc, WILC_GP_REG_1, reg);
+	if (!ret) {
+		PRINT_ER(vif->ndev, "[wilc start]: fail write WILC_GP_REG_1...\n");
+		release_bus(wilc, RELEASE_ALLOW_SLEEP, PWR_DEV_SRC_WIFI);
+		return -EIO;
+	}
+
+	wilc->hif_func->hif_sync_ext(wilc, NUM_INT_EXT);
+
+
+	wilc->hif_func->hif_read_reg(wilc, WILC_GLB_RESET_0, &reg);
+	if ((reg & BIT(10)) == BIT(10)) {
+		reg &= ~BIT(10);
+		wilc->hif_func->hif_write_reg(wilc, WILC_GLB_RESET_0, reg);
+		wilc->hif_func->hif_read_reg(wilc, WILC_GLB_RESET_0, &reg);
+	}
+
+	reg |= BIT(10);
+	ret = wilc->hif_func->hif_write_reg(wilc, WILC_GLB_RESET_0, reg);
+	wilc->hif_func->hif_read_reg(wilc, WILC_GLB_RESET_0, &reg);
+
+	if (ret >= 0)
+		wilc->initialized = 1;
+	else
+		wilc->initialized = 0;
+	release_bus(wilc, RELEASE_ALLOW_SLEEP, PWR_DEV_SRC_WIFI);
+
+	return (ret < 0) ? ret : 0;
+}
+
+int wilc_wlan_stop(struct wilc *wilc)
+{
+	u32 reg = 0;
+	int ret;
+	u8 timeout = 10;
+	struct wilc_vif *vif = wilc->vif[0];
+
+	acquire_bus(wilc, ACQUIRE_AND_WAKEUP, PWR_DEV_SRC_WIFI);
+
+	/* Clear Wifi mode*/
+	ret = wilc->hif_func->hif_read_reg(wilc, WILC_GLOBAL_MODE_CONTROL, &reg);
+	if (!ret) {
+		PRINT_ER(vif->ndev, "Error while reading reg\n");
+		release_bus(wilc, RELEASE_ALLOW_SLEEP, PWR_DEV_SRC_WIFI);
+		return ret;
+	}
+	
+	reg &= ~BIT(0);
+	ret = wilc->hif_func->hif_write_reg(wilc, WILC_GLOBAL_MODE_CONTROL, reg);
+	if (!ret) {
+		PRINT_ER(vif->ndev, "Error while writing reg\n");
+		release_bus(wilc, RELEASE_ALLOW_SLEEP, PWR_DEV_SRC_WIFI);
+		return ret;
+	}
+
+	/* Configure the power sequencer to ignore WIFI sleep signal on making chip
+		sleep decision */
+	ret = wilc->hif_func->hif_read_reg(wilc, WILC_PWR_SEQ_MISC_CTRL, &reg);
+	if (!ret) {
+		PRINT_ER(vif->ndev, "Error while reading reg\n");
+		release_bus(wilc, RELEASE_ALLOW_SLEEP, PWR_DEV_SRC_WIFI);
+		return ret;
+	}
+	
+	reg &= ~BIT(28);
+	ret = wilc->hif_func->hif_write_reg(wilc, WILC_PWR_SEQ_MISC_CTRL, reg);
+	if (!ret) {
+		PRINT_ER(vif->ndev, "Error while writing reg\n");
+		release_bus(wilc, RELEASE_ALLOW_SLEEP, PWR_DEV_SRC_WIFI);
+		return ret;
+	}
+
+	ret = wilc->hif_func->hif_read_reg(wilc, WILC_GLB_RESET_0, &reg);
+	if (!ret) {
+		PRINT_ER(vif->ndev, "Error while reading reg\n");
+		release_bus(wilc, RELEASE_ALLOW_SLEEP, PWR_DEV_SRC_WIFI);
+		return ret;
+	}
+
+	reg &= ~BIT(10);
+	ret = wilc->hif_func->hif_write_reg(wilc, WILC_GLB_RESET_0, reg);
+	if (!ret) {
+		PRINT_ER(vif->ndev, "Error while writing reg\n");
+		release_bus(wilc, RELEASE_ALLOW_SLEEP, PWR_DEV_SRC_WIFI);
+		return ret;
+	}
+
+	do {
+		ret = wilc->hif_func->hif_read_reg(wilc,
+						   WILC_GLB_RESET_0, &reg);
+		if (!ret) {
+			PRINT_ER(vif->ndev, "Error while reading reg\n");
+			release_bus(wilc, RELEASE_ALLOW_SLEEP, PWR_DEV_SRC_WIFI);
+			return ret;
+		}
+		PRINT_INFO(vif->ndev, GENERIC_DBG,
+			   "Read RESET Reg %x : Retry%d\n", reg, timeout);
+		if ((reg & BIT(10))) {
+			PRINT_INFO(vif->ndev, GENERIC_DBG,
+				   "Bit 10 not reset : Retry %d\n", timeout);
+			reg &= ~BIT(10);
+			ret = wilc->hif_func->hif_write_reg(wilc,
+							    WILC_GLB_RESET_0,
+							    reg);
+			timeout--;
+		} else {
+			PRINT_INFO(vif->ndev, GENERIC_DBG,
+				   "Bit 10 reset after : Retry %d\n", timeout);
+			ret = wilc->hif_func->hif_read_reg(wilc,
+							   WILC_GLB_RESET_0,
+							   &reg);
+			if (!ret) {
+				PRINT_ER(vif->ndev, "Error while reading reg\n");
+				release_bus(wilc, RELEASE_ALLOW_SLEEP,
+					    PWR_DEV_SRC_WIFI);
+				return ret;
+			}
+			PRINT_INFO(vif->ndev, GENERIC_DBG,
+				   "Read RESET Reg %x : Retry%d\n", reg,
+				   timeout);
+			break;
+		}
+
+	} while (timeout);
+
+	if (wilc->chip == WILC_1000) {
+		reg = (BIT(0) | BIT(1) | BIT(2) | BIT(3) | BIT(8) | BIT(9) |
+		       BIT(26) | BIT(29) | BIT(30) | BIT(31));
+	} else {
+		reg = (BIT(0) | BIT(2) | BIT(3) | BIT(8) | BIT(9) |
+		       BIT(20) | BIT(26) | BIT(29) | BIT(30) | BIT(31));
+	}
+
+	wilc->hif_func->hif_read_reg(wilc, WILC_FW_HOST_COMM, &reg);
+	reg = BIT(0);
+
+	ret = wilc->hif_func->hif_write_reg(wilc, WILC_FW_HOST_COMM, reg);
+
+	release_bus(wilc, RELEASE_ALLOW_SLEEP, PWR_DEV_SRC_WIFI);
+
+	return ret;
+}
+
+void wilc_wlan_cleanup(struct net_device *dev)
+{
+	struct txq_entry_t *tqe;
+	struct rxq_entry_t *rqe;
+	u8 ac;
+	struct wilc_vif *vif;
+	struct wilc *wilc;
+
+	vif = netdev_priv(dev);
+	wilc = vif->wilc;
+
+	wilc->quit = 1;
+	for (ac = 0; ac < NQUEUES; ac++) {
+		do {
+			tqe = wilc_wlan_txq_remove_from_head(dev, ac);
+			if (!tqe)
+				break;
+			if (tqe->tx_complete_func)
+				tqe->tx_complete_func(tqe->priv, 0);
+			kfree(tqe);
+		} while (1);
+	}
+
+	do {
+		rqe = wilc_wlan_rxq_remove(wilc);
+		if (!rqe)
+			break;
+		kfree(rqe);
+	} while (1);
+
+	kfree(wilc->rx_buffer);
+	wilc->rx_buffer = NULL;
+	kfree(wilc->tx_buffer);
+	wilc->tx_buffer = NULL;
+}
+
+static int wilc_wlan_cfg_commit(struct wilc_vif *vif, int type,
+				u32 drv_handler)
+{
+	struct wilc *wilc = vif->wilc;
+	struct wilc_cfg_frame *cfg = &wilc->cfg_frame;
+	int total_len = wilc->cfg_frame_offset + 4 + DRIVER_HANDLER_SIZE;
+	int seq_no = wilc->cfg_seq_no % 256;
+	int driver_handler = (u32)drv_handler;
+
+	if (type == WILC_CFG_SET)
+		cfg->wid_header[0] = 'W';
+	else
+		cfg->wid_header[0] = 'Q';
+	cfg->wid_header[1] = seq_no;
+	cfg->wid_header[2] = (u8)total_len;
+	cfg->wid_header[3] = (u8)(total_len >> 8);
+	cfg->wid_header[4] = (u8)driver_handler;
+	cfg->wid_header[5] = (u8)(driver_handler >> 8);
+	cfg->wid_header[6] = (u8)(driver_handler >> 16);
+	cfg->wid_header[7] = (u8)(driver_handler >> 24);
+	wilc->cfg_seq_no = seq_no;
+
+	if (!wilc_wlan_txq_add_cfg_pkt(vif, &cfg->wid_header[0], total_len))
+		return -1;
+
+	return 0;
+}
+
+int wilc_wlan_cfg_set(struct wilc_vif *vif, int start, u16 wid, u8 *buffer,
+		      u32 buffer_size, int commit, u32 drv_handler)
+{
+	u32 offset;
+	int ret_size;
+	struct wilc *wilc = vif->wilc;
+
+	if (wilc->cfg_frame_in_use)
+		return 0;
+
+	if (start)
+		wilc->cfg_frame_offset = 0;
+
+	offset = wilc->cfg_frame_offset;
+	ret_size = wilc_wlan_cfg_set_wid(vif, wilc->cfg_frame.frame, offset,
+					 wid, buffer, buffer_size);
+	offset += ret_size;
+	wilc->cfg_frame_offset = offset;
+
+	if (!commit)
+		return ret_size;
+
+	PRINT_INFO(vif->ndev, TX_DBG,
+		   "[WILC]PACKET Commit with sequence number%d\n",
+		   wilc->cfg_seq_no);
+	wilc->cfg_frame_in_use = 1;
+
+	if (wilc_wlan_cfg_commit(vif, WILC_CFG_SET, drv_handler))
+		ret_size = 0;
+
+	if (!wait_for_completion_timeout(&wilc->cfg_event,
+					 msecs_to_jiffies(CFG_PKTS_TIMEOUT))) {
+		PRINT_ER(vif->ndev, "Set Timed Out\n");
+		ret_size = 0;
+	}
+
+	wilc->cfg_frame_in_use = 0;
+	wilc->cfg_frame_offset = 0;
+	wilc->cfg_seq_no += 1;
+
+	return ret_size;
+}
+
+int wilc_wlan_cfg_get(struct wilc_vif *vif, int start, u16 wid, int commit,
+		      u32 drv_handler)
+{
+	u32 offset;
+	int ret_size;
+	struct wilc *wilc = vif->wilc;
+
+	if (wilc->cfg_frame_in_use)
+		return 0;
+
+	if (start)
+		wilc->cfg_frame_offset = 0;
+
+	offset = wilc->cfg_frame_offset;
+	ret_size = wilc_wlan_cfg_get_wid(wilc->cfg_frame.frame, offset, wid);
+	offset += ret_size;
+	wilc->cfg_frame_offset = offset;
+
+	if (!commit)
+		return ret_size;
+
+	wilc->cfg_frame_in_use = 1;
+
+	if (wilc_wlan_cfg_commit(vif, WILC_CFG_QUERY, drv_handler))
+		ret_size = 0;
+
+	if (!wait_for_completion_timeout(&wilc->cfg_event,
+					 msecs_to_jiffies(CFG_PKTS_TIMEOUT))) {
+		PRINT_INFO(vif->ndev, TX_DBG, "Get Timed Out\n");
+		ret_size = 0;
+	}
+	PRINT_INFO(vif->ndev, TX_DBG, "Get Response received\n");
+	wilc->cfg_frame_in_use = 0;
+	wilc->cfg_frame_offset = 0;
+	wilc->cfg_seq_no += 1;
+
+	return ret_size;
+}
+
+int wilc_wlan_cfg_get_val(struct wilc_vif *vif, u16 wid, u8 *buffer,
+			  u32 buffer_size)
+{
+	return wilc_wlan_cfg_get_wid_value(vif, wid, buffer, buffer_size);
+}
+unsigned int cfg_packet_timeout = 0;
+extern int wait_for_recovery;
+int wilc_send_config_pkt(struct wilc_vif *vif, u8 mode, struct wid *wids,
+			 u32 count, u32 drv)
+{
+	int i;
+	int ret = 0;
+
+	if(wait_for_recovery){
+		PRINT_INFO(vif->ndev, CORECONFIG_DBG,
+			   "Host interface is suspended\n");
+		while(wait_for_recovery)
+			msleep(300);
+		PRINT_INFO(vif->ndev, CORECONFIG_DBG,
+			   "Host interface is resumed\n");
+	}
+
+	if (mode == GET_CFG) {
+		for (i = 0; i < count; i++) {
+			PRINT_D(vif->ndev, CORECONFIG_DBG,
+				"Sending CFG packet [%d][%d]\n",!i,
+				(i == count - 1));
+			if (!wilc_wlan_cfg_get(vif, !i,
+					       wids[i].id,
+					       (i == count - 1),
+					       drv)) {
+				ret = -ETIMEDOUT;
+				PRINT_ER(vif->ndev, "Get Timed out\n");
+				break;
+			}
+		}
+		for (i = 0; i < count; i++) {
+			wids[i].size = wilc_wlan_cfg_get_val(vif, wids[i].id,
+							     wids[i].val,
+							     wids[i].size);
+		}
+	} else if (mode == SET_CFG) {
+		for (i = 0; i < count; i++) {
+			PRINT_INFO(vif->ndev, CORECONFIG_DBG,
+				   "Sending config SET PACKET WID:%x\n",
+				   wids[i].id);
+			if (!wilc_wlan_cfg_set(vif, !i,
+					       wids[i].id,
+					       wids[i].val,
+					       wids[i].size,
+					       (i == count - 1),
+					       drv)) {
+				ret = -ETIMEDOUT;
+				PRINT_ER(vif->ndev, "Set Timed out\n");
+				break;
+			}
+		}
+	}
+	cfg_packet_timeout = (ret < 0) ? cfg_packet_timeout + 1 : 0;
+	return ret;
+}
+
+static u32 init_chip(struct net_device *dev)
+{
+	u32 chipid;
+	u32 reg, ret = 0;
+	struct wilc_vif *vif;
+	struct wilc *wilc;
+
+	vif = netdev_priv(dev);
+	wilc = vif->wilc;
+
+	acquire_bus(wilc, ACQUIRE_AND_WAKEUP,PWR_DEV_SRC_WIFI);
+
+	chipid = wilc_get_chipid(wilc, true);
+
+	ret = wilc->hif_func->hif_read_reg(wilc, 0x1118, &reg);
+	if (!ret) {
+		PRINT_ER(vif->ndev, "fail read reg 0x1118\n");
+		goto end;
+	}
+
+	reg |= BIT(0);
+	ret = wilc->hif_func->hif_write_reg(wilc, 0x1118, reg);
+	if (!ret) {
+		PRINT_ER(vif->ndev, "fail write reg 0x1118\n");
+		goto end;
+	}
+	ret = wilc->hif_func->hif_write_reg(wilc, 0xc0000, 0x71);
+	if (!ret) {
+		PRINT_ER(vif->ndev, "fail write reg 0xc0000 ...\n");
+		goto end;
+	}
+
+	if(wilc->chip == WILC_3000) {
+		ret = wilc->hif_func->hif_read_reg(wilc, 0x207ac, &reg);
+		PRINT_INFO(vif->ndev, INIT_DBG, "Bootrom sts = %x\n", reg);
+		ret = wilc->hif_func->hif_write_reg(wilc, 0x4f0000,
+						    0x71);
+		if (!ret) {
+			PRINT_ER(vif->ndev, "fail write reg 0x4f0000 ...\n");
+			goto end;
+		}
+	}
+
+end:
+	release_bus(wilc, RELEASE_ALLOW_SLEEP, PWR_DEV_SRC_WIFI);
+
+	return ret;
+}
+
+u32 wilc_get_chipid(struct wilc *wilc, bool update)
+{
+	static u32 chipid;
+	int ret;
+	u32 tempchipid = 0;
+
+	if (chipid == 0 || update) {
+		ret = wilc->hif_func->hif_read_reg(wilc, 0x3b0000,
+						     &tempchipid);
+		if (!ret) 
+			pr_err("[wilc start]: fail read reg 0x3b0000\n");
+		if (!ISWILC3000(tempchipid)) {
+			wilc->hif_func->hif_read_reg(wilc, 0x1000,
+						     &tempchipid);
+			if (!ISWILC1000(tempchipid)) {
+				chipid = 0;
+				return chipid;
+			}
+			if(tempchipid < 0x1003a0){
+				pr_err("WILC1002 isn't suported %x\n", chipid);
+				chipid = 0;
+				return chipid;
+			}
+		}
+		chipid = tempchipid;
+	}
+
+	return chipid;
+}
+
+int wilc_wlan_init(struct net_device *dev)
+{
+	int ret = 0;
+	struct wilc_vif *vif = netdev_priv(dev);
+	struct wilc *wilc;
+
+	wilc = vif->wilc;
+
+	wilc->quit = 0;
+	
+	PRINT_INFO(vif->ndev, INIT_DBG,"Initializing WILC_Wlan\n");
+
+	if(!wilc->hif_func->hif_is_init()) {
+		acquire_bus(wilc, ACQUIRE_ONLY , PWR_DEV_SRC_WIFI);
+		if (!wilc->hif_func->hif_init(wilc, false)) {
+			ret = -EIO;
+			release_bus(wilc, RELEASE_ONLY, PWR_DEV_SRC_WIFI);
+			goto fail;
+		}
+		release_bus(wilc, RELEASE_ONLY, PWR_DEV_SRC_WIFI);
+	}
+
+	if (!wilc_wlan_cfg_init()) {
+		ret = -ENOBUFS;
+		goto fail;
+	}
+
+	if (!wilc->tx_buffer)
+		wilc->tx_buffer = kmalloc(LINUX_TX_SIZE, GFP_KERNEL);
+
+	if (!wilc->tx_buffer) {
+		ret = -ENOBUFS;
+		PRINT_ER(vif->ndev, "Can't allocate Tx Buffer");
+		goto fail;
+	}
+
+	if (!wilc->rx_buffer)
+		wilc->rx_buffer = kmalloc(LINUX_RX_SIZE, GFP_KERNEL);
+	PRINT_D(vif->ndev, TX_DBG, "g_wlan.rx_buffer =%p\n", wilc->rx_buffer);
+	if (!wilc->rx_buffer) {
+		ret = -ENOBUFS;
+		PRINT_ER(vif->ndev, "Can't allocate Rx Buffer");
+		goto fail;
+	}
+
+	if (!init_chip(dev)) {
+		ret = -EIO;
+		goto fail;
+	}
+
+	return 1;
+
+fail:
+
+	kfree(wilc->rx_buffer);
+	wilc->rx_buffer = NULL;
+	kfree(wilc->tx_buffer);
+	wilc->tx_buffer = NULL;
+
+	return ret;
+}
diff --git a/drivers/staging/wilc1000/wilc_wlan.h b/drivers/staging/wilc/wilc_wlan.h
similarity index 71%
rename from drivers/staging/wilc1000/wilc_wlan.h
rename to drivers/staging/wilc/wilc_wlan.h
index da71731..afa0028 100644
--- a/drivers/staging/wilc1000/wilc_wlan.h
+++ b/drivers/staging/wilc/wilc_wlan.h
@@ -3,8 +3,10 @@
 #define WILC_WLAN_H
 
 #include <linux/types.h>
+#include <linux/version.h>
 
 #define ISWILC1000(id)			((id & 0xfffff000) == 0x100000 ? 1 : 0)
+#define ISWILC3000(id)			((id & 0xfffff000) == 0x300000 ? 1 : 0)
 
 /********************************************
  *
@@ -35,6 +37,8 @@
 
 #define ETH_CONFIG_PKT_HDR_OFFSET	(ETH_ETHERNET_HDR_OFFSET + \
 					 ETH_CONFIG_PKT_HDR_LEN)
+#define PKT_STATUS_NEW          0
+#define PKT_STATUS_BUFFERED     1
 
 /********************************************
  *
@@ -42,7 +46,6 @@
  *
  ********************************************/
 #define WILC_PERIPH_REG_BASE		0x1000
-#define WILC_CHANGING_VIR_IF		0x108c
 #define WILC_CHIPID			WILC_PERIPH_REG_BASE
 #define WILC_GLB_RESET_0		(WILC_PERIPH_REG_BASE + 0x400)
 #define WILC_PIN_MUX_0			(WILC_PERIPH_REG_BASE + 0x408)
@@ -53,6 +56,7 @@
 #define WILC_HOST_RX_CTRL		(WILC_PERIPH_REG_BASE + 0x80)
 #define WILC_HOST_RX_EXTRA_SIZE		(WILC_PERIPH_REG_BASE + 0x84)
 #define WILC_HOST_TX_CTRL_1		(WILC_PERIPH_REG_BASE + 0x88)
+#define WILC_INTERRUPT_CORTUS_0		(WILC_PERIPH_REG_BASE + 0xa8)
 #define WILC_MISC			(WILC_PERIPH_REG_BASE + 0x428)
 #define WILC_INTR_REG_BASE		(WILC_PERIPH_REG_BASE + 0xa00)
 #define WILC_INTR_ENABLE		WILC_INTR_REG_BASE
@@ -96,18 +100,21 @@
 #define WILC_VMM_TBL_RX_SHADOW_BASE	WILC_AHB_SHARE_MEM_BASE
 #define WILC_VMM_TBL_RX_SHADOW_SIZE	256
 
+#define WILC_FW_HOST_COMM		0x13c0
 #define WILC_GP_REG_0			0x149c
 #define WILC_GP_REG_1			0x14a0
 
+#define WILC_COEXIST_CTL		0x161E00
+#define WILC_GLOBAL_MODE_CONTROL	0x1614
+#define WILC_PWR_SEQ_MISC_CTRL		0x3008
+#define WILC_COE_AUTO_PS_ON_NULL_PKT	0x160468
+#define WILC_COE_AUTO_PS_OFF_NULL_PKT	0x16046C
+#define CCA_CTL_2 (0x160EF4)
+#define CCA_CTL_7 (0x160F08)
+
 #define WILC_HAVE_SDIO_IRQ_GPIO		BIT(0)
-#define WILC_HAVE_USE_PMU		BIT(1)
 #define WILC_HAVE_SLEEP_CLK_SRC_RTC	BIT(2)
 #define WILC_HAVE_SLEEP_CLK_SRC_XO	BIT(3)
-#define WILC_HAVE_EXT_PA_INV_TX_RX	BIT(4)
-#define WILC_HAVE_LEGACY_RF_SETTINGS	BIT(5)
-#define WILC_HAVE_XTAL_24		BIT(6)
-#define WILC_HAVE_DISABLE_WILC_UART	BIT(7)
-#define WILC_HAVE_USE_IRQ_AS_HOST_WAKE	BIT(8)
 
 /********************************************
  *
@@ -124,16 +131,27 @@
 #define WILC_CFG_RSP		1
 #define WILC_CFG_RSP_STATUS	2
 #define WILC_CFG_RSP_SCAN	3
-
-#define WILC_PLL_TO_SDIO	4
-#define WILC_PLL_TO_SPI		2
 #define ABORT_INT		BIT(31)
 
-#define LINUX_RX_SIZE		(96 * 1024)
-#define LINUX_TX_SIZE		(64 * 1024)
+#define LINUX_RX_SIZE	(96 * 1024)
+#define LINUX_TX_SIZE	(64 * 1024)
 
 #define MODALIAS		"WILC_SPI"
-#define GPIO_NUM		0x44
+#define GPIO_NUM		0x5B
+#define GPIO_NUM_CHIP_EN	94
+#define GPIO_NUM_RESET		60
+
+
+#define NQUEUES			4
+#define VO_AC_COUNT_POS		25
+#define VO_AC_ACM_STAT_POS	24
+#define VI_AC_COUNT_POS		17
+#define VI_AC_ACM_STAT_POS	16
+#define BE_AC_COUNT_POS		9
+#define BE_AC_ACM_STAT_POS	8
+#define BK_AC_COUNT_POS		2
+#define BK_AC_ACM_STAT_POS	1
+#define AC_BUFFER_SIZE		1000
 /*******************************************/
 /*        E0 and later Interrupt flags.    */
 /*******************************************/
@@ -155,8 +173,7 @@
 #define INT_2			BIT(IRG_FLAGS_OFFSET + 2)
 #define INT_3			BIT(IRG_FLAGS_OFFSET + 3)
 #define INT_4			BIT(IRG_FLAGS_OFFSET + 4)
-#define INT_5			BIT(IRG_FLAGS_OFFSET + 5)
-#define MAX_NUM_INT		6
+#define MAX_NUM_INT		5
 
 /*******************************************/
 /*        E0 and later Interrupt flags.    */
@@ -182,42 +199,56 @@
 #define EN_VMM			BIT(8)
 
 #define DATA_INT_EXT		INT_0
-#define PLL_INT_EXT		INT_1
-#define SLEEP_INT_EXT		INT_2
-#define ALL_INT_EXT		(DATA_INT_EXT | PLL_INT_EXT | SLEEP_INT_EXT)
-#define NUM_INT_EXT		3
+#define ALL_INT_EXT		(DATA_INT_EXT)
+#define NUM_INT_EXT		1
 
 #define DATA_INT_CLR		CLR_INT0
-#define PLL_INT_CLR		CLR_INT1
-#define SLEEP_INT_CLR		CLR_INT2
 
 #define ENABLE_RX_VMM		(SEL_VMM_TBL1 | EN_VMM)
 #define ENABLE_TX_VMM		(SEL_VMM_TBL0 | EN_VMM)
 /*time for expiring the completion of cfg packets*/
 #define CFG_PKTS_TIMEOUT	2000
+
+#define IS_MANAGMEMENT		0x100
+#define IS_MANAGMEMENT_CALLBACK	0x080
+#define IS_MGMT_STATUS_SUCCES	0x040
+
 /********************************************
  *
  *      Debug Type
  *
  ********************************************/
-typedef void (*wilc_debug_func)(u32, char *, ...);
 
 /********************************************
  *
  *      Tx/Rx Queue Structure
  *
  ********************************************/
+struct txq_handle {
+	struct txq_entry_t *txq_head;
+	struct txq_entry_t *txq_tail;
+	u16 count;
+	u8 acm;
+};
+
+enum ip_pkt_priority {
+	AC_VO_Q = 0,
+	AC_VI_Q = 1,
+	AC_BE_Q = 2,
+	AC_BK_Q = 3
+};
 
 struct txq_entry_t {
 	struct txq_entry_t *next;
 	struct txq_entry_t *prev;
 	int type;
+	u8 q_num;
 	int tcp_pending_ack_idx;
 	u8 *buffer;
 	int buffer_size;
 	void *priv;
 	int status;
-	void (*tx_complete_func)(void *, int);
+	void (*tx_complete_func)(void *priv, int status);
 };
 
 struct rxq_entry_t {
@@ -226,6 +257,11 @@ struct rxq_entry_t {
 	int buffer_size;
 };
 
+enum wilc_chip_type {
+	WILC_1000,
+	WILC_3000,
+};
+
 /********************************************
  *
  *      Host IF Structure
@@ -233,20 +269,22 @@ struct rxq_entry_t {
  ********************************************/
 struct wilc;
 struct wilc_hif_func {
-	int (*hif_init)(struct wilc *, bool resume);
-	int (*hif_deinit)(struct wilc *);
-	int (*hif_read_reg)(struct wilc *, u32, u32 *);
-	int (*hif_write_reg)(struct wilc *, u32, u32);
-	int (*hif_block_rx)(struct wilc *, u32, u8 *, u32);
-	int (*hif_block_tx)(struct wilc *, u32, u8 *, u32);
-	int (*hif_read_int)(struct wilc *, u32 *);
-	int (*hif_clear_int_ext)(struct wilc *, u32);
-	int (*hif_read_size)(struct wilc *, u32 *);
-	int (*hif_block_tx_ext)(struct wilc *, u32, u8 *, u32);
-	int (*hif_block_rx_ext)(struct wilc *, u32, u8 *, u32);
-	int (*hif_sync_ext)(struct wilc *, int);
+	int (*hif_init)(struct wilc *wilc, bool resume);
+	int (*hif_deinit)(struct wilc *wilc);
+	int (*hif_read_reg)(struct wilc *wilc, u32 addr, u32 *data);
+	int (*hif_write_reg)(struct wilc *wilc, u32 addr, u32 data);
+	int (*hif_block_rx)(struct wilc *wilc, u32 addr, u8 *buf, u32 size);
+	int (*hif_block_tx)(struct wilc *wilc, u32 addr, u8 *buf, u32 size);
+	int (*hif_read_int)(struct wilc *wilc, u32 *int_status);
+	int (*hif_clear_int_ext)(struct wilc *wilc, u32 val);
+	int (*hif_read_size)(struct wilc *wilc, u32 *size);
+	int (*hif_block_tx_ext)(struct wilc *wilc, u32 addr, u8 *buf, u32 size);
+	int (*hif_block_rx_ext)(struct wilc *wilc, u32 addr, u8 *buf, u32 size);
+	int (*hif_sync_ext)(struct wilc *wilc, int nint);
 	int (*enable_interrupt)(struct wilc *nic);
 	void (*disable_interrupt)(struct wilc *nic);
+	int (*hif_reset)(struct wilc *wilc);
+	bool (*hif_is_init)(void);
 };
 
 /********************************************
@@ -286,21 +324,35 @@ int wilc_wlan_cfg_set(struct wilc_vif *vif, int start, u16 wid, u8 *buffer,
 		      u32 buffer_size, int commit, u32 drv_handler);
 int wilc_wlan_cfg_get(struct wilc_vif *vif, int start, u16 wid, int commit,
 		      u32 drv_handler);
-int wilc_wlan_cfg_get_val(u16 wid, u8 *buffer, u32 buffer_size);
+int wilc_wlan_cfg_get_val(struct wilc_vif *vif, u16 wid, u8 *buffer,
+			  u32 buffer_size);
 int wilc_wlan_txq_add_mgmt_pkt(struct net_device *dev, void *priv, u8 *buffer,
 			       u32 buffer_size, wilc_tx_complete_func_t func);
-void wilc_chip_sleep_manually(struct wilc *wilc);
 
 void wilc_enable_tcp_ack_filter(bool value);
 int wilc_wlan_get_num_conn_ifcs(struct wilc *wilc);
-int wilc_mac_xmit(struct sk_buff *skb, struct net_device *dev);
+netdev_tx_t wilc_mac_xmit(struct sk_buff *skb, struct net_device *dev);
 
-void WILC_WFI_p2p_rx(struct net_device *dev, u8 *buff, u32 size);
-void host_wakeup_notify(struct wilc *wilc);
-void host_sleep_notify(struct wilc *wilc);
+void wilc_wfi_p2p_rx(struct net_device *dev, u8 *buff, u32 size);
+void host_wakeup_notify(struct wilc *wilc, int source);
+void host_sleep_notify(struct wilc *wilc, int source);
 extern bool wilc_enable_ps;
-void chip_allow_sleep(struct wilc *wilc);
-void chip_wakeup(struct wilc *wilc);
+void chip_allow_sleep(struct wilc *wilc, int source);
+void chip_wakeup(struct wilc *wilc, int source);
 int wilc_send_config_pkt(struct wilc_vif *vif, u8 mode, struct wid *wids,
 			 u32 count, u32 drv);
+void wilc_wlan_power_on_sequence(struct wilc *wilc);
+void wilc_wlan_power_off_sequence(struct wilc *wilc);
+
+void wilc_bt_init(struct wilc *wilc);
+void wilc_bt_deinit(void);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,15,0)
+void eap_buff_timeout(struct timer_list *t);
+#else
+void eap_buff_timeout(unsigned long user);
+#endif
+void acquire_bus(struct wilc *wilc, enum bus_acquire acquire, int source);
+void release_bus(struct wilc *wilc, enum bus_release release, int source);
+int wilc_wlan_init(struct net_device *dev);
+u32 wilc_get_chipid(struct wilc *wilc, bool update);
 #endif
diff --git a/drivers/staging/wilc1000/wilc_wlan_cfg.c b/drivers/staging/wilc/wilc_wlan_cfg.c
similarity index 76%
rename from drivers/staging/wilc1000/wilc_wlan_cfg.c
rename to drivers/staging/wilc/wilc_wlan_cfg.c
index 19e4f85..f893ad3 100644
--- a/drivers/staging/wilc1000/wilc_wlan_cfg.c
+++ b/drivers/staging/wilc/wilc_wlan_cfg.c
@@ -13,6 +13,7 @@
 #include "wilc_wlan.h"
 #include "wilc_wlan_cfg.h"
 #include "coreconfigurator.h"
+#include "wilc_wfi_netdevice.h"
 
 /********************************************
  *
@@ -46,6 +47,7 @@ struct wilc_mac_cfg {
 	u8 firmware_info[8];
 	u8 scan_result[256];
 	u8 scan_result1[256];
+	u8 antenna_param[5];
 };
 
 static struct wilc_mac_cfg g_mac;
@@ -90,6 +92,8 @@ static struct wilc_cfg_byte g_cfg_byte[] = {
 	{WID_TX_ABORT_CONFIG, 0},
 	{WID_11N_IMMEDIATE_BA_ENABLED, 0},
 	{WID_11N_TXOP_PROT_DISABLE, 0},
+	{WID_TX_POWER, 0},
+	{WID_WOWLAN_TRIGGER, 0},
 	{WID_NIL, 0}
 };
 
@@ -100,7 +104,6 @@ static struct wilc_cfg_hword g_cfg_hword[] = {
 	{WID_SHORT_RETRY_LIMIT, 0},
 	{WID_LONG_RETRY_LIMIT, 0},
 	{WID_BEACON_INTERVAL, 0},
-	{WID_RX_SENSE, 0},
 	{WID_ACTIVE_SCAN_TIME, 0},
 	{WID_PASSIVE_SCAN_TIME, 0},
 	{WID_SITE_SURVEY_SCAN_TIME, 0},
@@ -158,6 +161,10 @@ static struct wilc_cfg_str g_cfg_str[] = {
 	{WID_NIL, NULL}
 };
 
+static struct wilc_cfg_bin g_cfg_bin[] = {
+	{WID_ANTENNA_SELECTION, g_mac.antenna_param}
+};
+
 /********************************************
  *
  *      Configuration Functions
@@ -221,7 +228,8 @@ static int wilc_wlan_cfg_set_word(u8 *frame, u32 offset, u16 id, u32 val32)
 	return 8;
 }
 
-static int wilc_wlan_cfg_set_str(u8 *frame, u32 offset, u16 id, u8 *str, u32 size)
+static int wilc_wlan_cfg_set_str(u8 *frame, u32 offset, u16 id, u8 *str,
+				 u32 size)
 {
 	u8 *buf;
 
@@ -235,7 +243,7 @@ static int wilc_wlan_cfg_set_str(u8 *frame, u32 offset, u16 id, u8 *str, u32 siz
 	buf[2] = (u8)size;
 	buf[3] = (u8)(size >> 8);
 
-	if ((str) && (size != 0))
+	if (str && size != 0)
 		memcpy(&buf[4], str, size);
 
 	return (size + 4);
@@ -256,7 +264,7 @@ static int wilc_wlan_cfg_set_bin(u8 *frame, u32 offset, u16 id, u8 *b, u32 size)
 	buf[2] = (u8)size;
 	buf[3] = (u8)(size >> 8);
 
-	if ((b) && (size != 0)) {
+	if ((b) && size != 0) {
 		memcpy(&buf[4], b, size);
 		for (i = 0; i < size; i++)
 			checksum += buf[i + 4];
@@ -273,15 +281,19 @@ static int wilc_wlan_cfg_set_bin(u8 *frame, u32 offset, u16 id, u8 *b, u32 size)
  *
  ********************************************/
 
-static void wilc_wlan_parse_response_frame(u8 *info, int size)
+static void wilc_wlan_parse_response_frame(struct wilc *wilc, u8 *info,
+					   int size)
 {
 	u32 wid, len = 0, i = 0;
+	struct wilc_vif *vif = wilc->vif[0];
 
 	while (size > 0) {
 		i = 0;
 		wid = info[0] | (info[1] << 8);
 		wid = cpu_to_le32(wid);
 
+		PRINT_D(vif->ndev, GENERIC_DBG,"Processing response for %d\n",
+			wid);
 		switch ((wid >> 12) & 0x7) {
 		case WID_CHAR:
 			do {
@@ -340,18 +352,61 @@ static void wilc_wlan_parse_response_frame(u8 *info, int size)
 					if (wid == WID_SITE_SURVEY_RESULTS) {
 						static int toggle;
 
+						PRINT_D(vif->ndev, GENERIC_DBG,
+							"Site survey results received %d\n",
+							size);
+						PRINT_D(vif->ndev, GENERIC_DBG,
+							"Site survey results value %d toggle%d\n",
+							size, toggle);
 						i += toggle;
 						toggle ^= 1;
 					}
 					memcpy(g_cfg_str[i].str, &info[2],
-					       (info[2] + 2));
+					       (2+((info[3] << 8) | info[2])));
 					break;
 				}
 				i++;
 			} while (1);
-			len = 2 + info[2];
+			len = 2+((info[3] << 8) | info[2]);
 			break;
+		case WID_BIN_DATA:
+			do {
+				if (g_cfg_bin[i].id == WID_NIL)
+					break;
 
+				if (g_cfg_bin[i].id == wid) {
+					uint16_t length = (info[3] << 8) |
+							  info[2];
+					uint8_t  checksum = 0;
+					uint16_t i = 0;
+
+					/*
+					 * Compute the Checksum of received 
+					 * data field
+					 */
+					for(i = 0;i < length;i++)
+						checksum += info[4 + i];
+					/* 
+					 * Verify the checksum of recieved BIN 
+					 * DATA
+					 */
+					if (checksum == info[4 + length]) {
+						memcpy(g_cfg_bin[i].bin, &info[2], length + 2);
+						/*
+						 * value length + data length +
+						 * checksum 
+						 */
+						len = 2 + length + 1;   
+						break;
+					} else {
+						PRINT_ER(vif->ndev,
+							 "Checksum Failed!");
+						return;
+					}
+				}
+				i++;
+			} while (1);
+			break;
 		default:
 			break;
 		}
@@ -360,17 +415,18 @@ static void wilc_wlan_parse_response_frame(u8 *info, int size)
 	}
 }
 
-static int wilc_wlan_parse_info_frame(u8 *info, int size)
+static int wilc_wlan_parse_info_frame(struct wilc *wilc, u8 *info, int size)
 {
 	struct wilc_mac_cfg *pd = &g_mac;
+	struct wilc_vif *vif = wilc->vif[0];
 	u32 wid, len;
 	int type = WILC_CFG_RSP_STATUS;
 
 	wid = info[0] | (info[1] << 8);
 
 	len = info[2];
-
-	if ((len == 1) && (wid == WID_STATUS)) {
+	PRINT_D(vif->ndev, GENERIC_DBG,"Status Len = %d Id= %d\n", len, wid);
+	if (len == 1 && wid == WID_STATUS) {
 		pd->mac_status = info[3];
 		type = WILC_CFG_RSP_STATUS;
 	}
@@ -384,7 +440,8 @@ static int wilc_wlan_parse_info_frame(u8 *info, int size)
  *
  ********************************************/
 
-int wilc_wlan_cfg_set_wid(u8 *frame, u32 offset, u16 id, u8 *buf, int size)
+int wilc_wlan_cfg_set_wid(struct wilc_vif *vif, u8 *frame, u32 offset, u16 id,
+			  u8 *buf, int size)
 {
 	u8 type = (id >> 12) & 0xf;
 	int ret = 0;
@@ -414,6 +471,8 @@ int wilc_wlan_cfg_set_wid(u8 *frame, u32 offset, u16 id, u8 *buf, int size)
 	case CFG_BIN_CMD:
 		ret = wilc_wlan_cfg_set_bin(frame, offset, id, buf, size);
 		break;
+	default:
+		PRINT_ER(vif->ndev, "illegal id\n");
 	}
 
 	return ret;
@@ -434,7 +493,8 @@ int wilc_wlan_cfg_get_wid(u8 *frame, u32 offset, u16 id)
 	return 2;
 }
 
-int wilc_wlan_cfg_get_wid_value(u16 wid, u8 *buffer, u32 buffer_size)
+int wilc_wlan_cfg_get_wid_value(struct wilc_vif *vif, u16 wid, u8 *buffer,
+				u32 buffer_size)
 {
 	u32 type = (wid >> 12) & 0xf;
 	int i, ret = 0;
@@ -483,20 +543,24 @@ int wilc_wlan_cfg_get_wid_value(u16 wid, u8 *buffer, u32 buffer_size)
 		} while (1);
 	} else if (type == CFG_STR_CMD) {
 		do {
-			if (g_cfg_str[i].id == WID_NIL)
+			u32 id = g_cfg_str[i].id;
+
+			if (id == WID_NIL)
 				break;
 
-			if (g_cfg_str[i].id == wid) {
+			if (id == wid) {
 				u32 size = g_cfg_str[i].str[0] |
 						(g_cfg_str[i].str[1] << 8);
 
 				if (buffer_size >= size) {
-					if (g_cfg_str[i].id == WID_SITE_SURVEY_RESULTS)	{
+					if (id == WID_SITE_SURVEY_RESULTS) {
 						static int toggle;
 
+						PRINT_D(vif->ndev, GENERIC_DBG,
+							"Site survey results%d\n",
+							size);
 						i += toggle;
 						toggle ^= 1;
-
 					}
 					memcpy(buffer,  &g_cfg_str[i].str[2],
 					       size);
@@ -506,6 +570,25 @@ int wilc_wlan_cfg_get_wid_value(u16 wid, u8 *buffer, u32 buffer_size)
 			}
 			i++;
 		} while (1);
+	} else if (type == CFG_BIN_CMD) { /* binary command */
+		do {
+			if (g_cfg_bin[i].id == WID_NIL)
+				break;
+
+			if (g_cfg_bin[i].id == wid) {
+				uint32_t size = g_cfg_bin[i].bin[0] | 
+					     (g_cfg_bin[i].bin[1]<<8);
+				if (buffer_size >= size) {					
+					memcpy(buffer, &g_cfg_bin[i].bin[2],
+						size);
+					ret = size;
+				}
+				break;
+			}
+			i++;
+		} while (1);
+	} else {
+		PRINT_ER(vif->ndev, "[CFG]: illegal type (%08x)\n", wid);
 	}
 
 	return ret;
@@ -523,21 +606,25 @@ int wilc_wlan_cfg_indicate_rx(struct wilc *wilc, u8 *frame, int size,
 	frame += 4;
 	size -= 4;
 
-	/**
-	 *      The  valid types of response messages are 'R' (Response), 'I' (Information), and 'N' (Network Information)
-	 **/
+	/*
+	 * The valid types of response messages are
+	 * 'R' (Response),
+	 * 'I' (Information), and
+	 * 'N' (Network Information)
+	 */
 
 	switch (msg_type) {
 	case 'R':
-		wilc_wlan_parse_response_frame(frame, size);
+		wilc_wlan_parse_response_frame(wilc, frame, size);
 		rsp->type = WILC_CFG_RSP;
 		rsp->seq_no = msg_id;
 		break;
 
 	case 'I':
-		rsp->type = wilc_wlan_parse_info_frame(frame, size);
+		rsp->type = wilc_wlan_parse_info_frame(wilc, frame, size);
 		rsp->seq_no = msg_id;
 		/*call host interface info parse as well*/
+		PRINT_D(wilc->vif[0]->ndev, RX_DBG,"Info message received\n");
 		wilc_gnrl_async_info_received(wilc, frame - 4, size + 4);
 		break;
 
@@ -547,10 +634,15 @@ int wilc_wlan_cfg_indicate_rx(struct wilc *wilc, u8 *frame, int size,
 		break;
 
 	case 'S':
+		PRINT_D(wilc->vif[0]->ndev, RX_DBG,"Scan Notification Received\n");
 		wilc_scan_complete_received(wilc, frame - 4, size + 4);
 		break;
 
 	default:
+		PRINT_D(wilc->vif[0]->ndev, RX_DBG,
+			"Receive unknown message %d-%d-%d-%d-%d-%d-%d-%d\n",
+			 frame[0], frame[1], frame[2], frame[3], frame[4],
+			 frame[5], frame[6], frame[7]);
 		rsp->type = 0;
 		rsp->seq_no = msg_id;
 		ret = 0;
diff --git a/drivers/staging/wilc1000/wilc_wlan_cfg.h b/drivers/staging/wilc/wilc_wlan_cfg.h
similarity index 75%
rename from drivers/staging/wilc1000/wilc_wlan_cfg.h
rename to drivers/staging/wilc/wilc_wlan_cfg.h
index 08092a5..07c2852 100644
--- a/drivers/staging/wilc1000/wilc_wlan_cfg.h
+++ b/drivers/staging/wilc/wilc_wlan_cfg.h
@@ -31,10 +31,17 @@ struct wilc_cfg_str {
 	u8 *str;
 };
 
+struct wilc_cfg_bin {
+	u32 id;
+	u8 *bin;
+};
+
 struct wilc;
-int wilc_wlan_cfg_set_wid(u8 *frame, u32 offset, u16 id, u8 *buf, int size);
+int wilc_wlan_cfg_set_wid(struct wilc_vif *vif, u8 *frame, u32 offset, u16 id,
+			  u8 *buf, int size);
 int wilc_wlan_cfg_get_wid(u8 *frame, u32 offset, u16 id);
-int wilc_wlan_cfg_get_wid_value(u16 wid, u8 *buffer, u32 buffer_size);
+int wilc_wlan_cfg_get_wid_value(struct wilc_vif *vif, u16 wid, u8 *buffer,
+				u32 buffer_size);
 int wilc_wlan_cfg_indicate_rx(struct wilc *wilc, u8 *frame, int size,
 			      struct wilc_cfg_rsp *rsp);
 int wilc_wlan_cfg_init(void);
diff --git a/drivers/staging/wilc1000/wilc_wlan_if.h b/drivers/staging/wilc/wilc_wlan_if.h
similarity index 94%
rename from drivers/staging/wilc1000/wilc_wlan_if.h
rename to drivers/staging/wilc/wilc_wlan_if.h
index c1693cf..b362e90 100644
--- a/drivers/staging/wilc1000/wilc_wlan_if.h
+++ b/drivers/staging/wilc/wilc_wlan_if.h
@@ -12,6 +12,7 @@
 #define WILC_WLAN_IF_H
 
 #include <linux/netdevice.h>
+#include "wilc_debugfs.h"
 
 /********************************************
  *
@@ -23,6 +24,10 @@
 #define HIF_SPI			BIT(0)
 #define HIF_SDIO_GPIO_IRQ	BIT(2)
 
+#define	FIRMWARE_WILC1000_WIFi		"mchp/wilc1000_wifi_firmware.bin"
+#define	FIRMWARE_WILC3000_WIFI		"mchp/wilc3000_wifi_firmware.bin"
+#define	FIRMWARE_WILC3000_BLE		"mchp/wilc3000_ble_firmware.bin"
+
 /********************************************
  *
  *      Wlan Interface Defines
@@ -49,17 +54,18 @@ struct sdio_cmd53 {
 };
 
 #define WILC_MAC_INDICATE_STATUS	0x1
-#define WILC_MAC_STATUS_INIT		-1
-#define WILC_MAC_STATUS_READY		0
-#define WILC_MAC_STATUS_CONNECT		1
-
 #define WILC_MAC_INDICATE_SCAN		0x2
 
+#define MAC_STATUS_INIT			-1
+#define MAC_STATUS_CONNECTED		1
+#define MAC_STATUS_DISCONNECTED		0
+
 struct tx_complete_data {
 	int size;
 	void *buff;
 	u8 *bssid;
 	struct sk_buff *skb;
+	struct wilc_vif *vif;
 };
 
 typedef void (*wilc_tx_complete_func_t)(void *, int);
@@ -75,7 +81,7 @@ typedef void (*wilc_tx_complete_func_t)(void *, int);
 #define MAX_SSID_LEN            33
 #define MAX_RATES_SUPPORTED     12
 
-typedef enum {
+enum {
 	SUPP_RATES_IE		= 1,
 	EXT_SUPP_RATES_IE	= 50,
 	HT_CAPABILITY_IE	= 45,
@@ -83,15 +89,15 @@ typedef enum {
 	WPA_IE			= 221,
 	WMM_IE			= 221,
 	P2P_IE			= 221,
-} BEACON_IE;
+};
 
-typedef enum {
+enum bss_types {
 	INFRASTRUCTURE		= 0,
 	INDEPENDENT,
 	AP,
-} BSSTYPE_T;
+};
 
-typedef enum {
+enum {
 	RATE_AUTO		= 0,
 	RATE_1MB		= 1,
 	RATE_2MB		= 2,
@@ -105,55 +111,49 @@ typedef enum {
 	RATE_26MB		= 36,
 	RATE_48MB		= 48,
 	RATE_54MB		= 54
-} TX_RATE_T;
+};
 
-typedef enum {
+enum {
 	B_ONLY_MODE		= 0,    /* 1, 2 M, otherwise 5, 11 M */
 	G_ONLY_MODE,			/* 6,12,24 otherwise 9,18,36,48,54 */
 	G_MIXED_11B_1_MODE,		/* 1,2,5.5,11 otherwise all on */
 	G_MIXED_11B_2_MODE,		/* 1,2,5,11,6,12,24 otherwise all on */
-} G_OPERATING_MODE_T;
+};
 
-typedef enum {
+enum {
 	G_SHORT_PREAMBLE	= 0,	/* Short Preamble */
 	G_LONG_PREAMBLE		= 1,	/* Long Preamble */
 	G_AUTO_PREAMBLE		= 2,	/* Auto Preamble Selection */
-} G_PREAMBLE_T;
+};
 
-#define MAC_CONNECTED		1
-#define MAC_DISCONNECTED	0
+#define PWR_DEV_SRC_WIFI	0
+#define PWR_DEV_SRC_BT		1
+#define PWR_DEV_SRC_MAX		2
 
-#define SCAN_DONE		TRUE
-typedef enum {
+enum {
 	PASSIVE_SCAN		= 0,
 	ACTIVE_SCAN		= 1,
-} SCANTYPE_T;
+};
 
-typedef enum {
+enum {
 	NO_POWERSAVE		= 0,
 	MIN_FAST_PS		= 1,
 	MAX_FAST_PS		= 2,
 	MIN_PSPOLL_PS		= 3,
 	MAX_PSPOLL_PS		= 4
-} USER_PS_MODE_T;
-
-typedef enum {
-	CHIP_WAKEDUP		= 0,
-	CHIP_SLEEPING_AUTO      = 1,
-	CHIP_SLEEPING_MANUAL	= 2
-} CHIP_PS_STATE_T;
+};
 
-typedef enum {
+enum bus_acquire {
 	ACQUIRE_ONLY            = 0,
 	ACQUIRE_AND_WAKEUP	= 1,
-} BUS_ACQUIRE_T;
+};
 
-typedef enum {
+enum bus_release {
 	RELEASE_ONLY		= 0,
 	RELEASE_ALLOW_SLEEP	= 1,
-} BUS_RELEASE_T;
+};
 
-typedef enum {
+enum {
 	NO_SECURITY		= 0,
 	WEP_40			= 0x3,
 	WEP_104			= 0x7,
@@ -163,7 +163,7 @@ typedef enum {
 	WPA2_AES		= 0x31,
 	WPA2_TKIP		= 0x51,
 	WPA2_AES_TKIP		= 0x71,	/* Aes or Tkip */
-} SECURITY_T;
+};
 
 enum AUTHTYPE {
 	OPEN_SYSTEM		= 1,
@@ -178,88 +178,88 @@ enum SITESURVEY {
 	SITE_SURVEY_OFF		= 2
 };
 
-typedef enum {
+enum {
 	NORMAL_ACK		= 0,
 	NO_ACK,
-} ACK_POLICY_T;
+};
 
-typedef enum {
+enum {
 	DONT_RESET		= 0,
 	DO_RESET		= 1,
 	NO_REQUEST		= 2,
-} RESET_REQ_T;
+};
 
-typedef enum {
+enum {
 	REKEY_DISABLE		= 1,
 	REKEY_TIME_BASE,
 	REKEY_PKT_BASE,
 	REKEY_TIME_PKT_BASE
-} RSNA_REKEY_POLICY_T;
+};
 
-typedef enum {
+enum {
 	FILTER_NO		= 0x00,
 	FILTER_AP_ONLY		= 0x01,
 	FILTER_STA_ONLY		= 0x02
-} SCAN_CLASS_FITLER_T;
+};
 
-typedef enum {
+enum {
 	PRI_HIGH_RSSI		= 0x00,
 	PRI_LOW_RSSI		= 0x04,
 	PRI_DETECT		= 0x08
-} SCAN_PRI_T;
+};
 
-typedef enum {
+enum {
 	CH_FILTER_OFF		= 0x00,
 	CH_FILTER_ON		= 0x10
-} CH_FILTER_T;
+};
 
-typedef enum {
+enum {
 	AUTO_PROT		= 0,	/* Auto */
 	NO_PROT,			/* Do not use any protection */
 	ERP_PROT,			/* Protect all ERP frame exchanges */
 	HT_PROT,			/* Protect all HT frame exchanges  */
 	GF_PROT,			/* Protect all GF frame exchanges  */
-} N_PROTECTION_MODE_T;
+};
 
-typedef enum {
+enum {
 	G_SELF_CTS_PROT,
 	G_RTS_CTS_PROT,
-} G_PROTECTION_MODE_T;
+};
 
-typedef enum {
+enum {
 	HT_MIXED_MODE		= 1,
 	HT_ONLY_20MHZ_MODE,
 	HT_ONLY_20_40MHZ_MODE,
-} N_OPERATING_MODE_T;
+};
 
-typedef enum {
+enum {
 	NO_DETECT		= 0,
 	DETECT_ONLY		= 1,
 	DETECT_PROTECT		= 2,
 	DETECT_PROTECT_REPORT	= 3,
-} N_OBSS_DETECTION_T;
+};
 
-typedef enum {
+enum {
 	RTS_CTS_NONHT_PROT	= 0,	/* RTS-CTS at non-HT rate */
 	FIRST_FRAME_NONHT_PROT,		/* First frame at non-HT rate */
 	LSIG_TXOP_PROT,                 /* LSIG TXOP Protection */
 	FIRST_FRAME_MIXED_PROT,		/* First frame at Mixed format */
-} N_PROTECTION_TYPE_T;
+};
 
-typedef enum {
+enum {
 	STATIC_MODE		= 1,
 	DYNAMIC_MODE		= 2,
 	MIMO_MODE		= 3,	/* power save disable */
-} N_SMPS_MODE_T;
+};
 
-typedef enum {
+enum {
 	DISABLE_SELF_CTS,
 	ENABLE_SELF_CTS,
 	DISABLE_TX_ABORT,
 	ENABLE_TX_ABORT,
 	HW_TRIGGER_ABORT,
 	SW_TRIGGER_ABORT,
-} TX_ABORT_OPTION_T;
+};
 
 enum wid_type {
 	WID_CHAR		= 0,
@@ -274,6 +274,13 @@ enum wid_type {
 	WID_TYPE_FORCE_32BIT	= 0xFFFFFFFF
 };
 
+enum {
+	ANTENNA1		= 0,
+	ANTENNA2		= 1,
+	DIVERSITY		= 2,
+	NUM_ANT_MODE
+};
+
 struct wid {
 	u16 id;
 	enum wid_type type;
@@ -281,7 +288,7 @@ struct wid {
 	s8 *val;
 };
 
-typedef enum {
+enum {
 	WID_NIL				= 0xffff,
 
 	/*
@@ -337,6 +344,7 @@ typedef enum {
 	 *  -----------------------------------------------------------
 	 */
 	WID_STATUS			= 0x0005,
+	WID_BT_COEX_MODE		= 0x0006,
 
 	/*
 	 *  Scan type
@@ -433,6 +441,15 @@ typedef enum {
 	WID_ACK_POLICY			= 0x0011,
 
 	/*
+	 *  Set coex null frames transmission mode 
+	 * --------------------------------------------------------------
+ 	 *  Configuration :   Enable	Disable
+	 *  Values to set :       1			0
+	 * --------------------------------------------------------------
+	 */
+	WID_COEX_NULL_FRAMES_MODE               = 0x0013,
+
+	/*
 	 *  Reset MAC (Set only)
 	 *  -----------------------------------------------------------
 	 *  Configuration :   Don't Reset	Reset	No Request
@@ -741,8 +758,9 @@ typedef enum {
 
 	WID_DEL_BEACON			= 0x00CA,
 
-	WID_LOGTerminal_Switch		= 0x00CD,
+	WID_LOG_Terminal_Switch		= 0x00CD,
 	WID_TX_POWER			= 0x00CE,
+	WID_WOWLAN_TRIGGER		= 0X00CF,
 	/*  EMAC Short WID list */
 	/*  RTS Threshold */
 	/*
@@ -766,7 +784,6 @@ typedef enum {
 	WID_LONG_RETRY_LIMIT		= 0x1003,
 	WID_BEACON_INTERVAL		= 0x1006,
 	WID_MEMORY_ACCESS_16BIT		= 0x1008,
-	WID_RX_SENSE			= 0x100B,
 	WID_ACTIVE_SCAN_TIME		= 0x100C,
 	WID_PASSIVE_SCAN_TIME		= 0x100D,
 
@@ -807,11 +824,8 @@ typedef enum {
 	WID_HW_RX_COUNT			= 0x2015,
 	WID_MEMORY_ADDRESS		= 0x201E,
 	WID_MEMORY_ACCESS_32BIT		= 0x201F,
-	WID_RF_REG_VAL			= 0x2021,
 
 	/* NMAC Integer WID list */
-	WID_11N_PHY_ACTIVE_REG_VAL	= 0x2080,
-
 	/* Custom Integer WID list */
 	WID_GET_INACTIVE_TIME		= 0x2084,
 	WID_SET_OPERATION_MODE		= 0X2086,
@@ -832,7 +846,6 @@ typedef enum {
 	WID_SUPP_PASSWORD		= 0x3011,
 	WID_SITE_SURVEY_RESULTS		= 0x3012,
 	WID_RX_POWER_LEVEL		= 0x3013,
-	WID_DEL_ALL_RX_BA		= 0x3014,
 	WID_SET_STA_MAC_INACTIVE_TIME	= 0x3017,
 	WID_ADD_WEP_KEY			= 0x3019,
 	WID_REMOVE_WEP_KEY		= 0x301A,
@@ -846,9 +859,9 @@ typedef enum {
 	WID_MODEL_NAME			= 0x3027, /*Added for CAPI tool */
 	WID_MODEL_NUM			= 0x3028, /*Added for CAPI tool */
 	WID_DEVICE_NAME			= 0x3029, /*Added for CAPI tool */
-	WID_SET_DRV_HANDLER		= 0x3079,
 
 	/* NMAC String WID list */
+ 	WID_SET_DRV_HANDLER			= 0x3079,
 	WID_11N_P_ACTION_REQ		= 0x3080,
 	WID_HUT_TEST_ID			= 0x3081,
 	WID_PMKID_INFO			= 0x3082,
@@ -886,13 +899,12 @@ typedef enum {
 
 	WID_SETUP_MULTICAST_FILTER	= 0x408b,
 
+	WID_ANTENNA_SELECTION		= 0x408c,
 	/* Miscellaneous WIDs */
 	WID_ALL				= 0x7FFE,
 	WID_MAX				= 0xFFFF
-} WID_T;
+};
 
 struct wilc;
-int wilc_wlan_init(struct net_device *dev);
-u32 wilc_get_chipid(struct wilc *wilc, bool update);
 
 #endif
diff --git a/drivers/staging/wilc1000/Makefile b/drivers/staging/wilc1000/Makefile
deleted file mode 100644
index ee7e26b..0000000
--- a/drivers/staging/wilc1000/Makefile
+++ /dev/null
@@ -1,18 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-obj-$(CONFIG_WILC1000) += wilc1000.o
-
-ccflags-y += -DFIRMWARE_1002=\"atmel/wilc1002_firmware.bin\" \
-		-DFIRMWARE_1003=\"atmel/wilc1003_firmware.bin\"
-
-ccflags-y += -I$(src)/ -DWILC_ASIC_A0 -DWILC_DEBUGFS
-
-wilc1000-objs := wilc_wfi_cfgoperations.o linux_wlan.o linux_mon.o \
-			coreconfigurator.o host_interface.o \
-			wilc_wlan_cfg.o wilc_debugfs.o \
-			wilc_wlan.o
-
-obj-$(CONFIG_WILC1000_SDIO) += wilc1000-sdio.o
-wilc1000-sdio-objs += wilc_sdio.o
-
-obj-$(CONFIG_WILC1000_SPI) += wilc1000-spi.o
-wilc1000-spi-objs += wilc_spi.o
diff --git a/drivers/staging/wilc1000/TODO b/drivers/staging/wilc1000/TODO
deleted file mode 100644
index ae61b55..0000000
--- a/drivers/staging/wilc1000/TODO
+++ /dev/null
@@ -1,18 +0,0 @@
-TODO:
-- remove the defined feature as kernel versions
-- remove OS wrapper functions
-- remove custom debug and tracing functions
-- rework comments and function headers(also coding style)
-- Move handling for each individual members of 'union message_body' out
-  into a separate 'struct work_struct' and completely remove the multiplexer
-  that is currently part of host_if_work(), allowing movement of the
-  implementation of each message handler into the callsite of the function
-  that currently queues the 'host_if_msg'.
-- make spi and sdio components coexist in one build
-- turn compile-time platform configuration (BEAGLE_BOARD,
-  PANDA_BOARD, PLAT_WMS8304, PLAT_RKXXXX, CUSTOMER_PLATFORM, ...)
-  into run-time options that are read from DT
-- support soft-ap and p2p mode
-- support resume/suspend function
-- replace SIOCDEVPRIVATE commands with generic API functions
-- use wext-core handling instead of private SIOCSIWPRIV implementation
diff --git a/drivers/staging/wilc1000/host_interface.c b/drivers/staging/wilc1000/host_interface.c
deleted file mode 100644
index 421168b..0000000
--- a/drivers/staging/wilc1000/host_interface.c
+++ /dev/null
@@ -1,4092 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-#include <linux/slab.h>
-#include <linux/time.h>
-#include <linux/kthread.h>
-#include <linux/delay.h>
-#include <linux/completion.h>
-#include <linux/list.h>
-#include <linux/workqueue.h>
-#include "host_interface.h"
-#include <linux/spinlock.h>
-#include <linux/errno.h>
-#include "coreconfigurator.h"
-#include "wilc_wlan.h"
-#include "wilc_wlan_if.h"
-#include <linux/etherdevice.h>
-#include "wilc_wfi_netdevice.h"
-
-#define HOST_IF_MSG_SCAN                        0
-#define HOST_IF_MSG_CONNECT                     1
-#define HOST_IF_MSG_RCVD_GNRL_ASYNC_INFO        2
-#define HOST_IF_MSG_KEY                         3
-#define HOST_IF_MSG_RCVD_NTWRK_INFO             4
-#define HOST_IF_MSG_RCVD_SCAN_COMPLETE          5
-#define HOST_IF_MSG_CFG_PARAMS                  6
-#define HOST_IF_MSG_SET_CHANNEL                 7
-#define HOST_IF_MSG_DISCONNECT                  8
-#define HOST_IF_MSG_GET_RSSI                    9
-#define HOST_IF_MSG_ADD_BEACON                  11
-#define HOST_IF_MSG_DEL_BEACON                  12
-#define HOST_IF_MSG_ADD_STATION                 13
-#define HOST_IF_MSG_DEL_STATION                 14
-#define HOST_IF_MSG_EDIT_STATION                15
-#define HOST_IF_MSG_SCAN_TIMER_FIRED            16
-#define HOST_IF_MSG_CONNECT_TIMER_FIRED         17
-#define HOST_IF_MSG_POWER_MGMT                  18
-#define HOST_IF_MSG_GET_INACTIVETIME            19
-#define HOST_IF_MSG_REMAIN_ON_CHAN              20
-#define HOST_IF_MSG_REGISTER_FRAME              21
-#define HOST_IF_MSG_LISTEN_TIMER_FIRED          22
-#define HOST_IF_MSG_SET_WFIDRV_HANDLER          24
-#define HOST_IF_MSG_GET_MAC_ADDRESS             26
-#define HOST_IF_MSG_SET_OPERATION_MODE          27
-#define HOST_IF_MSG_SET_IPADDRESS               28
-#define HOST_IF_MSG_GET_IPADDRESS               29
-#define HOST_IF_MSG_GET_STATISTICS              31
-#define HOST_IF_MSG_SET_MULTICAST_FILTER        32
-#define HOST_IF_MSG_DEL_BA_SESSION              34
-#define HOST_IF_MSG_DEL_ALL_STA                 36
-#define HOST_IF_MSG_SET_TX_POWER		38
-#define HOST_IF_MSG_GET_TX_POWER		39
-#define HOST_IF_MSG_EXIT                        100
-
-#define HOST_IF_SCAN_TIMEOUT                    4000
-#define HOST_IF_CONNECT_TIMEOUT                 9500
-
-#define BA_SESSION_DEFAULT_BUFFER_SIZE          16
-#define BA_SESSION_DEFAULT_TIMEOUT              1000
-#define BLOCK_ACK_REQ_SIZE                      0x14
-#define FALSE_FRMWR_CHANNEL			100
-
-#define TCP_ACK_FILTER_LINK_SPEED_THRESH	54
-#define DEFAULT_LINK_SPEED			72
-
-struct host_if_wpa_attr {
-	u8 *key;
-	const u8 *mac_addr;
-	u8 *seq;
-	u8 seq_len;
-	u8 index;
-	u8 key_len;
-	u8 mode;
-};
-
-struct host_if_wep_attr {
-	u8 *key;
-	u8 key_len;
-	u8 index;
-	u8 mode;
-	enum AUTHTYPE auth_type;
-};
-
-union host_if_key_attr {
-	struct host_if_wep_attr wep;
-	struct host_if_wpa_attr wpa;
-	struct host_if_pmkid_attr pmkid;
-};
-
-struct key_attr {
-	enum KEY_TYPE type;
-	u8 action;
-	union host_if_key_attr attr;
-};
-
-struct scan_attr {
-	u8 src;
-	u8 type;
-	u8 *ch_freq_list;
-	u8 ch_list_len;
-	u8 *ies;
-	size_t ies_len;
-	wilc_scan_result result;
-	void *arg;
-	struct hidden_network hidden_network;
-};
-
-struct connect_attr {
-	u8 *bssid;
-	u8 *ssid;
-	size_t ssid_len;
-	u8 *ies;
-	size_t ies_len;
-	u8 security;
-	wilc_connect_result result;
-	void *arg;
-	enum AUTHTYPE auth_type;
-	u8 ch;
-	void *params;
-};
-
-struct rcvd_async_info {
-	u8 *buffer;
-	u32 len;
-};
-
-struct channel_attr {
-	u8 set_ch;
-};
-
-struct beacon_attr {
-	u32 interval;
-	u32 dtim_period;
-	u32 head_len;
-	u8 *head;
-	u32 tail_len;
-	u8 *tail;
-};
-
-struct set_multicast {
-	bool enabled;
-	u32 cnt;
-};
-
-struct del_all_sta {
-	u8 del_all_sta[MAX_NUM_STA][ETH_ALEN];
-	u8 assoc_sta;
-};
-
-struct del_sta {
-	u8 mac_addr[ETH_ALEN];
-};
-
-struct power_mgmt_param {
-	bool enabled;
-	u32 timeout;
-};
-
-struct set_ip_addr {
-	u8 *ip_addr;
-	u8 idx;
-};
-
-struct sta_inactive_t {
-	u8 mac[6];
-};
-
-struct tx_power {
-	u8 tx_pwr;
-};
-
-union message_body {
-	struct scan_attr scan_info;
-	struct connect_attr con_info;
-	struct rcvd_net_info net_info;
-	struct rcvd_async_info async_info;
-	struct key_attr key_info;
-	struct cfg_param_attr cfg_info;
-	struct channel_attr channel_info;
-	struct beacon_attr beacon_info;
-	struct add_sta_param add_sta_info;
-	struct del_sta del_sta_info;
-	struct add_sta_param edit_sta_info;
-	struct power_mgmt_param pwr_mgmt_info;
-	struct sta_inactive_t mac_info;
-	struct set_ip_addr ip_info;
-	struct drv_handler drv;
-	struct set_multicast multicast_info;
-	struct op_mode mode;
-	struct get_mac_addr get_mac_info;
-	struct ba_session_info session_info;
-	struct remain_ch remain_on_ch;
-	struct reg_frame reg_frame;
-	char *data;
-	struct del_all_sta del_all_sta_info;
-	struct tx_power tx_power;
-};
-
-struct host_if_msg {
-	u16 id;
-	union message_body body;
-	struct wilc_vif *vif;
-	struct work_struct work;
-};
-
-struct join_bss_param {
-	BSSTYPE_T bss_type;
-	u8 dtim_period;
-	u16 beacon_period;
-	u16 cap_info;
-	u8 bssid[6];
-	char ssid[MAX_SSID_LEN];
-	u8 ssid_len;
-	u8 supp_rates[MAX_RATES_SUPPORTED + 1];
-	u8 ht_capable;
-	u8 wmm_cap;
-	u8 uapsd_cap;
-	bool rsn_found;
-	u8 rsn_grp_policy;
-	u8 mode_802_11i;
-	u8 rsn_pcip_policy[3];
-	u8 rsn_auth_policy[3];
-	u8 rsn_cap[2];
-	u32 tsf;
-	u8 noa_enabled;
-	u8 opp_enabled;
-	u8 ct_window;
-	u8 cnt;
-	u8 idx;
-	u8 duration[4];
-	u8 interval[4];
-	u8 start_time[4];
-};
-
-static struct host_if_drv *terminated_handle;
-bool wilc_optaining_ip;
-static u8 P2P_LISTEN_STATE;
-static struct workqueue_struct *hif_workqueue;
-static struct completion hif_thread_comp;
-static struct completion hif_driver_comp;
-static struct completion hif_wait_response;
-static struct mutex hif_deinit_lock;
-static struct timer_list periodic_rssi;
-
-u8 wilc_multicast_mac_addr_list[WILC_MULTICAST_TABLE_SIZE][ETH_ALEN];
-
-static u8 rcv_assoc_resp[MAX_ASSOC_RESP_FRAME_SIZE];
-
-static bool scan_while_connected;
-
-static s8 rssi;
-static u8 set_ip[2][4];
-static u8 get_ip[2][4];
-static u32 inactive_time;
-static u8 del_beacon;
-static u32 clients_count;
-
-static u8 *join_req;
-static u8 *info_element;
-static u8 mode_11i;
-static u8 auth_type;
-static u32 join_req_size;
-static u32 info_element_size;
-static struct wilc_vif *join_req_vif;
-#define REAL_JOIN_REQ 0
-#define FLUSHED_JOIN_REQ 1
-#define FLUSHED_BYTE_POS 79
-
-static void *host_int_ParseJoinBssParam(struct network_info *ptstrNetworkInfo);
-static int host_int_get_ipaddress(struct wilc_vif *vif, u8 *ip_addr, u8 idx);
-static s32 Handle_ScanDone(struct wilc_vif *vif, enum scan_event enuEvent);
-static void host_if_work(struct work_struct *work);
-
-/*!
- *  @author		syounan
- *  @date		1 Sep 2010
- *  @note		copied from FLO glue implementatuion
- *  @version		1.0
- */
-static int wilc_enqueue_cmd(struct host_if_msg *msg)
-{
-	struct host_if_msg *new_msg;
-
-	new_msg = kmemdup(msg, sizeof(*new_msg), GFP_ATOMIC);
-	if (!new_msg)
-		return -ENOMEM;
-
-	INIT_WORK(&new_msg->work, host_if_work);
-	queue_work(hif_workqueue, &new_msg->work);
-	return 0;
-}
-
-/* The u8IfIdx starts from 0 to NUM_CONCURRENT_IFC -1, but 0 index used as
- * special purpose in wilc device, so we add 1 to the index to starts from 1.
- * As a result, the returned index will be 1 to NUM_CONCURRENT_IFC.
- */
-int wilc_get_vif_idx(struct wilc_vif *vif)
-{
-	return vif->idx + 1;
-}
-
-/* We need to minus 1 from idx which is from wilc device to get real index
- * of wilc->vif[], because we add 1 when pass to wilc device in the function
- * wilc_get_vif_idx.
- * As a result, the index should be between 0 and NUM_CONCURRENT_IFC -1.
- */
-static struct wilc_vif *wilc_get_vif_from_idx(struct wilc *wilc, int idx)
-{
-	int index = idx - 1;
-
-	if (index < 0 || index >= NUM_CONCURRENT_IFC)
-		return NULL;
-
-	return wilc->vif[index];
-}
-
-static void handle_set_channel(struct wilc_vif *vif,
-			       struct channel_attr *hif_set_ch)
-{
-	int ret = 0;
-	struct wid wid;
-
-	wid.id = (u16)WID_CURRENT_CHANNEL;
-	wid.type = WID_CHAR;
-	wid.val = (char *)&hif_set_ch->set_ch;
-	wid.size = sizeof(char);
-
-	ret = wilc_send_config_pkt(vif, SET_CFG, &wid, 1,
-				   wilc_get_vif_idx(vif));
-
-	if (ret)
-		netdev_err(vif->ndev, "Failed to set channel\n");
-}
-
-static int handle_set_wfi_drv_handler(struct wilc_vif *vif,
-				      struct drv_handler *hif_drv_handler)
-{
-	int ret = 0;
-	struct wid wid;
-	u8 *currbyte, *buffer;
-	struct host_if_drv *hif_drv = NULL;
-
-	if (!vif->hif_drv)
-		return -EINVAL;
-
-	if (!hif_drv_handler)
-		return -EINVAL;
-
-	hif_drv	= vif->hif_drv;
-
-	buffer = kzalloc(DRV_HANDLER_SIZE, GFP_KERNEL);
-	if (!buffer)
-		return -ENOMEM;
-
-	currbyte = buffer;
-	*currbyte = hif_drv->driver_handler_id & DRV_HANDLER_MASK;
-	currbyte++;
-	*currbyte = (u32)0 & DRV_HANDLER_MASK;
-	currbyte++;
-	*currbyte = (u32)0 & DRV_HANDLER_MASK;
-	currbyte++;
-	*currbyte = (u32)0 & DRV_HANDLER_MASK;
-	currbyte++;
-	*currbyte = (hif_drv_handler->name | (hif_drv_handler->mode << 1));
-
-	wid.id = (u16)WID_SET_DRV_HANDLER;
-	wid.type = WID_STR;
-	wid.val = (s8 *)buffer;
-	wid.size = DRV_HANDLER_SIZE;
-
-	ret = wilc_send_config_pkt(vif, SET_CFG, &wid, 1,
-				   hif_drv->driver_handler_id);
-	if (ret) {
-		netdev_err(vif->ndev, "Failed to set driver handler\n");
-		complete(&hif_driver_comp);
-		kfree(buffer);
-		return ret;
-	}
-	complete(&hif_driver_comp);
-	kfree(buffer);
-	return 0;
-}
-
-static void handle_set_operation_mode(struct wilc_vif *vif,
-				      struct op_mode *hif_op_mode)
-{
-	int ret = 0;
-	struct wid wid;
-
-	wid.id = (u16)WID_SET_OPERATION_MODE;
-	wid.type = WID_INT;
-	wid.val = (s8 *)&hif_op_mode->mode;
-	wid.size = sizeof(u32);
-
-	ret = wilc_send_config_pkt(vif, SET_CFG, &wid, 1,
-				   wilc_get_vif_idx(vif));
-
-	if ((hif_op_mode->mode) == IDLE_MODE)
-		complete(&hif_driver_comp);
-
-	if (ret)
-		netdev_err(vif->ndev, "Failed to set driver handler\n");
-}
-
-static void handle_set_ip_address(struct wilc_vif *vif, u8 *ip_addr, u8 idx)
-{
-	int ret = 0;
-	struct wid wid;
-	char firmware_ip_addr[4] = {0};
-
-	if (ip_addr[0] < 192)
-		ip_addr[0] = 0;
-
-	memcpy(set_ip[idx], ip_addr, IP_ALEN);
-
-	wid.id = (u16)WID_IP_ADDRESS;
-	wid.type = WID_STR;
-	wid.val = ip_addr;
-	wid.size = IP_ALEN;
-
-	ret = wilc_send_config_pkt(vif, SET_CFG, &wid, 1,
-				   wilc_get_vif_idx(vif));
-
-	host_int_get_ipaddress(vif, firmware_ip_addr, idx);
-
-	if (ret)
-		netdev_err(vif->ndev, "Failed to set IP address\n");
-}
-
-static void handle_get_ip_address(struct wilc_vif *vif, u8 idx)
-{
-	int ret = 0;
-	struct wid wid;
-
-	wid.id = (u16)WID_IP_ADDRESS;
-	wid.type = WID_STR;
-	wid.val = kmalloc(IP_ALEN, GFP_KERNEL);
-	wid.size = IP_ALEN;
-
-	ret = wilc_send_config_pkt(vif, GET_CFG, &wid, 1,
-				   wilc_get_vif_idx(vif));
-
-	memcpy(get_ip[idx], wid.val, IP_ALEN);
-
-	kfree(wid.val);
-
-	if (memcmp(get_ip[idx], set_ip[idx], IP_ALEN) != 0)
-		wilc_setup_ipaddress(vif, set_ip[idx], idx);
-
-	if (ret)
-		netdev_err(vif->ndev, "Failed to get IP address\n");
-}
-
-static void handle_get_mac_address(struct wilc_vif *vif,
-				   struct get_mac_addr *get_mac_addr)
-{
-	int ret = 0;
-	struct wid wid;
-
-	wid.id = (u16)WID_MAC_ADDR;
-	wid.type = WID_STR;
-	wid.val = get_mac_addr->mac_addr;
-	wid.size = ETH_ALEN;
-
-	ret = wilc_send_config_pkt(vif, GET_CFG, &wid, 1,
-				   wilc_get_vif_idx(vif));
-
-	if (ret)
-		netdev_err(vif->ndev, "Failed to get mac address\n");
-	complete(&hif_wait_response);
-}
-
-static void handle_cfg_param(struct wilc_vif *vif,
-			     struct cfg_param_attr *cfg_param_attr)
-{
-	int ret = 0;
-	struct wid wid_list[32];
-	struct host_if_drv *hif_drv = vif->hif_drv;
-	int i = 0;
-
-	mutex_lock(&hif_drv->cfg_values_lock);
-
-	if (cfg_param_attr->flag & BSS_TYPE) {
-		u8 bss_type = cfg_param_attr->bss_type;
-
-		if (bss_type < 6) {
-			wid_list[i].id = WID_BSS_TYPE;
-			wid_list[i].val = (s8 *)&bss_type;
-			wid_list[i].type = WID_CHAR;
-			wid_list[i].size = sizeof(char);
-			hif_drv->cfg_values.bss_type = bss_type;
-		} else {
-			netdev_err(vif->ndev, "check value 6 over\n");
-			goto unlock;
-		}
-		i++;
-	}
-	if (cfg_param_attr->flag & AUTH_TYPE) {
-		if (cfg_param_attr->auth_type == 1 ||
-		    cfg_param_attr->auth_type == 2 ||
-		    cfg_param_attr->auth_type == 5) {
-			wid_list[i].id = WID_AUTH_TYPE;
-			wid_list[i].val = (s8 *)&cfg_param_attr->auth_type;
-			wid_list[i].type = WID_CHAR;
-			wid_list[i].size = sizeof(char);
-			hif_drv->cfg_values.auth_type = (u8)cfg_param_attr->auth_type;
-		} else {
-			netdev_err(vif->ndev, "Impossible value\n");
-			goto unlock;
-		}
-		i++;
-	}
-	if (cfg_param_attr->flag & AUTHEN_TIMEOUT) {
-		if (cfg_param_attr->auth_timeout > 0 &&
-		    cfg_param_attr->auth_timeout < 65536) {
-			wid_list[i].id = WID_AUTH_TIMEOUT;
-			wid_list[i].val = (s8 *)&cfg_param_attr->auth_timeout;
-			wid_list[i].type = WID_SHORT;
-			wid_list[i].size = sizeof(u16);
-			hif_drv->cfg_values.auth_timeout = cfg_param_attr->auth_timeout;
-		} else {
-			netdev_err(vif->ndev, "Range(1 ~ 65535) over\n");
-			goto unlock;
-		}
-		i++;
-	}
-	if (cfg_param_attr->flag & POWER_MANAGEMENT) {
-		if (cfg_param_attr->power_mgmt_mode < 5) {
-			wid_list[i].id = WID_POWER_MANAGEMENT;
-			wid_list[i].val = (s8 *)&cfg_param_attr->power_mgmt_mode;
-			wid_list[i].type = WID_CHAR;
-			wid_list[i].size = sizeof(char);
-			hif_drv->cfg_values.power_mgmt_mode = (u8)cfg_param_attr->power_mgmt_mode;
-		} else {
-			netdev_err(vif->ndev, "Invalid power mode\n");
-			goto unlock;
-		}
-		i++;
-	}
-	if (cfg_param_attr->flag & RETRY_SHORT) {
-		if (cfg_param_attr->short_retry_limit > 0 &&
-		    cfg_param_attr->short_retry_limit < 256) {
-			wid_list[i].id = WID_SHORT_RETRY_LIMIT;
-			wid_list[i].val = (s8 *)&cfg_param_attr->short_retry_limit;
-			wid_list[i].type = WID_SHORT;
-			wid_list[i].size = sizeof(u16);
-			hif_drv->cfg_values.short_retry_limit = cfg_param_attr->short_retry_limit;
-		} else {
-			netdev_err(vif->ndev, "Range(1~256) over\n");
-			goto unlock;
-		}
-		i++;
-	}
-	if (cfg_param_attr->flag & RETRY_LONG) {
-		if (cfg_param_attr->long_retry_limit > 0 &&
-		    cfg_param_attr->long_retry_limit < 256) {
-			wid_list[i].id = WID_LONG_RETRY_LIMIT;
-			wid_list[i].val = (s8 *)&cfg_param_attr->long_retry_limit;
-			wid_list[i].type = WID_SHORT;
-			wid_list[i].size = sizeof(u16);
-			hif_drv->cfg_values.long_retry_limit = cfg_param_attr->long_retry_limit;
-		} else {
-			netdev_err(vif->ndev, "Range(1~256) over\n");
-			goto unlock;
-		}
-		i++;
-	}
-	if (cfg_param_attr->flag & FRAG_THRESHOLD) {
-		if (cfg_param_attr->frag_threshold > 255 &&
-		    cfg_param_attr->frag_threshold < 7937) {
-			wid_list[i].id = WID_FRAG_THRESHOLD;
-			wid_list[i].val = (s8 *)&cfg_param_attr->frag_threshold;
-			wid_list[i].type = WID_SHORT;
-			wid_list[i].size = sizeof(u16);
-			hif_drv->cfg_values.frag_threshold = cfg_param_attr->frag_threshold;
-		} else {
-			netdev_err(vif->ndev, "Threshold Range fail\n");
-			goto unlock;
-		}
-		i++;
-	}
-	if (cfg_param_attr->flag & RTS_THRESHOLD) {
-		if (cfg_param_attr->rts_threshold > 255 &&
-		    cfg_param_attr->rts_threshold < 65536) {
-			wid_list[i].id = WID_RTS_THRESHOLD;
-			wid_list[i].val = (s8 *)&cfg_param_attr->rts_threshold;
-			wid_list[i].type = WID_SHORT;
-			wid_list[i].size = sizeof(u16);
-			hif_drv->cfg_values.rts_threshold = cfg_param_attr->rts_threshold;
-		} else {
-			netdev_err(vif->ndev, "Threshold Range fail\n");
-			goto unlock;
-		}
-		i++;
-	}
-	if (cfg_param_attr->flag & PREAMBLE) {
-		if (cfg_param_attr->preamble_type < 3) {
-			wid_list[i].id = WID_PREAMBLE;
-			wid_list[i].val = (s8 *)&cfg_param_attr->preamble_type;
-			wid_list[i].type = WID_CHAR;
-			wid_list[i].size = sizeof(char);
-			hif_drv->cfg_values.preamble_type = cfg_param_attr->preamble_type;
-		} else {
-			netdev_err(vif->ndev, "Preamle Range(0~2) over\n");
-			goto unlock;
-		}
-		i++;
-	}
-	if (cfg_param_attr->flag & SHORT_SLOT_ALLOWED) {
-		if (cfg_param_attr->short_slot_allowed < 2) {
-			wid_list[i].id = WID_SHORT_SLOT_ALLOWED;
-			wid_list[i].val = (s8 *)&cfg_param_attr->short_slot_allowed;
-			wid_list[i].type = WID_CHAR;
-			wid_list[i].size = sizeof(char);
-			hif_drv->cfg_values.short_slot_allowed = (u8)cfg_param_attr->short_slot_allowed;
-		} else {
-			netdev_err(vif->ndev, "Short slot(2) over\n");
-			goto unlock;
-		}
-		i++;
-	}
-	if (cfg_param_attr->flag & TXOP_PROT_DISABLE) {
-		if (cfg_param_attr->txop_prot_disabled < 2) {
-			wid_list[i].id = WID_11N_TXOP_PROT_DISABLE;
-			wid_list[i].val = (s8 *)&cfg_param_attr->txop_prot_disabled;
-			wid_list[i].type = WID_CHAR;
-			wid_list[i].size = sizeof(char);
-			hif_drv->cfg_values.txop_prot_disabled = (u8)cfg_param_attr->txop_prot_disabled;
-		} else {
-			netdev_err(vif->ndev, "TXOP prot disable\n");
-			goto unlock;
-		}
-		i++;
-	}
-	if (cfg_param_attr->flag & BEACON_INTERVAL) {
-		if (cfg_param_attr->beacon_interval > 0 &&
-		    cfg_param_attr->beacon_interval < 65536) {
-			wid_list[i].id = WID_BEACON_INTERVAL;
-			wid_list[i].val = (s8 *)&cfg_param_attr->beacon_interval;
-			wid_list[i].type = WID_SHORT;
-			wid_list[i].size = sizeof(u16);
-			hif_drv->cfg_values.beacon_interval = cfg_param_attr->beacon_interval;
-		} else {
-			netdev_err(vif->ndev, "Beacon interval(1~65535)fail\n");
-			goto unlock;
-		}
-		i++;
-	}
-	if (cfg_param_attr->flag & DTIM_PERIOD) {
-		if (cfg_param_attr->dtim_period > 0 &&
-		    cfg_param_attr->dtim_period < 256) {
-			wid_list[i].id = WID_DTIM_PERIOD;
-			wid_list[i].val = (s8 *)&cfg_param_attr->dtim_period;
-			wid_list[i].type = WID_CHAR;
-			wid_list[i].size = sizeof(char);
-			hif_drv->cfg_values.dtim_period = cfg_param_attr->dtim_period;
-		} else {
-			netdev_err(vif->ndev, "DTIM range(1~255) fail\n");
-			goto unlock;
-		}
-		i++;
-	}
-	if (cfg_param_attr->flag & SITE_SURVEY) {
-		if (cfg_param_attr->site_survey_enabled < 3) {
-			wid_list[i].id = WID_SITE_SURVEY;
-			wid_list[i].val = (s8 *)&cfg_param_attr->site_survey_enabled;
-			wid_list[i].type = WID_CHAR;
-			wid_list[i].size = sizeof(char);
-			hif_drv->cfg_values.site_survey_enabled = (u8)cfg_param_attr->site_survey_enabled;
-		} else {
-			netdev_err(vif->ndev, "Site survey disable\n");
-			goto unlock;
-		}
-		i++;
-	}
-	if (cfg_param_attr->flag & SITE_SURVEY_SCAN_TIME) {
-		if (cfg_param_attr->site_survey_scan_time > 0 &&
-		    cfg_param_attr->site_survey_scan_time < 65536) {
-			wid_list[i].id = WID_SITE_SURVEY_SCAN_TIME;
-			wid_list[i].val = (s8 *)&cfg_param_attr->site_survey_scan_time;
-			wid_list[i].type = WID_SHORT;
-			wid_list[i].size = sizeof(u16);
-			hif_drv->cfg_values.site_survey_scan_time = cfg_param_attr->site_survey_scan_time;
-		} else {
-			netdev_err(vif->ndev, "Site scan time(1~65535) over\n");
-			goto unlock;
-		}
-		i++;
-	}
-	if (cfg_param_attr->flag & ACTIVE_SCANTIME) {
-		if (cfg_param_attr->active_scan_time > 0 &&
-		    cfg_param_attr->active_scan_time < 65536) {
-			wid_list[i].id = WID_ACTIVE_SCAN_TIME;
-			wid_list[i].val = (s8 *)&cfg_param_attr->active_scan_time;
-			wid_list[i].type = WID_SHORT;
-			wid_list[i].size = sizeof(u16);
-			hif_drv->cfg_values.active_scan_time = cfg_param_attr->active_scan_time;
-		} else {
-			netdev_err(vif->ndev, "Active time(1~65535) over\n");
-			goto unlock;
-		}
-		i++;
-	}
-	if (cfg_param_attr->flag & PASSIVE_SCANTIME) {
-		if (cfg_param_attr->passive_scan_time > 0 &&
-		    cfg_param_attr->passive_scan_time < 65536) {
-			wid_list[i].id = WID_PASSIVE_SCAN_TIME;
-			wid_list[i].val = (s8 *)&cfg_param_attr->passive_scan_time;
-			wid_list[i].type = WID_SHORT;
-			wid_list[i].size = sizeof(u16);
-			hif_drv->cfg_values.passive_scan_time = cfg_param_attr->passive_scan_time;
-		} else {
-			netdev_err(vif->ndev, "Passive time(1~65535) over\n");
-			goto unlock;
-		}
-		i++;
-	}
-	if (cfg_param_attr->flag & CURRENT_TX_RATE) {
-		enum CURRENT_TXRATE curr_tx_rate = cfg_param_attr->curr_tx_rate;
-
-		if (curr_tx_rate == AUTORATE || curr_tx_rate == MBPS_1 ||
-		    curr_tx_rate == MBPS_2 || curr_tx_rate == MBPS_5_5 ||
-		    curr_tx_rate == MBPS_11 || curr_tx_rate == MBPS_6 ||
-		    curr_tx_rate == MBPS_9 || curr_tx_rate == MBPS_12 ||
-		    curr_tx_rate == MBPS_18 || curr_tx_rate == MBPS_24 ||
-		    curr_tx_rate == MBPS_36 || curr_tx_rate == MBPS_48 ||
-		    curr_tx_rate == MBPS_54) {
-			wid_list[i].id = WID_CURRENT_TX_RATE;
-			wid_list[i].val = (s8 *)&curr_tx_rate;
-			wid_list[i].type = WID_SHORT;
-			wid_list[i].size = sizeof(u16);
-			hif_drv->cfg_values.curr_tx_rate = (u8)curr_tx_rate;
-		} else {
-			netdev_err(vif->ndev, "out of TX rate\n");
-			goto unlock;
-		}
-		i++;
-	}
-
-	ret = wilc_send_config_pkt(vif, SET_CFG, wid_list,
-				   i, wilc_get_vif_idx(vif));
-
-	if (ret)
-		netdev_err(vif->ndev, "Error in setting CFG params\n");
-
-unlock:
-	mutex_unlock(&hif_drv->cfg_values_lock);
-}
-
-static s32 handle_scan(struct wilc_vif *vif, struct scan_attr *scan_info)
-{
-	s32 result = 0;
-	struct wid wid_list[5];
-	u32 index = 0;
-	u32 i;
-	u8 *buffer;
-	u8 valuesize = 0;
-	u8 *pu8HdnNtwrksWidVal = NULL;
-	struct host_if_drv *hif_drv = vif->hif_drv;
-
-	hif_drv->usr_scan_req.scan_result = scan_info->result;
-	hif_drv->usr_scan_req.arg = scan_info->arg;
-
-	if ((hif_drv->hif_state >= HOST_IF_SCANNING) &&
-	    (hif_drv->hif_state < HOST_IF_CONNECTED)) {
-		netdev_err(vif->ndev, "Already scan\n");
-		result = -EBUSY;
-		goto ERRORHANDLER;
-	}
-
-	if (wilc_optaining_ip || wilc_connecting) {
-		netdev_err(vif->ndev, "Don't do obss scan\n");
-		result = -EBUSY;
-		goto ERRORHANDLER;
-	}
-
-	hif_drv->usr_scan_req.rcvd_ch_cnt = 0;
-
-	wid_list[index].id = (u16)WID_SSID_PROBE_REQ;
-	wid_list[index].type = WID_STR;
-
-	for (i = 0; i < scan_info->hidden_network.n_ssids; i++)
-		valuesize += ((scan_info->hidden_network.net_info[i].ssid_len) + 1);
-	pu8HdnNtwrksWidVal = kmalloc(valuesize + 1, GFP_KERNEL);
-	wid_list[index].val = pu8HdnNtwrksWidVal;
-	if (wid_list[index].val) {
-		buffer = wid_list[index].val;
-
-		*buffer++ = scan_info->hidden_network.n_ssids;
-
-		for (i = 0; i < scan_info->hidden_network.n_ssids; i++) {
-			*buffer++ = scan_info->hidden_network.net_info[i].ssid_len;
-			memcpy(buffer, scan_info->hidden_network.net_info[i].ssid, scan_info->hidden_network.net_info[i].ssid_len);
-			buffer += scan_info->hidden_network.net_info[i].ssid_len;
-		}
-
-		wid_list[index].size = (s32)(valuesize + 1);
-		index++;
-	}
-
-	wid_list[index].id = WID_INFO_ELEMENT_PROBE;
-	wid_list[index].type = WID_BIN_DATA;
-	wid_list[index].val = scan_info->ies;
-	wid_list[index].size = scan_info->ies_len;
-	index++;
-
-	wid_list[index].id = WID_SCAN_TYPE;
-	wid_list[index].type = WID_CHAR;
-	wid_list[index].size = sizeof(char);
-	wid_list[index].val = (s8 *)&scan_info->type;
-	index++;
-
-	wid_list[index].id = WID_SCAN_CHANNEL_LIST;
-	wid_list[index].type = WID_BIN_DATA;
-
-	if (scan_info->ch_freq_list &&
-	    scan_info->ch_list_len > 0) {
-		int i;
-
-		for (i = 0; i < scan_info->ch_list_len; i++)	{
-			if (scan_info->ch_freq_list[i] > 0)
-				scan_info->ch_freq_list[i] = scan_info->ch_freq_list[i] - 1;
-		}
-	}
-
-	wid_list[index].val = scan_info->ch_freq_list;
-	wid_list[index].size = scan_info->ch_list_len;
-	index++;
-
-	wid_list[index].id = WID_START_SCAN_REQ;
-	wid_list[index].type = WID_CHAR;
-	wid_list[index].size = sizeof(char);
-	wid_list[index].val = (s8 *)&scan_info->src;
-	index++;
-
-	if (hif_drv->hif_state == HOST_IF_CONNECTED)
-		scan_while_connected = true;
-	else if (hif_drv->hif_state == HOST_IF_IDLE)
-		scan_while_connected = false;
-
-	result = wilc_send_config_pkt(vif, SET_CFG, wid_list,
-				      index,
-				      wilc_get_vif_idx(vif));
-
-	if (result)
-		netdev_err(vif->ndev, "Failed to send scan parameters\n");
-
-ERRORHANDLER:
-	if (result) {
-		del_timer(&hif_drv->scan_timer);
-		Handle_ScanDone(vif, SCAN_EVENT_ABORTED);
-	}
-
-	kfree(scan_info->ch_freq_list);
-	scan_info->ch_freq_list = NULL;
-
-	kfree(scan_info->ies);
-	scan_info->ies = NULL;
-	kfree(scan_info->hidden_network.net_info);
-	scan_info->hidden_network.net_info = NULL;
-
-	kfree(pu8HdnNtwrksWidVal);
-
-	return result;
-}
-
-static s32 Handle_ScanDone(struct wilc_vif *vif,
-			   enum scan_event enuEvent)
-{
-	s32 result = 0;
-	u8 u8abort_running_scan;
-	struct wid wid;
-	struct host_if_drv *hif_drv = vif->hif_drv;
-
-	if (enuEvent == SCAN_EVENT_ABORTED) {
-		u8abort_running_scan = 1;
-		wid.id = (u16)WID_ABORT_RUNNING_SCAN;
-		wid.type = WID_CHAR;
-		wid.val = (s8 *)&u8abort_running_scan;
-		wid.size = sizeof(char);
-
-		result = wilc_send_config_pkt(vif, SET_CFG, &wid, 1,
-					      wilc_get_vif_idx(vif));
-
-		if (result) {
-			netdev_err(vif->ndev, "Failed to set abort running\n");
-			result = -EFAULT;
-		}
-	}
-
-	if (!hif_drv) {
-		netdev_err(vif->ndev, "Driver handler is NULL\n");
-		return result;
-	}
-
-	if (hif_drv->usr_scan_req.scan_result) {
-		hif_drv->usr_scan_req.scan_result(enuEvent, NULL,
-						  hif_drv->usr_scan_req.arg, NULL);
-		hif_drv->usr_scan_req.scan_result = NULL;
-	}
-
-	return result;
-}
-
-u8 wilc_connected_ssid[6] = {0};
-static s32 Handle_Connect(struct wilc_vif *vif,
-			  struct connect_attr *pstrHostIFconnectAttr)
-{
-	s32 result = 0;
-	struct wid strWIDList[8];
-	u32 u32WidsCount = 0, dummyval = 0;
-	u8 *pu8CurrByte = NULL;
-	struct join_bss_param *ptstrJoinBssParam;
-	struct host_if_drv *hif_drv = vif->hif_drv;
-
-	if (memcmp(pstrHostIFconnectAttr->bssid, wilc_connected_ssid, ETH_ALEN) == 0) {
-		result = 0;
-		netdev_err(vif->ndev, "Discard connect request\n");
-		return result;
-	}
-
-	ptstrJoinBssParam = pstrHostIFconnectAttr->params;
-	if (!ptstrJoinBssParam) {
-		netdev_err(vif->ndev, "Required BSSID not found\n");
-		result = -ENOENT;
-		goto ERRORHANDLER;
-	}
-
-	if (pstrHostIFconnectAttr->bssid) {
-		hif_drv->usr_conn_req.bssid = kmalloc(6, GFP_KERNEL);
-		memcpy(hif_drv->usr_conn_req.bssid, pstrHostIFconnectAttr->bssid, 6);
-	}
-
-	hif_drv->usr_conn_req.ssid_len = pstrHostIFconnectAttr->ssid_len;
-	if (pstrHostIFconnectAttr->ssid) {
-		hif_drv->usr_conn_req.ssid = kmalloc(pstrHostIFconnectAttr->ssid_len + 1, GFP_KERNEL);
-		memcpy(hif_drv->usr_conn_req.ssid,
-		       pstrHostIFconnectAttr->ssid,
-		       pstrHostIFconnectAttr->ssid_len);
-		hif_drv->usr_conn_req.ssid[pstrHostIFconnectAttr->ssid_len] = '\0';
-	}
-
-	hif_drv->usr_conn_req.ies_len = pstrHostIFconnectAttr->ies_len;
-	if (pstrHostIFconnectAttr->ies) {
-		hif_drv->usr_conn_req.ies = kmalloc(pstrHostIFconnectAttr->ies_len, GFP_KERNEL);
-		memcpy(hif_drv->usr_conn_req.ies,
-		       pstrHostIFconnectAttr->ies,
-		       pstrHostIFconnectAttr->ies_len);
-	}
-
-	hif_drv->usr_conn_req.security = pstrHostIFconnectAttr->security;
-	hif_drv->usr_conn_req.auth_type = pstrHostIFconnectAttr->auth_type;
-	hif_drv->usr_conn_req.conn_result = pstrHostIFconnectAttr->result;
-	hif_drv->usr_conn_req.arg = pstrHostIFconnectAttr->arg;
-
-	strWIDList[u32WidsCount].id = WID_SUCCESS_FRAME_COUNT;
-	strWIDList[u32WidsCount].type = WID_INT;
-	strWIDList[u32WidsCount].size = sizeof(u32);
-	strWIDList[u32WidsCount].val = (s8 *)(&(dummyval));
-	u32WidsCount++;
-
-	strWIDList[u32WidsCount].id = WID_RECEIVED_FRAGMENT_COUNT;
-	strWIDList[u32WidsCount].type = WID_INT;
-	strWIDList[u32WidsCount].size = sizeof(u32);
-	strWIDList[u32WidsCount].val = (s8 *)(&(dummyval));
-	u32WidsCount++;
-
-	strWIDList[u32WidsCount].id = WID_FAILED_COUNT;
-	strWIDList[u32WidsCount].type = WID_INT;
-	strWIDList[u32WidsCount].size = sizeof(u32);
-	strWIDList[u32WidsCount].val = (s8 *)(&(dummyval));
-	u32WidsCount++;
-
-	{
-		strWIDList[u32WidsCount].id = WID_INFO_ELEMENT_ASSOCIATE;
-		strWIDList[u32WidsCount].type = WID_BIN_DATA;
-		strWIDList[u32WidsCount].val = hif_drv->usr_conn_req.ies;
-		strWIDList[u32WidsCount].size = hif_drv->usr_conn_req.ies_len;
-		u32WidsCount++;
-
-		if (memcmp("DIRECT-", pstrHostIFconnectAttr->ssid, 7)) {
-			info_element_size = hif_drv->usr_conn_req.ies_len;
-			info_element = kmalloc(info_element_size, GFP_KERNEL);
-			memcpy(info_element, hif_drv->usr_conn_req.ies,
-			       info_element_size);
-		}
-	}
-	strWIDList[u32WidsCount].id = (u16)WID_11I_MODE;
-	strWIDList[u32WidsCount].type = WID_CHAR;
-	strWIDList[u32WidsCount].size = sizeof(char);
-	strWIDList[u32WidsCount].val = (s8 *)&hif_drv->usr_conn_req.security;
-	u32WidsCount++;
-
-	if (memcmp("DIRECT-", pstrHostIFconnectAttr->ssid, 7))
-		mode_11i = hif_drv->usr_conn_req.security;
-
-	strWIDList[u32WidsCount].id = (u16)WID_AUTH_TYPE;
-	strWIDList[u32WidsCount].type = WID_CHAR;
-	strWIDList[u32WidsCount].size = sizeof(char);
-	strWIDList[u32WidsCount].val = (s8 *)&hif_drv->usr_conn_req.auth_type;
-	u32WidsCount++;
-
-	if (memcmp("DIRECT-", pstrHostIFconnectAttr->ssid, 7))
-		auth_type = (u8)hif_drv->usr_conn_req.auth_type;
-
-	strWIDList[u32WidsCount].id = (u16)WID_JOIN_REQ_EXTENDED;
-	strWIDList[u32WidsCount].type = WID_STR;
-	strWIDList[u32WidsCount].size = 112;
-	strWIDList[u32WidsCount].val = kmalloc(strWIDList[u32WidsCount].size, GFP_KERNEL);
-
-	if (memcmp("DIRECT-", pstrHostIFconnectAttr->ssid, 7)) {
-		join_req_size = strWIDList[u32WidsCount].size;
-		join_req = kmalloc(join_req_size, GFP_KERNEL);
-	}
-	if (!strWIDList[u32WidsCount].val) {
-		result = -EFAULT;
-		goto ERRORHANDLER;
-	}
-
-	pu8CurrByte = strWIDList[u32WidsCount].val;
-
-	if (pstrHostIFconnectAttr->ssid) {
-		memcpy(pu8CurrByte, pstrHostIFconnectAttr->ssid, pstrHostIFconnectAttr->ssid_len);
-		pu8CurrByte[pstrHostIFconnectAttr->ssid_len] = '\0';
-	}
-	pu8CurrByte += MAX_SSID_LEN;
-	*(pu8CurrByte++) = INFRASTRUCTURE;
-
-	if ((pstrHostIFconnectAttr->ch >= 1) && (pstrHostIFconnectAttr->ch <= 14)) {
-		*(pu8CurrByte++) = pstrHostIFconnectAttr->ch;
-	} else {
-		netdev_err(vif->ndev, "Channel out of range\n");
-		*(pu8CurrByte++) = 0xFF;
-	}
-	*(pu8CurrByte++)  = (ptstrJoinBssParam->cap_info) & 0xFF;
-	*(pu8CurrByte++)  = ((ptstrJoinBssParam->cap_info) >> 8) & 0xFF;
-
-	if (pstrHostIFconnectAttr->bssid)
-		memcpy(pu8CurrByte, pstrHostIFconnectAttr->bssid, 6);
-	pu8CurrByte += 6;
-
-	if (pstrHostIFconnectAttr->bssid)
-		memcpy(pu8CurrByte, pstrHostIFconnectAttr->bssid, 6);
-	pu8CurrByte += 6;
-
-	*(pu8CurrByte++)  = (ptstrJoinBssParam->beacon_period) & 0xFF;
-	*(pu8CurrByte++)  = ((ptstrJoinBssParam->beacon_period) >> 8) & 0xFF;
-	*(pu8CurrByte++)  =  ptstrJoinBssParam->dtim_period;
-
-	memcpy(pu8CurrByte, ptstrJoinBssParam->supp_rates, MAX_RATES_SUPPORTED + 1);
-	pu8CurrByte += (MAX_RATES_SUPPORTED + 1);
-
-	*(pu8CurrByte++)  =  ptstrJoinBssParam->wmm_cap;
-	*(pu8CurrByte++)  = ptstrJoinBssParam->uapsd_cap;
-
-	*(pu8CurrByte++)  = ptstrJoinBssParam->ht_capable;
-	hif_drv->usr_conn_req.ht_capable = ptstrJoinBssParam->ht_capable;
-
-	*(pu8CurrByte++)  =  ptstrJoinBssParam->rsn_found;
-	*(pu8CurrByte++)  =  ptstrJoinBssParam->rsn_grp_policy;
-	*(pu8CurrByte++) =  ptstrJoinBssParam->mode_802_11i;
-
-	memcpy(pu8CurrByte, ptstrJoinBssParam->rsn_pcip_policy, sizeof(ptstrJoinBssParam->rsn_pcip_policy));
-	pu8CurrByte += sizeof(ptstrJoinBssParam->rsn_pcip_policy);
-
-	memcpy(pu8CurrByte, ptstrJoinBssParam->rsn_auth_policy, sizeof(ptstrJoinBssParam->rsn_auth_policy));
-	pu8CurrByte += sizeof(ptstrJoinBssParam->rsn_auth_policy);
-
-	memcpy(pu8CurrByte, ptstrJoinBssParam->rsn_cap, sizeof(ptstrJoinBssParam->rsn_cap));
-	pu8CurrByte += sizeof(ptstrJoinBssParam->rsn_cap);
-
-	*(pu8CurrByte++) = REAL_JOIN_REQ;
-	*(pu8CurrByte++) = ptstrJoinBssParam->noa_enabled;
-
-	if (ptstrJoinBssParam->noa_enabled) {
-		*(pu8CurrByte++) = (ptstrJoinBssParam->tsf) & 0xFF;
-		*(pu8CurrByte++) = ((ptstrJoinBssParam->tsf) >> 8) & 0xFF;
-		*(pu8CurrByte++) = ((ptstrJoinBssParam->tsf) >> 16) & 0xFF;
-		*(pu8CurrByte++) = ((ptstrJoinBssParam->tsf) >> 24) & 0xFF;
-
-		*(pu8CurrByte++) = ptstrJoinBssParam->opp_enabled;
-		*(pu8CurrByte++) = ptstrJoinBssParam->idx;
-
-		if (ptstrJoinBssParam->opp_enabled)
-			*(pu8CurrByte++) = ptstrJoinBssParam->ct_window;
-
-		*(pu8CurrByte++) = ptstrJoinBssParam->cnt;
-
-		memcpy(pu8CurrByte, ptstrJoinBssParam->duration, sizeof(ptstrJoinBssParam->duration));
-		pu8CurrByte += sizeof(ptstrJoinBssParam->duration);
-
-		memcpy(pu8CurrByte, ptstrJoinBssParam->interval, sizeof(ptstrJoinBssParam->interval));
-		pu8CurrByte += sizeof(ptstrJoinBssParam->interval);
-
-		memcpy(pu8CurrByte, ptstrJoinBssParam->start_time, sizeof(ptstrJoinBssParam->start_time));
-		pu8CurrByte += sizeof(ptstrJoinBssParam->start_time);
-	}
-
-	pu8CurrByte = strWIDList[u32WidsCount].val;
-	u32WidsCount++;
-
-	if (memcmp("DIRECT-", pstrHostIFconnectAttr->ssid, 7)) {
-		memcpy(join_req, pu8CurrByte, join_req_size);
-		join_req_vif = vif;
-	}
-
-	if (pstrHostIFconnectAttr->bssid)
-		memcpy(wilc_connected_ssid,
-		       pstrHostIFconnectAttr->bssid, ETH_ALEN);
-
-	result = wilc_send_config_pkt(vif, SET_CFG, strWIDList,
-				      u32WidsCount,
-				      wilc_get_vif_idx(vif));
-	if (result) {
-		netdev_err(vif->ndev, "failed to send config packet\n");
-		result = -EFAULT;
-		goto ERRORHANDLER;
-	} else {
-		hif_drv->hif_state = HOST_IF_WAITING_CONN_RESP;
-	}
-
-ERRORHANDLER:
-	if (result) {
-		struct connect_info strConnectInfo;
-
-		del_timer(&hif_drv->connect_timer);
-
-		memset(&strConnectInfo, 0, sizeof(struct connect_info));
-
-		if (pstrHostIFconnectAttr->result) {
-			if (pstrHostIFconnectAttr->bssid)
-				memcpy(strConnectInfo.bssid, pstrHostIFconnectAttr->bssid, 6);
-
-			if (pstrHostIFconnectAttr->ies) {
-				strConnectInfo.req_ies_len = pstrHostIFconnectAttr->ies_len;
-				strConnectInfo.req_ies = kmalloc(pstrHostIFconnectAttr->ies_len, GFP_KERNEL);
-				memcpy(strConnectInfo.req_ies,
-				       pstrHostIFconnectAttr->ies,
-				       pstrHostIFconnectAttr->ies_len);
-			}
-
-			pstrHostIFconnectAttr->result(CONN_DISCONN_EVENT_CONN_RESP,
-							       &strConnectInfo,
-							       MAC_DISCONNECTED,
-							       NULL,
-							       pstrHostIFconnectAttr->arg);
-			hif_drv->hif_state = HOST_IF_IDLE;
-			kfree(strConnectInfo.req_ies);
-			strConnectInfo.req_ies = NULL;
-
-		} else {
-			netdev_err(vif->ndev, "Connect callback is NULL\n");
-		}
-	}
-
-	kfree(pstrHostIFconnectAttr->bssid);
-	pstrHostIFconnectAttr->bssid = NULL;
-
-	kfree(pstrHostIFconnectAttr->ssid);
-	pstrHostIFconnectAttr->ssid = NULL;
-
-	kfree(pstrHostIFconnectAttr->ies);
-	pstrHostIFconnectAttr->ies = NULL;
-
-	kfree(pu8CurrByte);
-	return result;
-}
-
-static s32 Handle_ConnectTimeout(struct wilc_vif *vif)
-{
-	s32 result = 0;
-	struct connect_info strConnectInfo;
-	struct wid wid;
-	u16 u16DummyReasonCode = 0;
-	struct host_if_drv *hif_drv = vif->hif_drv;
-
-	if (!hif_drv) {
-		netdev_err(vif->ndev, "Driver handler is NULL\n");
-		return result;
-	}
-
-	hif_drv->hif_state = HOST_IF_IDLE;
-
-	scan_while_connected = false;
-
-	memset(&strConnectInfo, 0, sizeof(struct connect_info));
-
-	if (hif_drv->usr_conn_req.conn_result) {
-		if (hif_drv->usr_conn_req.bssid) {
-			memcpy(strConnectInfo.bssid,
-			       hif_drv->usr_conn_req.bssid, 6);
-		}
-
-		if (hif_drv->usr_conn_req.ies) {
-			strConnectInfo.req_ies_len = hif_drv->usr_conn_req.ies_len;
-			strConnectInfo.req_ies = kmalloc(hif_drv->usr_conn_req.ies_len, GFP_KERNEL);
-			memcpy(strConnectInfo.req_ies,
-			       hif_drv->usr_conn_req.ies,
-			       hif_drv->usr_conn_req.ies_len);
-		}
-
-		hif_drv->usr_conn_req.conn_result(CONN_DISCONN_EVENT_CONN_RESP,
-						  &strConnectInfo,
-						  MAC_DISCONNECTED,
-						  NULL,
-						  hif_drv->usr_conn_req.arg);
-
-		kfree(strConnectInfo.req_ies);
-		strConnectInfo.req_ies = NULL;
-	} else {
-		netdev_err(vif->ndev, "Connect callback is NULL\n");
-	}
-
-	wid.id = (u16)WID_DISCONNECT;
-	wid.type = WID_CHAR;
-	wid.val = (s8 *)&u16DummyReasonCode;
-	wid.size = sizeof(char);
-
-	result = wilc_send_config_pkt(vif, SET_CFG, &wid, 1,
-				      wilc_get_vif_idx(vif));
-	if (result)
-		netdev_err(vif->ndev, "Failed to send disconnect\n");
-
-	hif_drv->usr_conn_req.ssid_len = 0;
-	kfree(hif_drv->usr_conn_req.ssid);
-	hif_drv->usr_conn_req.ssid = NULL;
-	kfree(hif_drv->usr_conn_req.bssid);
-	hif_drv->usr_conn_req.bssid = NULL;
-	hif_drv->usr_conn_req.ies_len = 0;
-	kfree(hif_drv->usr_conn_req.ies);
-	hif_drv->usr_conn_req.ies = NULL;
-
-	eth_zero_addr(wilc_connected_ssid);
-
-	if (join_req && join_req_vif == vif) {
-		kfree(join_req);
-		join_req = NULL;
-	}
-
-	if (info_element && join_req_vif == vif) {
-		kfree(info_element);
-		info_element = NULL;
-	}
-
-	return result;
-}
-
-static s32 Handle_RcvdNtwrkInfo(struct wilc_vif *vif,
-				struct rcvd_net_info *pstrRcvdNetworkInfo)
-{
-	u32 i;
-	bool bNewNtwrkFound;
-	s32 result = 0;
-	struct network_info *pstrNetworkInfo = NULL;
-	void *pJoinParams = NULL;
-	struct host_if_drv *hif_drv = vif->hif_drv;
-
-	bNewNtwrkFound = true;
-
-	if (hif_drv->usr_scan_req.scan_result) {
-		wilc_parse_network_info(pstrRcvdNetworkInfo->buffer, &pstrNetworkInfo);
-		if ((!pstrNetworkInfo) ||
-		    (!hif_drv->usr_scan_req.scan_result)) {
-			netdev_err(vif->ndev, "driver is null\n");
-			result = -EINVAL;
-			goto done;
-		}
-
-		for (i = 0; i < hif_drv->usr_scan_req.rcvd_ch_cnt; i++) {
-			if (memcmp(hif_drv->usr_scan_req.net_info[i].bssid,
-				   pstrNetworkInfo->bssid, 6) == 0) {
-				if (pstrNetworkInfo->rssi <= hif_drv->usr_scan_req.net_info[i].rssi) {
-					goto done;
-				} else {
-					hif_drv->usr_scan_req.net_info[i].rssi = pstrNetworkInfo->rssi;
-					bNewNtwrkFound = false;
-					break;
-				}
-			}
-		}
-
-		if (bNewNtwrkFound) {
-			if (hif_drv->usr_scan_req.rcvd_ch_cnt < MAX_NUM_SCANNED_NETWORKS) {
-				hif_drv->usr_scan_req.net_info[hif_drv->usr_scan_req.rcvd_ch_cnt].rssi = pstrNetworkInfo->rssi;
-
-				memcpy(hif_drv->usr_scan_req.net_info[hif_drv->usr_scan_req.rcvd_ch_cnt].bssid,
-				       pstrNetworkInfo->bssid, 6);
-
-				hif_drv->usr_scan_req.rcvd_ch_cnt++;
-
-				pstrNetworkInfo->new_network = true;
-				pJoinParams = host_int_ParseJoinBssParam(pstrNetworkInfo);
-
-				hif_drv->usr_scan_req.scan_result(SCAN_EVENT_NETWORK_FOUND, pstrNetworkInfo,
-								  hif_drv->usr_scan_req.arg,
-								  pJoinParams);
-			}
-		} else {
-			pstrNetworkInfo->new_network = false;
-			hif_drv->usr_scan_req.scan_result(SCAN_EVENT_NETWORK_FOUND, pstrNetworkInfo,
-							  hif_drv->usr_scan_req.arg, NULL);
-		}
-	}
-
-done:
-	kfree(pstrRcvdNetworkInfo->buffer);
-	pstrRcvdNetworkInfo->buffer = NULL;
-
-	if (pstrNetworkInfo) {
-		kfree(pstrNetworkInfo->ies);
-		kfree(pstrNetworkInfo);
-	}
-
-	return result;
-}
-
-static s32 host_int_get_assoc_res_info(struct wilc_vif *vif,
-				       u8 *pu8AssocRespInfo,
-				       u32 u32MaxAssocRespInfoLen,
-				       u32 *pu32RcvdAssocRespInfoLen);
-
-static s32 Handle_RcvdGnrlAsyncInfo(struct wilc_vif *vif,
-				    struct rcvd_async_info *pstrRcvdGnrlAsyncInfo)
-{
-	s32 result = 0;
-	u8 u8MsgType = 0;
-	u8 u8MsgID = 0;
-	u16 u16MsgLen = 0;
-	u16 u16WidID = (u16)WID_NIL;
-	u8 u8WidLen  = 0;
-	u8 u8MacStatus;
-	u8 u8MacStatusReasonCode;
-	u8 u8MacStatusAdditionalInfo;
-	struct connect_info strConnectInfo;
-	struct disconnect_info strDisconnectNotifInfo;
-	s32 s32Err = 0;
-	struct host_if_drv *hif_drv = vif->hif_drv;
-
-	if (!hif_drv) {
-		netdev_err(vif->ndev, "Driver handler is NULL\n");
-		return -ENODEV;
-	}
-
-	if ((hif_drv->hif_state == HOST_IF_WAITING_CONN_RESP) ||
-	    (hif_drv->hif_state == HOST_IF_CONNECTED) ||
-	    hif_drv->usr_scan_req.scan_result) {
-		if (!pstrRcvdGnrlAsyncInfo->buffer ||
-		    !hif_drv->usr_conn_req.conn_result) {
-			netdev_err(vif->ndev, "driver is null\n");
-			return -EINVAL;
-		}
-
-		u8MsgType = pstrRcvdGnrlAsyncInfo->buffer[0];
-
-		if ('I' != u8MsgType) {
-			netdev_err(vif->ndev, "Received Message incorrect.\n");
-			return -EFAULT;
-		}
-
-		u8MsgID = pstrRcvdGnrlAsyncInfo->buffer[1];
-		u16MsgLen = MAKE_WORD16(pstrRcvdGnrlAsyncInfo->buffer[2], pstrRcvdGnrlAsyncInfo->buffer[3]);
-		u16WidID = MAKE_WORD16(pstrRcvdGnrlAsyncInfo->buffer[4], pstrRcvdGnrlAsyncInfo->buffer[5]);
-		u8WidLen = pstrRcvdGnrlAsyncInfo->buffer[6];
-		u8MacStatus  = pstrRcvdGnrlAsyncInfo->buffer[7];
-		u8MacStatusReasonCode = pstrRcvdGnrlAsyncInfo->buffer[8];
-		u8MacStatusAdditionalInfo = pstrRcvdGnrlAsyncInfo->buffer[9];
-		if (hif_drv->hif_state == HOST_IF_WAITING_CONN_RESP) {
-			u32 u32RcvdAssocRespInfoLen = 0;
-			struct connect_resp_info *pstrConnectRespInfo = NULL;
-
-			memset(&strConnectInfo, 0, sizeof(struct connect_info));
-
-			if (u8MacStatus == MAC_CONNECTED) {
-				memset(rcv_assoc_resp, 0, MAX_ASSOC_RESP_FRAME_SIZE);
-
-				host_int_get_assoc_res_info(vif,
-							    rcv_assoc_resp,
-							    MAX_ASSOC_RESP_FRAME_SIZE,
-							    &u32RcvdAssocRespInfoLen);
-
-				if (u32RcvdAssocRespInfoLen != 0) {
-					s32Err = wilc_parse_assoc_resp_info(rcv_assoc_resp, u32RcvdAssocRespInfoLen,
-									    &pstrConnectRespInfo);
-					if (s32Err) {
-						netdev_err(vif->ndev, "wilc_parse_assoc_resp_info() returned error %d\n", s32Err);
-					} else {
-						strConnectInfo.status = pstrConnectRespInfo->status;
-
-						if (strConnectInfo.status == SUCCESSFUL_STATUSCODE && pstrConnectRespInfo->ies) {
-							strConnectInfo.resp_ies_len = pstrConnectRespInfo->ies_len;
-							strConnectInfo.resp_ies = kmalloc(pstrConnectRespInfo->ies_len, GFP_KERNEL);
-							memcpy(strConnectInfo.resp_ies, pstrConnectRespInfo->ies,
-							       pstrConnectRespInfo->ies_len);
-						}
-
-						if (pstrConnectRespInfo) {
-							kfree(pstrConnectRespInfo->ies);
-							kfree(pstrConnectRespInfo);
-						}
-					}
-				}
-			}
-
-			if ((u8MacStatus == MAC_CONNECTED) &&
-			    (strConnectInfo.status != SUCCESSFUL_STATUSCODE))	{
-				netdev_err(vif->ndev, "Received MAC status is MAC_CONNECTED while the received status code in Asoc Resp is not SUCCESSFUL_STATUSCODE\n");
-				eth_zero_addr(wilc_connected_ssid);
-			} else if (u8MacStatus == MAC_DISCONNECTED)    {
-				netdev_err(vif->ndev, "Received MAC status is MAC_DISCONNECTED\n");
-				eth_zero_addr(wilc_connected_ssid);
-			}
-
-			if (hif_drv->usr_conn_req.bssid) {
-				memcpy(strConnectInfo.bssid, hif_drv->usr_conn_req.bssid, 6);
-
-				if ((u8MacStatus == MAC_CONNECTED) &&
-				    (strConnectInfo.status == SUCCESSFUL_STATUSCODE))	{
-					memcpy(hif_drv->assoc_bssid,
-					       hif_drv->usr_conn_req.bssid, ETH_ALEN);
-				}
-			}
-
-			if (hif_drv->usr_conn_req.ies) {
-				strConnectInfo.req_ies_len = hif_drv->usr_conn_req.ies_len;
-				strConnectInfo.req_ies = kmalloc(hif_drv->usr_conn_req.ies_len, GFP_KERNEL);
-				memcpy(strConnectInfo.req_ies,
-				       hif_drv->usr_conn_req.ies,
-				       hif_drv->usr_conn_req.ies_len);
-			}
-
-			del_timer(&hif_drv->connect_timer);
-			hif_drv->usr_conn_req.conn_result(CONN_DISCONN_EVENT_CONN_RESP,
-							  &strConnectInfo,
-							  u8MacStatus,
-							  NULL,
-							  hif_drv->usr_conn_req.arg);
-
-			if ((u8MacStatus == MAC_CONNECTED) &&
-			    (strConnectInfo.status == SUCCESSFUL_STATUSCODE))	{
-				wilc_set_power_mgmt(vif, 0, 0);
-
-				hif_drv->hif_state = HOST_IF_CONNECTED;
-
-				wilc_optaining_ip = true;
-				mod_timer(&wilc_during_ip_timer,
-					  jiffies + msecs_to_jiffies(10000));
-			} else {
-				hif_drv->hif_state = HOST_IF_IDLE;
-				scan_while_connected = false;
-			}
-
-			kfree(strConnectInfo.resp_ies);
-			strConnectInfo.resp_ies = NULL;
-
-			kfree(strConnectInfo.req_ies);
-			strConnectInfo.req_ies = NULL;
-			hif_drv->usr_conn_req.ssid_len = 0;
-			kfree(hif_drv->usr_conn_req.ssid);
-			hif_drv->usr_conn_req.ssid = NULL;
-			kfree(hif_drv->usr_conn_req.bssid);
-			hif_drv->usr_conn_req.bssid = NULL;
-			hif_drv->usr_conn_req.ies_len = 0;
-			kfree(hif_drv->usr_conn_req.ies);
-			hif_drv->usr_conn_req.ies = NULL;
-		} else if ((u8MacStatus == MAC_DISCONNECTED) &&
-			   (hif_drv->hif_state == HOST_IF_CONNECTED)) {
-			memset(&strDisconnectNotifInfo, 0, sizeof(struct disconnect_info));
-
-			if (hif_drv->usr_scan_req.scan_result) {
-				del_timer(&hif_drv->scan_timer);
-				Handle_ScanDone(vif, SCAN_EVENT_ABORTED);
-			}
-
-			strDisconnectNotifInfo.reason = 0;
-			strDisconnectNotifInfo.ie = NULL;
-			strDisconnectNotifInfo.ie_len = 0;
-
-			if (hif_drv->usr_conn_req.conn_result) {
-				wilc_optaining_ip = false;
-				wilc_set_power_mgmt(vif, 0, 0);
-
-				hif_drv->usr_conn_req.conn_result(CONN_DISCONN_EVENT_DISCONN_NOTIF,
-								  NULL,
-								  0,
-								  &strDisconnectNotifInfo,
-								  hif_drv->usr_conn_req.arg);
-			} else {
-				netdev_err(vif->ndev, "Connect result NULL\n");
-			}
-
-			eth_zero_addr(hif_drv->assoc_bssid);
-
-			hif_drv->usr_conn_req.ssid_len = 0;
-			kfree(hif_drv->usr_conn_req.ssid);
-			hif_drv->usr_conn_req.ssid = NULL;
-			kfree(hif_drv->usr_conn_req.bssid);
-			hif_drv->usr_conn_req.bssid = NULL;
-			hif_drv->usr_conn_req.ies_len = 0;
-			kfree(hif_drv->usr_conn_req.ies);
-			hif_drv->usr_conn_req.ies = NULL;
-
-			if (join_req && join_req_vif == vif) {
-				kfree(join_req);
-				join_req = NULL;
-			}
-
-			if (info_element && join_req_vif == vif) {
-				kfree(info_element);
-				info_element = NULL;
-			}
-
-			hif_drv->hif_state = HOST_IF_IDLE;
-			scan_while_connected = false;
-
-		} else if ((u8MacStatus == MAC_DISCONNECTED) &&
-			   (hif_drv->usr_scan_req.scan_result)) {
-			del_timer(&hif_drv->scan_timer);
-			if (hif_drv->usr_scan_req.scan_result)
-				Handle_ScanDone(vif, SCAN_EVENT_ABORTED);
-		}
-	}
-
-	kfree(pstrRcvdGnrlAsyncInfo->buffer);
-	pstrRcvdGnrlAsyncInfo->buffer = NULL;
-
-	return result;
-}
-
-static int Handle_Key(struct wilc_vif *vif,
-		      struct key_attr *pstrHostIFkeyAttr)
-{
-	s32 result = 0;
-	struct wid wid;
-	struct wid strWIDList[5];
-	u8 i;
-	u8 *pu8keybuf;
-	s8 s8idxarray[1];
-	s8 ret = 0;
-	struct host_if_drv *hif_drv = vif->hif_drv;
-
-	switch (pstrHostIFkeyAttr->type) {
-	case WEP:
-
-		if (pstrHostIFkeyAttr->action & ADDKEY_AP) {
-			strWIDList[0].id = (u16)WID_11I_MODE;
-			strWIDList[0].type = WID_CHAR;
-			strWIDList[0].size = sizeof(char);
-			strWIDList[0].val = (s8 *)&pstrHostIFkeyAttr->attr.wep.mode;
-
-			strWIDList[1].id = WID_AUTH_TYPE;
-			strWIDList[1].type = WID_CHAR;
-			strWIDList[1].size = sizeof(char);
-			strWIDList[1].val = (s8 *)&pstrHostIFkeyAttr->attr.wep.auth_type;
-
-			pu8keybuf = kmalloc(pstrHostIFkeyAttr->attr.wep.key_len + 2,
-					    GFP_KERNEL);
-			if (!pu8keybuf)
-				return -ENOMEM;
-
-			pu8keybuf[0] = pstrHostIFkeyAttr->attr.wep.index;
-			pu8keybuf[1] = pstrHostIFkeyAttr->attr.wep.key_len;
-
-			memcpy(&pu8keybuf[2], pstrHostIFkeyAttr->attr.wep.key,
-			       pstrHostIFkeyAttr->attr.wep.key_len);
-
-			kfree(pstrHostIFkeyAttr->attr.wep.key);
-
-			strWIDList[2].id = (u16)WID_WEP_KEY_VALUE;
-			strWIDList[2].type = WID_STR;
-			strWIDList[2].size = pstrHostIFkeyAttr->attr.wep.key_len + 2;
-			strWIDList[2].val = (s8 *)pu8keybuf;
-
-			result = wilc_send_config_pkt(vif, SET_CFG,
-						      strWIDList, 3,
-						      wilc_get_vif_idx(vif));
-			kfree(pu8keybuf);
-		} else if (pstrHostIFkeyAttr->action & ADDKEY) {
-			pu8keybuf = kmalloc(pstrHostIFkeyAttr->attr.wep.key_len + 2, GFP_KERNEL);
-			if (!pu8keybuf)
-				return -ENOMEM;
-			pu8keybuf[0] = pstrHostIFkeyAttr->attr.wep.index;
-			memcpy(pu8keybuf + 1, &pstrHostIFkeyAttr->attr.wep.key_len, 1);
-			memcpy(pu8keybuf + 2, pstrHostIFkeyAttr->attr.wep.key,
-			       pstrHostIFkeyAttr->attr.wep.key_len);
-			kfree(pstrHostIFkeyAttr->attr.wep.key);
-
-			wid.id = (u16)WID_ADD_WEP_KEY;
-			wid.type = WID_STR;
-			wid.val = (s8 *)pu8keybuf;
-			wid.size = pstrHostIFkeyAttr->attr.wep.key_len + 2;
-
-			result = wilc_send_config_pkt(vif, SET_CFG,
-						      &wid, 1,
-						      wilc_get_vif_idx(vif));
-			kfree(pu8keybuf);
-		} else if (pstrHostIFkeyAttr->action & REMOVEKEY) {
-			wid.id = (u16)WID_REMOVE_WEP_KEY;
-			wid.type = WID_STR;
-
-			s8idxarray[0] = (s8)pstrHostIFkeyAttr->attr.wep.index;
-			wid.val = s8idxarray;
-			wid.size = 1;
-
-			result = wilc_send_config_pkt(vif, SET_CFG,
-						      &wid, 1,
-						      wilc_get_vif_idx(vif));
-		} else if (pstrHostIFkeyAttr->action & DEFAULTKEY) {
-			wid.id = (u16)WID_KEY_ID;
-			wid.type = WID_CHAR;
-			wid.val = (s8 *)&pstrHostIFkeyAttr->attr.wep.index;
-			wid.size = sizeof(char);
-
-			result = wilc_send_config_pkt(vif, SET_CFG,
-						      &wid, 1,
-						      wilc_get_vif_idx(vif));
-		}
-		complete(&hif_drv->comp_test_key_block);
-		break;
-
-	case WPA_RX_GTK:
-		if (pstrHostIFkeyAttr->action & ADDKEY_AP) {
-			pu8keybuf = kzalloc(RX_MIC_KEY_MSG_LEN, GFP_KERNEL);
-			if (!pu8keybuf) {
-				ret = -ENOMEM;
-				goto _WPARxGtk_end_case_;
-			}
-
-			if (pstrHostIFkeyAttr->attr.wpa.seq)
-				memcpy(pu8keybuf + 6, pstrHostIFkeyAttr->attr.wpa.seq, 8);
-
-			memcpy(pu8keybuf + 14, &pstrHostIFkeyAttr->attr.wpa.index, 1);
-			memcpy(pu8keybuf + 15, &pstrHostIFkeyAttr->attr.wpa.key_len, 1);
-			memcpy(pu8keybuf + 16, pstrHostIFkeyAttr->attr.wpa.key,
-			       pstrHostIFkeyAttr->attr.wpa.key_len);
-
-			strWIDList[0].id = (u16)WID_11I_MODE;
-			strWIDList[0].type = WID_CHAR;
-			strWIDList[0].size = sizeof(char);
-			strWIDList[0].val = (s8 *)&pstrHostIFkeyAttr->attr.wpa.mode;
-
-			strWIDList[1].id = (u16)WID_ADD_RX_GTK;
-			strWIDList[1].type = WID_STR;
-			strWIDList[1].val = (s8 *)pu8keybuf;
-			strWIDList[1].size = RX_MIC_KEY_MSG_LEN;
-
-			result = wilc_send_config_pkt(vif, SET_CFG,
-						      strWIDList, 2,
-						      wilc_get_vif_idx(vif));
-
-			kfree(pu8keybuf);
-			complete(&hif_drv->comp_test_key_block);
-		} else if (pstrHostIFkeyAttr->action & ADDKEY) {
-			pu8keybuf = kzalloc(RX_MIC_KEY_MSG_LEN, GFP_KERNEL);
-			if (!pu8keybuf) {
-				ret = -ENOMEM;
-				goto _WPARxGtk_end_case_;
-			}
-
-			if (hif_drv->hif_state == HOST_IF_CONNECTED)
-				memcpy(pu8keybuf, hif_drv->assoc_bssid, ETH_ALEN);
-			else
-				netdev_err(vif->ndev, "Couldn't handle\n");
-
-			memcpy(pu8keybuf + 6, pstrHostIFkeyAttr->attr.wpa.seq, 8);
-			memcpy(pu8keybuf + 14, &pstrHostIFkeyAttr->attr.wpa.index, 1);
-			memcpy(pu8keybuf + 15, &pstrHostIFkeyAttr->attr.wpa.key_len, 1);
-			memcpy(pu8keybuf + 16, pstrHostIFkeyAttr->attr.wpa.key,
-			       pstrHostIFkeyAttr->attr.wpa.key_len);
-
-			wid.id = (u16)WID_ADD_RX_GTK;
-			wid.type = WID_STR;
-			wid.val = (s8 *)pu8keybuf;
-			wid.size = RX_MIC_KEY_MSG_LEN;
-
-			result = wilc_send_config_pkt(vif, SET_CFG,
-						      &wid, 1,
-						      wilc_get_vif_idx(vif));
-
-			kfree(pu8keybuf);
-			complete(&hif_drv->comp_test_key_block);
-		}
-_WPARxGtk_end_case_:
-		kfree(pstrHostIFkeyAttr->attr.wpa.key);
-		kfree(pstrHostIFkeyAttr->attr.wpa.seq);
-		if (ret)
-			return ret;
-
-		break;
-
-	case WPA_PTK:
-		if (pstrHostIFkeyAttr->action & ADDKEY_AP) {
-			pu8keybuf = kmalloc(PTK_KEY_MSG_LEN + 1, GFP_KERNEL);
-			if (!pu8keybuf) {
-				ret = -ENOMEM;
-				goto _WPAPtk_end_case_;
-			}
-
-			memcpy(pu8keybuf, pstrHostIFkeyAttr->attr.wpa.mac_addr, 6);
-			memcpy(pu8keybuf + 6, &pstrHostIFkeyAttr->attr.wpa.index, 1);
-			memcpy(pu8keybuf + 7, &pstrHostIFkeyAttr->attr.wpa.key_len, 1);
-			memcpy(pu8keybuf + 8, pstrHostIFkeyAttr->attr.wpa.key,
-			       pstrHostIFkeyAttr->attr.wpa.key_len);
-
-			strWIDList[0].id = (u16)WID_11I_MODE;
-			strWIDList[0].type = WID_CHAR;
-			strWIDList[0].size = sizeof(char);
-			strWIDList[0].val = (s8 *)&pstrHostIFkeyAttr->attr.wpa.mode;
-
-			strWIDList[1].id = (u16)WID_ADD_PTK;
-			strWIDList[1].type = WID_STR;
-			strWIDList[1].val = (s8 *)pu8keybuf;
-			strWIDList[1].size = PTK_KEY_MSG_LEN + 1;
-
-			result = wilc_send_config_pkt(vif, SET_CFG,
-						      strWIDList, 2,
-						      wilc_get_vif_idx(vif));
-			kfree(pu8keybuf);
-			complete(&hif_drv->comp_test_key_block);
-		} else if (pstrHostIFkeyAttr->action & ADDKEY) {
-			pu8keybuf = kmalloc(PTK_KEY_MSG_LEN, GFP_KERNEL);
-			if (!pu8keybuf) {
-				netdev_err(vif->ndev, "No buffer send PTK\n");
-				ret = -ENOMEM;
-				goto _WPAPtk_end_case_;
-			}
-
-			memcpy(pu8keybuf, pstrHostIFkeyAttr->attr.wpa.mac_addr, 6);
-			memcpy(pu8keybuf + 6, &pstrHostIFkeyAttr->attr.wpa.key_len, 1);
-			memcpy(pu8keybuf + 7, pstrHostIFkeyAttr->attr.wpa.key,
-			       pstrHostIFkeyAttr->attr.wpa.key_len);
-
-			wid.id = (u16)WID_ADD_PTK;
-			wid.type = WID_STR;
-			wid.val = (s8 *)pu8keybuf;
-			wid.size = PTK_KEY_MSG_LEN;
-
-			result = wilc_send_config_pkt(vif, SET_CFG,
-						      &wid, 1,
-						      wilc_get_vif_idx(vif));
-			kfree(pu8keybuf);
-			complete(&hif_drv->comp_test_key_block);
-		}
-
-_WPAPtk_end_case_:
-		kfree(pstrHostIFkeyAttr->attr.wpa.key);
-		if (ret)
-			return ret;
-
-		break;
-
-	case PMKSA:
-		pu8keybuf = kmalloc((pstrHostIFkeyAttr->attr.pmkid.numpmkid * PMKSA_KEY_LEN) + 1, GFP_KERNEL);
-		if (!pu8keybuf)
-			return -ENOMEM;
-
-		pu8keybuf[0] = pstrHostIFkeyAttr->attr.pmkid.numpmkid;
-
-		for (i = 0; i < pstrHostIFkeyAttr->attr.pmkid.numpmkid; i++) {
-			memcpy(pu8keybuf + ((PMKSA_KEY_LEN * i) + 1), pstrHostIFkeyAttr->attr.pmkid.pmkidlist[i].bssid, ETH_ALEN);
-			memcpy(pu8keybuf + ((PMKSA_KEY_LEN * i) + ETH_ALEN + 1), pstrHostIFkeyAttr->attr.pmkid.pmkidlist[i].pmkid, PMKID_LEN);
-		}
-
-		wid.id = (u16)WID_PMKID_INFO;
-		wid.type = WID_STR;
-		wid.val = (s8 *)pu8keybuf;
-		wid.size = (pstrHostIFkeyAttr->attr.pmkid.numpmkid * PMKSA_KEY_LEN) + 1;
-
-		result = wilc_send_config_pkt(vif, SET_CFG, &wid, 1,
-					      wilc_get_vif_idx(vif));
-
-		kfree(pu8keybuf);
-		break;
-	}
-
-	if (result)
-		netdev_err(vif->ndev, "Failed to send key config packet\n");
-
-	return result;
-}
-
-static void Handle_Disconnect(struct wilc_vif *vif)
-{
-	struct wid wid;
-	struct host_if_drv *hif_drv = vif->hif_drv;
-
-	s32 result = 0;
-	u16 u16DummyReasonCode = 0;
-
-	wid.id = (u16)WID_DISCONNECT;
-	wid.type = WID_CHAR;
-	wid.val = (s8 *)&u16DummyReasonCode;
-	wid.size = sizeof(char);
-
-	wilc_optaining_ip = false;
-	wilc_set_power_mgmt(vif, 0, 0);
-
-	eth_zero_addr(wilc_connected_ssid);
-
-	result = wilc_send_config_pkt(vif, SET_CFG, &wid, 1,
-				      wilc_get_vif_idx(vif));
-
-	if (result) {
-		netdev_err(vif->ndev, "Failed to send dissconect\n");
-	} else {
-		struct disconnect_info strDisconnectNotifInfo;
-
-		memset(&strDisconnectNotifInfo, 0, sizeof(struct disconnect_info));
-
-		strDisconnectNotifInfo.reason = 0;
-		strDisconnectNotifInfo.ie = NULL;
-		strDisconnectNotifInfo.ie_len = 0;
-
-		if (hif_drv->usr_scan_req.scan_result) {
-			del_timer(&hif_drv->scan_timer);
-			hif_drv->usr_scan_req.scan_result(SCAN_EVENT_ABORTED,
-							  NULL,
-							  hif_drv->usr_scan_req.arg,
-							  NULL);
-			hif_drv->usr_scan_req.scan_result = NULL;
-		}
-
-		if (hif_drv->usr_conn_req.conn_result) {
-			if (hif_drv->hif_state == HOST_IF_WAITING_CONN_RESP)
-				del_timer(&hif_drv->connect_timer);
-
-			hif_drv->usr_conn_req.conn_result(CONN_DISCONN_EVENT_DISCONN_NOTIF,
-							  NULL,
-							  0,
-							  &strDisconnectNotifInfo,
-							  hif_drv->usr_conn_req.arg);
-		} else {
-			netdev_err(vif->ndev, "conn_result = NULL\n");
-		}
-
-		scan_while_connected = false;
-
-		hif_drv->hif_state = HOST_IF_IDLE;
-
-		eth_zero_addr(hif_drv->assoc_bssid);
-
-		hif_drv->usr_conn_req.ssid_len = 0;
-		kfree(hif_drv->usr_conn_req.ssid);
-		hif_drv->usr_conn_req.ssid = NULL;
-		kfree(hif_drv->usr_conn_req.bssid);
-		hif_drv->usr_conn_req.bssid = NULL;
-		hif_drv->usr_conn_req.ies_len = 0;
-		kfree(hif_drv->usr_conn_req.ies);
-		hif_drv->usr_conn_req.ies = NULL;
-
-		if (join_req && join_req_vif == vif) {
-			kfree(join_req);
-			join_req = NULL;
-		}
-
-		if (info_element && join_req_vif == vif) {
-			kfree(info_element);
-			info_element = NULL;
-		}
-	}
-
-	complete(&hif_drv->comp_test_disconn_block);
-}
-
-void wilc_resolve_disconnect_aberration(struct wilc_vif *vif)
-{
-	if (!vif->hif_drv)
-		return;
-	if ((vif->hif_drv->hif_state == HOST_IF_WAITING_CONN_RESP) ||
-	    (vif->hif_drv->hif_state == HOST_IF_CONNECTING))
-		wilc_disconnect(vif, 1);
-}
-
-static void Handle_GetRssi(struct wilc_vif *vif)
-{
-	s32 result = 0;
-	struct wid wid;
-
-	wid.id = (u16)WID_RSSI;
-	wid.type = WID_CHAR;
-	wid.val = &rssi;
-	wid.size = sizeof(char);
-
-	result = wilc_send_config_pkt(vif, GET_CFG, &wid, 1,
-				      wilc_get_vif_idx(vif));
-	if (result) {
-		netdev_err(vif->ndev, "Failed to get RSSI value\n");
-		result = -EFAULT;
-	}
-
-	complete(&vif->hif_drv->comp_get_rssi);
-}
-
-static s32 Handle_GetStatistics(struct wilc_vif *vif,
-				struct rf_info *pstrStatistics)
-{
-	struct wid strWIDList[5];
-	u32 u32WidsCount = 0, result = 0;
-
-	strWIDList[u32WidsCount].id = WID_LINKSPEED;
-	strWIDList[u32WidsCount].type = WID_CHAR;
-	strWIDList[u32WidsCount].size = sizeof(char);
-	strWIDList[u32WidsCount].val = (s8 *)&pstrStatistics->link_speed;
-	u32WidsCount++;
-
-	strWIDList[u32WidsCount].id = WID_RSSI;
-	strWIDList[u32WidsCount].type = WID_CHAR;
-	strWIDList[u32WidsCount].size = sizeof(char);
-	strWIDList[u32WidsCount].val = (s8 *)&pstrStatistics->rssi;
-	u32WidsCount++;
-
-	strWIDList[u32WidsCount].id = WID_SUCCESS_FRAME_COUNT;
-	strWIDList[u32WidsCount].type = WID_INT;
-	strWIDList[u32WidsCount].size = sizeof(u32);
-	strWIDList[u32WidsCount].val = (s8 *)&pstrStatistics->tx_cnt;
-	u32WidsCount++;
-
-	strWIDList[u32WidsCount].id = WID_RECEIVED_FRAGMENT_COUNT;
-	strWIDList[u32WidsCount].type = WID_INT;
-	strWIDList[u32WidsCount].size = sizeof(u32);
-	strWIDList[u32WidsCount].val = (s8 *)&pstrStatistics->rx_cnt;
-	u32WidsCount++;
-
-	strWIDList[u32WidsCount].id = WID_FAILED_COUNT;
-	strWIDList[u32WidsCount].type = WID_INT;
-	strWIDList[u32WidsCount].size = sizeof(u32);
-	strWIDList[u32WidsCount].val = (s8 *)&pstrStatistics->tx_fail_cnt;
-	u32WidsCount++;
-
-	result = wilc_send_config_pkt(vif, GET_CFG, strWIDList,
-				      u32WidsCount,
-				      wilc_get_vif_idx(vif));
-
-	if (result)
-		netdev_err(vif->ndev, "Failed to send scan parameters\n");
-
-	if (pstrStatistics->link_speed > TCP_ACK_FILTER_LINK_SPEED_THRESH &&
-	    pstrStatistics->link_speed != DEFAULT_LINK_SPEED)
-		wilc_enable_tcp_ack_filter(true);
-	else if (pstrStatistics->link_speed != DEFAULT_LINK_SPEED)
-		wilc_enable_tcp_ack_filter(false);
-
-	if (pstrStatistics != &vif->wilc->dummy_statistics)
-		complete(&hif_wait_response);
-	return 0;
-}
-
-static s32 Handle_Get_InActiveTime(struct wilc_vif *vif,
-				   struct sta_inactive_t *strHostIfStaInactiveT)
-{
-	s32 result = 0;
-	u8 *stamac;
-	struct wid wid;
-	struct host_if_drv *hif_drv = vif->hif_drv;
-
-	wid.id = (u16)WID_SET_STA_MAC_INACTIVE_TIME;
-	wid.type = WID_STR;
-	wid.size = ETH_ALEN;
-	wid.val = kmalloc(wid.size, GFP_KERNEL);
-	if (!wid.val)
-		return -ENOMEM;
-
-	stamac = wid.val;
-	ether_addr_copy(stamac, strHostIfStaInactiveT->mac);
-
-	result = wilc_send_config_pkt(vif, SET_CFG, &wid, 1,
-				      wilc_get_vif_idx(vif));
-
-	if (result) {
-		netdev_err(vif->ndev, "Failed to SET inactive time\n");
-		return -EFAULT;
-	}
-
-	wid.id = (u16)WID_GET_INACTIVE_TIME;
-	wid.type = WID_INT;
-	wid.val = (s8 *)&inactive_time;
-	wid.size = sizeof(u32);
-
-	result = wilc_send_config_pkt(vif, GET_CFG, &wid, 1,
-				      wilc_get_vif_idx(vif));
-
-	if (result) {
-		netdev_err(vif->ndev, "Failed to get inactive time\n");
-		return -EFAULT;
-	}
-
-	complete(&hif_drv->comp_inactive_time);
-
-	return result;
-}
-
-static void Handle_AddBeacon(struct wilc_vif *vif,
-			     struct beacon_attr *pstrSetBeaconParam)
-{
-	s32 result = 0;
-	struct wid wid;
-	u8 *pu8CurrByte;
-
-	wid.id = (u16)WID_ADD_BEACON;
-	wid.type = WID_BIN;
-	wid.size = pstrSetBeaconParam->head_len + pstrSetBeaconParam->tail_len + 16;
-	wid.val = kmalloc(wid.size, GFP_KERNEL);
-	if (!wid.val)
-		goto ERRORHANDLER;
-
-	pu8CurrByte = wid.val;
-	*pu8CurrByte++ = (pstrSetBeaconParam->interval & 0xFF);
-	*pu8CurrByte++ = ((pstrSetBeaconParam->interval >> 8) & 0xFF);
-	*pu8CurrByte++ = ((pstrSetBeaconParam->interval >> 16) & 0xFF);
-	*pu8CurrByte++ = ((pstrSetBeaconParam->interval >> 24) & 0xFF);
-
-	*pu8CurrByte++ = (pstrSetBeaconParam->dtim_period & 0xFF);
-	*pu8CurrByte++ = ((pstrSetBeaconParam->dtim_period >> 8) & 0xFF);
-	*pu8CurrByte++ = ((pstrSetBeaconParam->dtim_period >> 16) & 0xFF);
-	*pu8CurrByte++ = ((pstrSetBeaconParam->dtim_period >> 24) & 0xFF);
-
-	*pu8CurrByte++ = (pstrSetBeaconParam->head_len & 0xFF);
-	*pu8CurrByte++ = ((pstrSetBeaconParam->head_len >> 8) & 0xFF);
-	*pu8CurrByte++ = ((pstrSetBeaconParam->head_len >> 16) & 0xFF);
-	*pu8CurrByte++ = ((pstrSetBeaconParam->head_len >> 24) & 0xFF);
-
-	memcpy(pu8CurrByte, pstrSetBeaconParam->head, pstrSetBeaconParam->head_len);
-	pu8CurrByte += pstrSetBeaconParam->head_len;
-
-	*pu8CurrByte++ = (pstrSetBeaconParam->tail_len & 0xFF);
-	*pu8CurrByte++ = ((pstrSetBeaconParam->tail_len >> 8) & 0xFF);
-	*pu8CurrByte++ = ((pstrSetBeaconParam->tail_len >> 16) & 0xFF);
-	*pu8CurrByte++ = ((pstrSetBeaconParam->tail_len >> 24) & 0xFF);
-
-	if (pstrSetBeaconParam->tail)
-		memcpy(pu8CurrByte, pstrSetBeaconParam->tail, pstrSetBeaconParam->tail_len);
-	pu8CurrByte += pstrSetBeaconParam->tail_len;
-
-	result = wilc_send_config_pkt(vif, SET_CFG, &wid, 1,
-				      wilc_get_vif_idx(vif));
-	if (result)
-		netdev_err(vif->ndev, "Failed to send add beacon\n");
-
-ERRORHANDLER:
-	kfree(wid.val);
-	kfree(pstrSetBeaconParam->head);
-	kfree(pstrSetBeaconParam->tail);
-}
-
-static void Handle_DelBeacon(struct wilc_vif *vif)
-{
-	s32 result = 0;
-	struct wid wid;
-	u8 *pu8CurrByte;
-
-	wid.id = (u16)WID_DEL_BEACON;
-	wid.type = WID_CHAR;
-	wid.size = sizeof(char);
-	wid.val = &del_beacon;
-
-	if (!wid.val)
-		return;
-
-	pu8CurrByte = wid.val;
-
-	result = wilc_send_config_pkt(vif, SET_CFG, &wid, 1,
-				      wilc_get_vif_idx(vif));
-	if (result)
-		netdev_err(vif->ndev, "Failed to send delete beacon\n");
-}
-
-static u32 WILC_HostIf_PackStaParam(u8 *pu8Buffer,
-				    struct add_sta_param *pstrStationParam)
-{
-	u8 *pu8CurrByte;
-
-	pu8CurrByte = pu8Buffer;
-
-	memcpy(pu8CurrByte, pstrStationParam->bssid, ETH_ALEN);
-	pu8CurrByte +=  ETH_ALEN;
-
-	*pu8CurrByte++ = pstrStationParam->aid & 0xFF;
-	*pu8CurrByte++ = (pstrStationParam->aid >> 8) & 0xFF;
-
-	*pu8CurrByte++ = pstrStationParam->rates_len;
-	if (pstrStationParam->rates_len > 0)
-		memcpy(pu8CurrByte, pstrStationParam->rates,
-		       pstrStationParam->rates_len);
-	pu8CurrByte += pstrStationParam->rates_len;
-
-	*pu8CurrByte++ = pstrStationParam->ht_supported;
-	memcpy(pu8CurrByte, &pstrStationParam->ht_capa,
-	       sizeof(struct ieee80211_ht_cap));
-	pu8CurrByte += sizeof(struct ieee80211_ht_cap);
-
-	*pu8CurrByte++ = pstrStationParam->flags_mask & 0xFF;
-	*pu8CurrByte++ = (pstrStationParam->flags_mask >> 8) & 0xFF;
-
-	*pu8CurrByte++ = pstrStationParam->flags_set & 0xFF;
-	*pu8CurrByte++ = (pstrStationParam->flags_set >> 8) & 0xFF;
-
-	return pu8CurrByte - pu8Buffer;
-}
-
-static void Handle_AddStation(struct wilc_vif *vif,
-			      struct add_sta_param *pstrStationParam)
-{
-	s32 result = 0;
-	struct wid wid;
-	u8 *pu8CurrByte;
-
-	wid.id = (u16)WID_ADD_STA;
-	wid.type = WID_BIN;
-	wid.size = WILC_ADD_STA_LENGTH + pstrStationParam->rates_len;
-
-	wid.val = kmalloc(wid.size, GFP_KERNEL);
-	if (!wid.val)
-		goto ERRORHANDLER;
-
-	pu8CurrByte = wid.val;
-	pu8CurrByte += WILC_HostIf_PackStaParam(pu8CurrByte, pstrStationParam);
-
-	result = wilc_send_config_pkt(vif, SET_CFG, &wid, 1,
-				      wilc_get_vif_idx(vif));
-	if (result != 0)
-		netdev_err(vif->ndev, "Failed to send add station\n");
-
-ERRORHANDLER:
-	kfree(pstrStationParam->rates);
-	kfree(wid.val);
-}
-
-static void Handle_DelAllSta(struct wilc_vif *vif,
-			     struct del_all_sta *pstrDelAllStaParam)
-{
-	s32 result = 0;
-	struct wid wid;
-	u8 *pu8CurrByte;
-	u8 i;
-	u8 au8Zero_Buff[6] = {0};
-
-	wid.id = (u16)WID_DEL_ALL_STA;
-	wid.type = WID_STR;
-	wid.size = (pstrDelAllStaParam->assoc_sta * ETH_ALEN) + 1;
-
-	wid.val = kmalloc((pstrDelAllStaParam->assoc_sta * ETH_ALEN) + 1, GFP_KERNEL);
-	if (!wid.val)
-		goto ERRORHANDLER;
-
-	pu8CurrByte = wid.val;
-
-	*(pu8CurrByte++) = pstrDelAllStaParam->assoc_sta;
-
-	for (i = 0; i < MAX_NUM_STA; i++) {
-		if (memcmp(pstrDelAllStaParam->del_all_sta[i], au8Zero_Buff, ETH_ALEN))
-			memcpy(pu8CurrByte, pstrDelAllStaParam->del_all_sta[i], ETH_ALEN);
-		else
-			continue;
-
-		pu8CurrByte += ETH_ALEN;
-	}
-
-	result = wilc_send_config_pkt(vif, SET_CFG, &wid, 1,
-				      wilc_get_vif_idx(vif));
-	if (result)
-		netdev_err(vif->ndev, "Failed to send add station\n");
-
-ERRORHANDLER:
-	kfree(wid.val);
-
-	complete(&hif_wait_response);
-}
-
-static void Handle_DelStation(struct wilc_vif *vif,
-			      struct del_sta *pstrDelStaParam)
-{
-	s32 result = 0;
-	struct wid wid;
-	u8 *pu8CurrByte;
-
-	wid.id = (u16)WID_REMOVE_STA;
-	wid.type = WID_BIN;
-	wid.size = ETH_ALEN;
-
-	wid.val = kmalloc(wid.size, GFP_KERNEL);
-	if (!wid.val)
-		goto ERRORHANDLER;
-
-	pu8CurrByte = wid.val;
-
-	ether_addr_copy(pu8CurrByte, pstrDelStaParam->mac_addr);
-
-	result = wilc_send_config_pkt(vif, SET_CFG, &wid, 1,
-				      wilc_get_vif_idx(vif));
-	if (result)
-		netdev_err(vif->ndev, "Failed to send add station\n");
-
-ERRORHANDLER:
-	kfree(wid.val);
-}
-
-static void Handle_EditStation(struct wilc_vif *vif,
-			       struct add_sta_param *pstrStationParam)
-{
-	s32 result = 0;
-	struct wid wid;
-	u8 *pu8CurrByte;
-
-	wid.id = (u16)WID_EDIT_STA;
-	wid.type = WID_BIN;
-	wid.size = WILC_ADD_STA_LENGTH + pstrStationParam->rates_len;
-
-	wid.val = kmalloc(wid.size, GFP_KERNEL);
-	if (!wid.val)
-		goto ERRORHANDLER;
-
-	pu8CurrByte = wid.val;
-	pu8CurrByte += WILC_HostIf_PackStaParam(pu8CurrByte, pstrStationParam);
-
-	result = wilc_send_config_pkt(vif, SET_CFG, &wid, 1,
-				      wilc_get_vif_idx(vif));
-	if (result)
-		netdev_err(vif->ndev, "Failed to send edit station\n");
-
-ERRORHANDLER:
-	kfree(pstrStationParam->rates);
-	kfree(wid.val);
-}
-
-static int Handle_RemainOnChan(struct wilc_vif *vif,
-			       struct remain_ch *pstrHostIfRemainOnChan)
-{
-	s32 result = 0;
-	u8 u8remain_on_chan_flag;
-	struct wid wid;
-	struct host_if_drv *hif_drv = vif->hif_drv;
-
-	if (!hif_drv->remain_on_ch_pending) {
-		hif_drv->remain_on_ch.arg = pstrHostIfRemainOnChan->arg;
-		hif_drv->remain_on_ch.expired = pstrHostIfRemainOnChan->expired;
-		hif_drv->remain_on_ch.ready = pstrHostIfRemainOnChan->ready;
-		hif_drv->remain_on_ch.ch = pstrHostIfRemainOnChan->ch;
-		hif_drv->remain_on_ch.id = pstrHostIfRemainOnChan->id;
-	} else {
-		pstrHostIfRemainOnChan->ch = hif_drv->remain_on_ch.ch;
-	}
-
-	if (hif_drv->usr_scan_req.scan_result) {
-		hif_drv->remain_on_ch_pending = 1;
-		result = -EBUSY;
-		goto ERRORHANDLER;
-	}
-	if (hif_drv->hif_state == HOST_IF_WAITING_CONN_RESP) {
-		result = -EBUSY;
-		goto ERRORHANDLER;
-	}
-
-	if (wilc_optaining_ip || wilc_connecting) {
-		result = -EBUSY;
-		goto ERRORHANDLER;
-	}
-
-	u8remain_on_chan_flag = true;
-	wid.id = (u16)WID_REMAIN_ON_CHAN;
-	wid.type = WID_STR;
-	wid.size = 2;
-	wid.val = kmalloc(wid.size, GFP_KERNEL);
-	if (!wid.val) {
-		result = -ENOMEM;
-		goto ERRORHANDLER;
-	}
-
-	wid.val[0] = u8remain_on_chan_flag;
-	wid.val[1] = (s8)pstrHostIfRemainOnChan->ch;
-
-	result = wilc_send_config_pkt(vif, SET_CFG, &wid, 1,
-				      wilc_get_vif_idx(vif));
-	if (result != 0)
-		netdev_err(vif->ndev, "Failed to set remain on channel\n");
-
-ERRORHANDLER:
-	{
-		P2P_LISTEN_STATE = 1;
-		hif_drv->remain_on_ch_timer.data = (unsigned long)vif;
-		mod_timer(&hif_drv->remain_on_ch_timer,
-			  jiffies +
-			  msecs_to_jiffies(pstrHostIfRemainOnChan->duration));
-
-		if (hif_drv->remain_on_ch.ready)
-			hif_drv->remain_on_ch.ready(hif_drv->remain_on_ch.arg);
-
-		if (hif_drv->remain_on_ch_pending)
-			hif_drv->remain_on_ch_pending = 0;
-	}
-
-	return result;
-}
-
-static int Handle_RegisterFrame(struct wilc_vif *vif,
-				struct reg_frame *pstrHostIfRegisterFrame)
-{
-	s32 result = 0;
-	struct wid wid;
-	u8 *pu8CurrByte;
-
-	wid.id = (u16)WID_REGISTER_FRAME;
-	wid.type = WID_STR;
-	wid.val = kmalloc(sizeof(u16) + 2, GFP_KERNEL);
-	if (!wid.val)
-		return -ENOMEM;
-
-	pu8CurrByte = wid.val;
-
-	*pu8CurrByte++ = pstrHostIfRegisterFrame->reg;
-	*pu8CurrByte++ = pstrHostIfRegisterFrame->reg_id;
-	memcpy(pu8CurrByte, &pstrHostIfRegisterFrame->frame_type, sizeof(u16));
-
-	wid.size = sizeof(u16) + 2;
-
-	result = wilc_send_config_pkt(vif, SET_CFG, &wid, 1,
-				      wilc_get_vif_idx(vif));
-	if (result) {
-		netdev_err(vif->ndev, "Failed to frame register\n");
-		result = -EINVAL;
-	}
-
-	return result;
-}
-
-static u32 Handle_ListenStateExpired(struct wilc_vif *vif,
-				     struct remain_ch *pstrHostIfRemainOnChan)
-{
-	u8 u8remain_on_chan_flag;
-	struct wid wid;
-	s32 result = 0;
-	struct host_if_drv *hif_drv = vif->hif_drv;
-
-	if (P2P_LISTEN_STATE) {
-		u8remain_on_chan_flag = false;
-		wid.id = (u16)WID_REMAIN_ON_CHAN;
-		wid.type = WID_STR;
-		wid.size = 2;
-		wid.val = kmalloc(wid.size, GFP_KERNEL);
-
-		if (!wid.val)
-			return -ENOMEM;
-
-		wid.val[0] = u8remain_on_chan_flag;
-		wid.val[1] = FALSE_FRMWR_CHANNEL;
-
-		result = wilc_send_config_pkt(vif, SET_CFG, &wid, 1,
-					      wilc_get_vif_idx(vif));
-		if (result != 0) {
-			netdev_err(vif->ndev, "Failed to set remain channel\n");
-			goto _done_;
-		}
-
-		if (hif_drv->remain_on_ch.expired) {
-			hif_drv->remain_on_ch.expired(hif_drv->remain_on_ch.arg,
-						      pstrHostIfRemainOnChan->id);
-		}
-		P2P_LISTEN_STATE = 0;
-	} else {
-		netdev_dbg(vif->ndev, "Not in listen state\n");
-		result = -EFAULT;
-	}
-
-_done_:
-	return result;
-}
-
-static void ListenTimerCB(unsigned long arg)
-{
-	s32 result = 0;
-	struct host_if_msg msg;
-	struct wilc_vif *vif = (struct wilc_vif *)arg;
-
-	del_timer(&vif->hif_drv->remain_on_ch_timer);
-
-	memset(&msg, 0, sizeof(struct host_if_msg));
-	msg.id = HOST_IF_MSG_LISTEN_TIMER_FIRED;
-	msg.vif = vif;
-	msg.body.remain_on_ch.id = vif->hif_drv->remain_on_ch.id;
-
-	result = wilc_enqueue_cmd(&msg);
-	if (result)
-		netdev_err(vif->ndev, "wilc_mq_send fail\n");
-}
-
-static void Handle_PowerManagement(struct wilc_vif *vif,
-				   struct power_mgmt_param *strPowerMgmtParam)
-{
-	s32 result = 0;
-	struct wid wid;
-	s8 s8PowerMode;
-
-	wid.id = (u16)WID_POWER_MANAGEMENT;
-
-	if (strPowerMgmtParam->enabled)
-		s8PowerMode = MIN_FAST_PS;
-	else
-		s8PowerMode = NO_POWERSAVE;
-
-	wid.val = &s8PowerMode;
-	wid.size = sizeof(char);
-
-	result = wilc_send_config_pkt(vif, SET_CFG, &wid, 1,
-				      wilc_get_vif_idx(vif));
-	if (result)
-		netdev_err(vif->ndev, "Failed to send power management\n");
-}
-
-static void Handle_SetMulticastFilter(struct wilc_vif *vif,
-				      struct set_multicast *strHostIfSetMulti)
-{
-	s32 result = 0;
-	struct wid wid;
-	u8 *pu8CurrByte;
-
-	wid.id = (u16)WID_SETUP_MULTICAST_FILTER;
-	wid.type = WID_BIN;
-	wid.size = sizeof(struct set_multicast) + ((strHostIfSetMulti->cnt) * ETH_ALEN);
-	wid.val = kmalloc(wid.size, GFP_KERNEL);
-	if (!wid.val)
-		goto ERRORHANDLER;
-
-	pu8CurrByte = wid.val;
-	*pu8CurrByte++ = (strHostIfSetMulti->enabled & 0xFF);
-	*pu8CurrByte++ = ((strHostIfSetMulti->enabled >> 8) & 0xFF);
-	*pu8CurrByte++ = ((strHostIfSetMulti->enabled >> 16) & 0xFF);
-	*pu8CurrByte++ = ((strHostIfSetMulti->enabled >> 24) & 0xFF);
-
-	*pu8CurrByte++ = (strHostIfSetMulti->cnt & 0xFF);
-	*pu8CurrByte++ = ((strHostIfSetMulti->cnt >> 8) & 0xFF);
-	*pu8CurrByte++ = ((strHostIfSetMulti->cnt >> 16) & 0xFF);
-	*pu8CurrByte++ = ((strHostIfSetMulti->cnt >> 24) & 0xFF);
-
-	if ((strHostIfSetMulti->cnt) > 0)
-		memcpy(pu8CurrByte, wilc_multicast_mac_addr_list,
-		       ((strHostIfSetMulti->cnt) * ETH_ALEN));
-
-	result = wilc_send_config_pkt(vif, SET_CFG, &wid, 1,
-				      wilc_get_vif_idx(vif));
-	if (result)
-		netdev_err(vif->ndev, "Failed to send setup multicast\n");
-
-ERRORHANDLER:
-	kfree(wid.val);
-}
-
-static void handle_set_tx_pwr(struct wilc_vif *vif, u8 tx_pwr)
-{
-	int ret;
-	struct wid wid;
-
-	wid.id = (u16)WID_TX_POWER;
-	wid.type = WID_CHAR;
-	wid.val = &tx_pwr;
-	wid.size = sizeof(char);
-
-	ret = wilc_send_config_pkt(vif, SET_CFG, &wid, 1,
-				   wilc_get_vif_idx(vif));
-	if (ret)
-		netdev_err(vif->ndev, "Failed to set TX PWR\n");
-}
-
-static void handle_get_tx_pwr(struct wilc_vif *vif, u8 *tx_pwr)
-{
-	int ret = 0;
-	struct wid wid;
-
-	wid.id = (u16)WID_TX_POWER;
-	wid.type = WID_CHAR;
-	wid.val = (s8 *)tx_pwr;
-	wid.size = sizeof(char);
-
-	ret = wilc_send_config_pkt(vif, GET_CFG, &wid, 1,
-				   wilc_get_vif_idx(vif));
-	if (ret)
-		netdev_err(vif->ndev, "Failed to get TX PWR\n");
-
-	complete(&hif_wait_response);
-}
-
-static void host_if_work(struct work_struct *work)
-{
-	struct host_if_msg *msg;
-	struct wilc *wilc;
-	int ret = 0;
-
-	msg = container_of(work, struct host_if_msg, work);
-	wilc = msg->vif->wilc;
-
-	if (msg->id == HOST_IF_MSG_CONNECT &&
-	    msg->vif->hif_drv->usr_scan_req.scan_result) {
-		wilc_enqueue_cmd(msg);
-		usleep_range(2 * 1000, 2 * 1000);
-		goto free_msg;
-	}
-	switch (msg->id) {
-	case HOST_IF_MSG_SCAN:
-		handle_scan(msg->vif, &msg->body.scan_info);
-		break;
-
-	case HOST_IF_MSG_CONNECT:
-		Handle_Connect(msg->vif, &msg->body.con_info);
-		break;
-
-	case HOST_IF_MSG_RCVD_NTWRK_INFO:
-		Handle_RcvdNtwrkInfo(msg->vif, &msg->body.net_info);
-		break;
-
-	case HOST_IF_MSG_RCVD_GNRL_ASYNC_INFO:
-		Handle_RcvdGnrlAsyncInfo(msg->vif,
-					 &msg->body.async_info);
-		break;
-
-	case HOST_IF_MSG_KEY:
-		Handle_Key(msg->vif, &msg->body.key_info);
-		break;
-
-	case HOST_IF_MSG_CFG_PARAMS:
-		handle_cfg_param(msg->vif, &msg->body.cfg_info);
-		break;
-
-	case HOST_IF_MSG_SET_CHANNEL:
-		handle_set_channel(msg->vif, &msg->body.channel_info);
-		break;
-
-	case HOST_IF_MSG_DISCONNECT:
-		Handle_Disconnect(msg->vif);
-		break;
-
-	case HOST_IF_MSG_RCVD_SCAN_COMPLETE:
-		del_timer(&msg->vif->hif_drv->scan_timer);
-
-		if (!wilc_wlan_get_num_conn_ifcs(wilc))
-			wilc_chip_sleep_manually(wilc);
-
-		Handle_ScanDone(msg->vif, SCAN_EVENT_DONE);
-
-		if (msg->vif->hif_drv->remain_on_ch_pending)
-			Handle_RemainOnChan(msg->vif,
-					    &msg->body.remain_on_ch);
-
-		break;
-
-	case HOST_IF_MSG_GET_RSSI:
-		Handle_GetRssi(msg->vif);
-		break;
-
-	case HOST_IF_MSG_GET_STATISTICS:
-		Handle_GetStatistics(msg->vif,
-				     (struct rf_info *)msg->body.data);
-		break;
-
-	case HOST_IF_MSG_ADD_BEACON:
-		Handle_AddBeacon(msg->vif, &msg->body.beacon_info);
-		break;
-
-	case HOST_IF_MSG_DEL_BEACON:
-		Handle_DelBeacon(msg->vif);
-		break;
-
-	case HOST_IF_MSG_ADD_STATION:
-		Handle_AddStation(msg->vif, &msg->body.add_sta_info);
-		break;
-
-	case HOST_IF_MSG_DEL_STATION:
-		Handle_DelStation(msg->vif, &msg->body.del_sta_info);
-		break;
-
-	case HOST_IF_MSG_EDIT_STATION:
-		Handle_EditStation(msg->vif, &msg->body.edit_sta_info);
-		break;
-
-	case HOST_IF_MSG_GET_INACTIVETIME:
-		Handle_Get_InActiveTime(msg->vif, &msg->body.mac_info);
-		break;
-
-	case HOST_IF_MSG_SCAN_TIMER_FIRED:
-		Handle_ScanDone(msg->vif, SCAN_EVENT_ABORTED);
-		break;
-
-	case HOST_IF_MSG_CONNECT_TIMER_FIRED:
-		Handle_ConnectTimeout(msg->vif);
-		break;
-
-	case HOST_IF_MSG_POWER_MGMT:
-		Handle_PowerManagement(msg->vif,
-				       &msg->body.pwr_mgmt_info);
-		break;
-
-	case HOST_IF_MSG_SET_WFIDRV_HANDLER:
-		ret = handle_set_wfi_drv_handler(msg->vif, &msg->body.drv);
-		break;
-
-	case HOST_IF_MSG_SET_OPERATION_MODE:
-		handle_set_operation_mode(msg->vif, &msg->body.mode);
-		break;
-
-	case HOST_IF_MSG_SET_IPADDRESS:
-		handle_set_ip_address(msg->vif,
-				      msg->body.ip_info.ip_addr,
-				      msg->body.ip_info.idx);
-		break;
-
-	case HOST_IF_MSG_GET_IPADDRESS:
-		handle_get_ip_address(msg->vif, msg->body.ip_info.idx);
-		break;
-
-	case HOST_IF_MSG_GET_MAC_ADDRESS:
-		handle_get_mac_address(msg->vif,
-				       &msg->body.get_mac_info);
-		break;
-
-	case HOST_IF_MSG_REMAIN_ON_CHAN:
-		Handle_RemainOnChan(msg->vif, &msg->body.remain_on_ch);
-		break;
-
-	case HOST_IF_MSG_REGISTER_FRAME:
-		Handle_RegisterFrame(msg->vif, &msg->body.reg_frame);
-		break;
-
-	case HOST_IF_MSG_LISTEN_TIMER_FIRED:
-		Handle_ListenStateExpired(msg->vif, &msg->body.remain_on_ch);
-		break;
-
-	case HOST_IF_MSG_SET_MULTICAST_FILTER:
-		Handle_SetMulticastFilter(msg->vif, &msg->body.multicast_info);
-		break;
-
-	case HOST_IF_MSG_DEL_ALL_STA:
-		Handle_DelAllSta(msg->vif, &msg->body.del_all_sta_info);
-		break;
-
-	case HOST_IF_MSG_SET_TX_POWER:
-		handle_set_tx_pwr(msg->vif, msg->body.tx_power.tx_pwr);
-		break;
-
-	case HOST_IF_MSG_GET_TX_POWER:
-		handle_get_tx_pwr(msg->vif, &msg->body.tx_power.tx_pwr);
-		break;
-	default:
-		netdev_err(msg->vif->ndev, "[Host Interface] undefined\n");
-		break;
-	}
-free_msg:
-	if (ret)
-		netdev_err(msg->vif->ndev, "Host cmd %d failed\n", msg->id);
-	kfree(msg);
-	complete(&hif_thread_comp);
-}
-
-static void TimerCB_Scan(unsigned long arg)
-{
-	struct wilc_vif *vif = (struct wilc_vif *)arg;
-	struct host_if_msg msg;
-
-	memset(&msg, 0, sizeof(struct host_if_msg));
-	msg.vif = vif;
-	msg.id = HOST_IF_MSG_SCAN_TIMER_FIRED;
-
-	wilc_enqueue_cmd(&msg);
-}
-
-static void TimerCB_Connect(unsigned long arg)
-{
-	struct wilc_vif *vif = (struct wilc_vif *)arg;
-	struct host_if_msg msg;
-
-	memset(&msg, 0, sizeof(struct host_if_msg));
-	msg.vif = vif;
-	msg.id = HOST_IF_MSG_CONNECT_TIMER_FIRED;
-
-	wilc_enqueue_cmd(&msg);
-}
-
-s32 wilc_remove_key(struct host_if_drv *hif_drv, const u8 *pu8StaAddress)
-{
-	struct wid wid;
-
-	wid.id = (u16)WID_REMOVE_KEY;
-	wid.type = WID_STR;
-	wid.val = (s8 *)pu8StaAddress;
-	wid.size = 6;
-
-	return 0;
-}
-
-int wilc_remove_wep_key(struct wilc_vif *vif, u8 index)
-{
-	int result = 0;
-	struct host_if_msg msg;
-	struct host_if_drv *hif_drv = vif->hif_drv;
-
-	if (!hif_drv) {
-		result = -EFAULT;
-		netdev_err(vif->ndev, "Failed to send setup multicast\n");
-		return result;
-	}
-
-	memset(&msg, 0, sizeof(struct host_if_msg));
-
-	msg.id = HOST_IF_MSG_KEY;
-	msg.body.key_info.type = WEP;
-	msg.body.key_info.action = REMOVEKEY;
-	msg.vif = vif;
-	msg.body.key_info.attr.wep.index = index;
-
-	result = wilc_enqueue_cmd(&msg);
-	if (result)
-		netdev_err(vif->ndev, "Request to remove WEP key\n");
-	else
-		wait_for_completion(&hif_drv->comp_test_key_block);
-
-	return result;
-}
-
-int wilc_set_wep_default_keyid(struct wilc_vif *vif, u8 index)
-{
-	int result = 0;
-	struct host_if_msg msg;
-	struct host_if_drv *hif_drv = vif->hif_drv;
-
-	if (!hif_drv) {
-		result = -EFAULT;
-		netdev_err(vif->ndev, "driver is null\n");
-		return result;
-	}
-
-	memset(&msg, 0, sizeof(struct host_if_msg));
-
-	msg.id = HOST_IF_MSG_KEY;
-	msg.body.key_info.type = WEP;
-	msg.body.key_info.action = DEFAULTKEY;
-	msg.vif = vif;
-	msg.body.key_info.attr.wep.index = index;
-
-	result = wilc_enqueue_cmd(&msg);
-	if (result)
-		netdev_err(vif->ndev, "Default key index\n");
-	else
-		wait_for_completion(&hif_drv->comp_test_key_block);
-
-	return result;
-}
-
-int wilc_add_wep_key_bss_sta(struct wilc_vif *vif, const u8 *key, u8 len,
-			     u8 index)
-{
-	int result = 0;
-	struct host_if_msg msg;
-	struct host_if_drv *hif_drv = vif->hif_drv;
-
-	if (!hif_drv) {
-		netdev_err(vif->ndev, "driver is null\n");
-		return -EFAULT;
-	}
-
-	memset(&msg, 0, sizeof(struct host_if_msg));
-
-	msg.id = HOST_IF_MSG_KEY;
-	msg.body.key_info.type = WEP;
-	msg.body.key_info.action = ADDKEY;
-	msg.vif = vif;
-	msg.body.key_info.attr.wep.key = kmemdup(key, len, GFP_KERNEL);
-	if (!msg.body.key_info.attr.wep.key)
-		return -ENOMEM;
-
-	msg.body.key_info.attr.wep.key_len = len;
-	msg.body.key_info.attr.wep.index = index;
-
-	result = wilc_enqueue_cmd(&msg);
-	if (result)
-		netdev_err(vif->ndev, "STA - WEP Key\n");
-	wait_for_completion(&hif_drv->comp_test_key_block);
-
-	return result;
-}
-
-int wilc_add_wep_key_bss_ap(struct wilc_vif *vif, const u8 *key, u8 len,
-			    u8 index, u8 mode, enum AUTHTYPE auth_type)
-{
-	int result = 0;
-	struct host_if_msg msg;
-	struct host_if_drv *hif_drv = vif->hif_drv;
-
-	if (!hif_drv) {
-		netdev_err(vif->ndev, "driver is null\n");
-		return -EFAULT;
-	}
-
-	memset(&msg, 0, sizeof(struct host_if_msg));
-
-	msg.id = HOST_IF_MSG_KEY;
-	msg.body.key_info.type = WEP;
-	msg.body.key_info.action = ADDKEY_AP;
-	msg.vif = vif;
-	msg.body.key_info.attr.wep.key = kmemdup(key, len, GFP_KERNEL);
-	if (!msg.body.key_info.attr.wep.key)
-		return -ENOMEM;
-
-	msg.body.key_info.attr.wep.key_len = len;
-	msg.body.key_info.attr.wep.index = index;
-	msg.body.key_info.attr.wep.mode = mode;
-	msg.body.key_info.attr.wep.auth_type = auth_type;
-
-	result = wilc_enqueue_cmd(&msg);
-
-	if (result)
-		netdev_err(vif->ndev, "AP - WEP Key\n");
-	else
-		wait_for_completion(&hif_drv->comp_test_key_block);
-
-	return result;
-}
-
-int wilc_add_ptk(struct wilc_vif *vif, const u8 *ptk, u8 ptk_key_len,
-		 const u8 *mac_addr, const u8 *rx_mic, const u8 *tx_mic,
-		 u8 mode, u8 cipher_mode, u8 index)
-{
-	int result = 0;
-	struct host_if_msg msg;
-	struct host_if_drv *hif_drv = vif->hif_drv;
-	u8 key_len = ptk_key_len;
-
-	if (!hif_drv) {
-		netdev_err(vif->ndev, "driver is null\n");
-		return -EFAULT;
-	}
-
-	if (rx_mic)
-		key_len += RX_MIC_KEY_LEN;
-
-	if (tx_mic)
-		key_len += TX_MIC_KEY_LEN;
-
-	memset(&msg, 0, sizeof(struct host_if_msg));
-
-	msg.id = HOST_IF_MSG_KEY;
-	msg.body.key_info.type = WPA_PTK;
-	if (mode == AP_MODE) {
-		msg.body.key_info.action = ADDKEY_AP;
-		msg.body.key_info.attr.wpa.index = index;
-	}
-	if (mode == STATION_MODE)
-		msg.body.key_info.action = ADDKEY;
-
-	msg.body.key_info.attr.wpa.key = kmemdup(ptk, ptk_key_len, GFP_KERNEL);
-	if (!msg.body.key_info.attr.wpa.key)
-		return -ENOMEM;
-
-	if (rx_mic)
-		memcpy(msg.body.key_info.attr.wpa.key + 16, rx_mic, RX_MIC_KEY_LEN);
-
-	if (tx_mic)
-		memcpy(msg.body.key_info.attr.wpa.key + 24, tx_mic, TX_MIC_KEY_LEN);
-
-	msg.body.key_info.attr.wpa.key_len = key_len;
-	msg.body.key_info.attr.wpa.mac_addr = mac_addr;
-	msg.body.key_info.attr.wpa.mode = cipher_mode;
-	msg.vif = vif;
-
-	result = wilc_enqueue_cmd(&msg);
-
-	if (result)
-		netdev_err(vif->ndev, "PTK Key\n");
-	else
-		wait_for_completion(&hif_drv->comp_test_key_block);
-
-	return result;
-}
-
-int wilc_add_rx_gtk(struct wilc_vif *vif, const u8 *rx_gtk, u8 gtk_key_len,
-		    u8 index, u32 key_rsc_len, const u8 *key_rsc,
-		    const u8 *rx_mic, const u8 *tx_mic, u8 mode,
-		    u8 cipher_mode)
-{
-	int result = 0;
-	struct host_if_msg msg;
-	struct host_if_drv *hif_drv = vif->hif_drv;
-	u8 key_len = gtk_key_len;
-
-	if (!hif_drv) {
-		netdev_err(vif->ndev, "driver is null\n");
-		return -EFAULT;
-	}
-	memset(&msg, 0, sizeof(struct host_if_msg));
-
-	if (rx_mic)
-		key_len += RX_MIC_KEY_LEN;
-
-	if (tx_mic)
-		key_len += TX_MIC_KEY_LEN;
-
-	if (key_rsc) {
-		msg.body.key_info.attr.wpa.seq = kmemdup(key_rsc,
-							 key_rsc_len,
-							 GFP_KERNEL);
-		if (!msg.body.key_info.attr.wpa.seq)
-			return -ENOMEM;
-	}
-
-	msg.id = HOST_IF_MSG_KEY;
-	msg.body.key_info.type = WPA_RX_GTK;
-	msg.vif = vif;
-
-	if (mode == AP_MODE) {
-		msg.body.key_info.action = ADDKEY_AP;
-		msg.body.key_info.attr.wpa.mode = cipher_mode;
-	}
-	if (mode == STATION_MODE)
-		msg.body.key_info.action = ADDKEY;
-
-	msg.body.key_info.attr.wpa.key = kmemdup(rx_gtk,
-						 key_len,
-						 GFP_KERNEL);
-	if (!msg.body.key_info.attr.wpa.key)
-		return -ENOMEM;
-
-	if (rx_mic)
-		memcpy(msg.body.key_info.attr.wpa.key + 16, rx_mic,
-		       RX_MIC_KEY_LEN);
-
-	if (tx_mic)
-		memcpy(msg.body.key_info.attr.wpa.key + 24, tx_mic,
-		       TX_MIC_KEY_LEN);
-
-	msg.body.key_info.attr.wpa.index = index;
-	msg.body.key_info.attr.wpa.key_len = key_len;
-	msg.body.key_info.attr.wpa.seq_len = key_rsc_len;
-
-	result = wilc_enqueue_cmd(&msg);
-	if (result)
-		netdev_err(vif->ndev, "RX GTK\n");
-	else
-		wait_for_completion(&hif_drv->comp_test_key_block);
-
-	return result;
-}
-
-int wilc_set_pmkid_info(struct wilc_vif *vif,
-			struct host_if_pmkid_attr *pmkid)
-{
-	int result = 0;
-	struct host_if_msg msg;
-	int i;
-
-	memset(&msg, 0, sizeof(struct host_if_msg));
-
-	msg.id = HOST_IF_MSG_KEY;
-	msg.body.key_info.type = PMKSA;
-	msg.body.key_info.action = ADDKEY;
-	msg.vif = vif;
-
-	for (i = 0; i < pmkid->numpmkid; i++) {
-		memcpy(msg.body.key_info.attr.pmkid.pmkidlist[i].bssid,
-		       &pmkid->pmkidlist[i].bssid, ETH_ALEN);
-		memcpy(msg.body.key_info.attr.pmkid.pmkidlist[i].pmkid,
-		       &pmkid->pmkidlist[i].pmkid, PMKID_LEN);
-	}
-
-	result = wilc_enqueue_cmd(&msg);
-	if (result)
-		netdev_err(vif->ndev, "PMKID Info\n");
-
-	return result;
-}
-
-int wilc_get_mac_address(struct wilc_vif *vif, u8 *mac_addr)
-{
-	int result = 0;
-	struct host_if_msg msg;
-
-	memset(&msg, 0, sizeof(struct host_if_msg));
-
-	msg.id = HOST_IF_MSG_GET_MAC_ADDRESS;
-	msg.body.get_mac_info.mac_addr = mac_addr;
-	msg.vif = vif;
-
-	result = wilc_enqueue_cmd(&msg);
-	if (result) {
-		netdev_err(vif->ndev, "Failed to send get mac address\n");
-		return -EFAULT;
-	}
-
-	wait_for_completion(&hif_wait_response);
-	return result;
-}
-
-int wilc_set_join_req(struct wilc_vif *vif, u8 *bssid, const u8 *ssid,
-		      size_t ssid_len, const u8 *ies, size_t ies_len,
-		      wilc_connect_result connect_result, void *user_arg,
-		      u8 security, enum AUTHTYPE auth_type,
-		      u8 channel, void *join_params)
-{
-	int result = 0;
-	struct host_if_msg msg;
-	struct host_if_drv *hif_drv = vif->hif_drv;
-
-	if (!hif_drv || !connect_result) {
-		netdev_err(vif->ndev, "Driver is null\n");
-		return -EFAULT;
-	}
-
-	if (!join_params) {
-		netdev_err(vif->ndev, "Unable to Join - JoinParams is NULL\n");
-		return -EFAULT;
-	}
-
-	memset(&msg, 0, sizeof(struct host_if_msg));
-
-	msg.id = HOST_IF_MSG_CONNECT;
-
-	msg.body.con_info.security = security;
-	msg.body.con_info.auth_type = auth_type;
-	msg.body.con_info.ch = channel;
-	msg.body.con_info.result = connect_result;
-	msg.body.con_info.arg = user_arg;
-	msg.body.con_info.params = join_params;
-	msg.vif = vif;
-
-	if (bssid) {
-		msg.body.con_info.bssid = kmemdup(bssid, 6, GFP_KERNEL);
-		if (!msg.body.con_info.bssid)
-			return -ENOMEM;
-	}
-
-	if (ssid) {
-		msg.body.con_info.ssid_len = ssid_len;
-		msg.body.con_info.ssid = kmemdup(ssid, ssid_len, GFP_KERNEL);
-		if (!msg.body.con_info.ssid)
-			return -ENOMEM;
-	}
-
-	if (ies) {
-		msg.body.con_info.ies_len = ies_len;
-		msg.body.con_info.ies = kmemdup(ies, ies_len, GFP_KERNEL);
-		if (!msg.body.con_info.ies)
-			return -ENOMEM;
-	}
-	if (hif_drv->hif_state < HOST_IF_CONNECTING)
-		hif_drv->hif_state = HOST_IF_CONNECTING;
-
-	result = wilc_enqueue_cmd(&msg);
-	if (result) {
-		netdev_err(vif->ndev, "send message: Set join request\n");
-		return -EFAULT;
-	}
-
-	hif_drv->connect_timer.data = (unsigned long)vif;
-	mod_timer(&hif_drv->connect_timer,
-		  jiffies + msecs_to_jiffies(HOST_IF_CONNECT_TIMEOUT));
-
-	return result;
-}
-
-int wilc_disconnect(struct wilc_vif *vif, u16 reason_code)
-{
-	int result = 0;
-	struct host_if_msg msg;
-	struct host_if_drv *hif_drv = vif->hif_drv;
-
-	if (!hif_drv) {
-		netdev_err(vif->ndev, "Driver is null\n");
-		return -EFAULT;
-	}
-
-	memset(&msg, 0, sizeof(struct host_if_msg));
-
-	msg.id = HOST_IF_MSG_DISCONNECT;
-	msg.vif = vif;
-
-	result = wilc_enqueue_cmd(&msg);
-	if (result)
-		netdev_err(vif->ndev, "Failed to send message: disconnect\n");
-	else
-		wait_for_completion(&hif_drv->comp_test_disconn_block);
-
-	return result;
-}
-
-static s32 host_int_get_assoc_res_info(struct wilc_vif *vif,
-				       u8 *pu8AssocRespInfo,
-				       u32 u32MaxAssocRespInfoLen,
-				       u32 *pu32RcvdAssocRespInfoLen)
-{
-	s32 result = 0;
-	struct wid wid;
-
-	wid.id = (u16)WID_ASSOC_RES_INFO;
-	wid.type = WID_STR;
-	wid.val = pu8AssocRespInfo;
-	wid.size = u32MaxAssocRespInfoLen;
-
-	result = wilc_send_config_pkt(vif, GET_CFG, &wid, 1,
-				      wilc_get_vif_idx(vif));
-	if (result) {
-		*pu32RcvdAssocRespInfoLen = 0;
-		netdev_err(vif->ndev, "Failed to send association response\n");
-		return -EINVAL;
-	}
-
-	*pu32RcvdAssocRespInfoLen = wid.size;
-	return result;
-}
-
-int wilc_set_mac_chnl_num(struct wilc_vif *vif, u8 channel)
-{
-	int result;
-	struct host_if_msg msg;
-
-	memset(&msg, 0, sizeof(struct host_if_msg));
-	msg.id = HOST_IF_MSG_SET_CHANNEL;
-	msg.body.channel_info.set_ch = channel;
-	msg.vif = vif;
-
-	result = wilc_enqueue_cmd(&msg);
-	if (result) {
-		netdev_err(vif->ndev, "wilc mq send fail\n");
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-int wilc_set_wfi_drv_handler(struct wilc_vif *vif, int index, u8 mode,
-			     u8 ifc_id)
-{
-	int result = 0;
-	struct host_if_msg msg;
-
-	memset(&msg, 0, sizeof(struct host_if_msg));
-	msg.id = HOST_IF_MSG_SET_WFIDRV_HANDLER;
-	msg.body.drv.handler = index;
-	msg.body.drv.mode = mode;
-	msg.body.drv.name = ifc_id;
-	msg.vif = vif;
-
-	result = wilc_enqueue_cmd(&msg);
-	if (result) {
-		netdev_err(vif->ndev, "wilc mq send fail\n");
-		result = -EINVAL;
-	}
-
-	return result;
-}
-
-int wilc_set_operation_mode(struct wilc_vif *vif, u32 mode)
-{
-	int result = 0;
-	struct host_if_msg msg;
-
-	memset(&msg, 0, sizeof(struct host_if_msg));
-	msg.id = HOST_IF_MSG_SET_OPERATION_MODE;
-	msg.body.mode.mode = mode;
-	msg.vif = vif;
-
-	result = wilc_enqueue_cmd(&msg);
-	if (result) {
-		netdev_err(vif->ndev, "wilc mq send fail\n");
-		result = -EINVAL;
-	}
-
-	return result;
-}
-
-s32 wilc_get_inactive_time(struct wilc_vif *vif, const u8 *mac,
-			   u32 *pu32InactiveTime)
-{
-	s32 result = 0;
-	struct host_if_msg msg;
-	struct host_if_drv *hif_drv = vif->hif_drv;
-
-	if (!hif_drv) {
-		netdev_err(vif->ndev, "driver is null\n");
-		return -EFAULT;
-	}
-
-	memset(&msg, 0, sizeof(struct host_if_msg));
-	memcpy(msg.body.mac_info.mac, mac, ETH_ALEN);
-
-	msg.id = HOST_IF_MSG_GET_INACTIVETIME;
-	msg.vif = vif;
-
-	result = wilc_enqueue_cmd(&msg);
-	if (result)
-		netdev_err(vif->ndev, "Failed to send get host ch param\n");
-	else
-		wait_for_completion(&hif_drv->comp_inactive_time);
-
-	*pu32InactiveTime = inactive_time;
-
-	return result;
-}
-
-int wilc_get_rssi(struct wilc_vif *vif, s8 *rssi_level)
-{
-	int result = 0;
-	struct host_if_msg msg;
-	struct host_if_drv *hif_drv = vif->hif_drv;
-
-	memset(&msg, 0, sizeof(struct host_if_msg));
-	msg.id = HOST_IF_MSG_GET_RSSI;
-	msg.vif = vif;
-
-	result = wilc_enqueue_cmd(&msg);
-	if (result) {
-		netdev_err(vif->ndev, "Failed to send get host ch param\n");
-		return -EFAULT;
-	}
-
-	wait_for_completion(&hif_drv->comp_get_rssi);
-
-	if (!rssi_level) {
-		netdev_err(vif->ndev, "RSS pointer value is null\n");
-		return -EFAULT;
-	}
-
-	*rssi_level = rssi;
-
-	return result;
-}
-
-int wilc_get_statistics(struct wilc_vif *vif, struct rf_info *stats)
-{
-	int result = 0;
-	struct host_if_msg msg;
-
-	memset(&msg, 0, sizeof(struct host_if_msg));
-	msg.id = HOST_IF_MSG_GET_STATISTICS;
-	msg.body.data = (char *)stats;
-	msg.vif = vif;
-
-	result = wilc_enqueue_cmd(&msg);
-	if (result) {
-		netdev_err(vif->ndev, "Failed to send get host channel\n");
-		return -EFAULT;
-	}
-
-	if (stats != &vif->wilc->dummy_statistics)
-		wait_for_completion(&hif_wait_response);
-	return result;
-}
-
-int wilc_scan(struct wilc_vif *vif, u8 scan_source, u8 scan_type,
-	      u8 *ch_freq_list, u8 ch_list_len, const u8 *ies,
-	      size_t ies_len, wilc_scan_result scan_result, void *user_arg,
-	      struct hidden_network *hidden_network)
-{
-	int result = 0;
-	struct host_if_msg msg;
-	struct scan_attr *scan_info = &msg.body.scan_info;
-	struct host_if_drv *hif_drv = vif->hif_drv;
-
-	if (!hif_drv || !scan_result) {
-		netdev_err(vif->ndev, "hif_drv or scan_result = NULL\n");
-		return -EFAULT;
-	}
-
-	memset(&msg, 0, sizeof(struct host_if_msg));
-
-	msg.id = HOST_IF_MSG_SCAN;
-
-	if (hidden_network) {
-		scan_info->hidden_network.net_info = hidden_network->net_info;
-		scan_info->hidden_network.n_ssids = hidden_network->n_ssids;
-	}
-
-	msg.vif = vif;
-	scan_info->src = scan_source;
-	scan_info->type = scan_type;
-	scan_info->result = scan_result;
-	scan_info->arg = user_arg;
-
-	scan_info->ch_list_len = ch_list_len;
-	scan_info->ch_freq_list = kmemdup(ch_freq_list,
-					  ch_list_len,
-					  GFP_KERNEL);
-	if (!scan_info->ch_freq_list)
-		return -ENOMEM;
-
-	scan_info->ies_len = ies_len;
-	scan_info->ies = kmemdup(ies, ies_len, GFP_KERNEL);
-	if (!scan_info->ies)
-		return -ENOMEM;
-
-	result = wilc_enqueue_cmd(&msg);
-	if (result) {
-		netdev_err(vif->ndev, "Error in sending message queue\n");
-		return -EINVAL;
-	}
-
-	hif_drv->scan_timer.data = (unsigned long)vif;
-	mod_timer(&hif_drv->scan_timer,
-		  jiffies + msecs_to_jiffies(HOST_IF_SCAN_TIMEOUT));
-
-	return result;
-}
-
-int wilc_hif_set_cfg(struct wilc_vif *vif,
-		     struct cfg_param_attr *cfg_param)
-{
-	struct host_if_msg msg;
-	struct host_if_drv *hif_drv = vif->hif_drv;
-
-	if (!hif_drv) {
-		netdev_err(vif->ndev, "hif_drv NULL\n");
-		return -EFAULT;
-	}
-
-	memset(&msg, 0, sizeof(struct host_if_msg));
-	msg.id = HOST_IF_MSG_CFG_PARAMS;
-	msg.body.cfg_info = *cfg_param;
-	msg.vif = vif;
-
-	return wilc_enqueue_cmd(&msg);
-}
-
-static void GetPeriodicRSSI(unsigned long arg)
-{
-	struct wilc_vif *vif = (struct wilc_vif *)arg;
-
-	if (!vif->hif_drv) {
-		netdev_err(vif->ndev, "Driver handler is NULL\n");
-		return;
-	}
-
-	if (vif->hif_drv->hif_state == HOST_IF_CONNECTED)
-		wilc_get_statistics(vif, &vif->wilc->dummy_statistics);
-
-	periodic_rssi.data = (unsigned long)vif;
-	mod_timer(&periodic_rssi, jiffies + msecs_to_jiffies(5000));
-}
-
-int wilc_init(struct net_device *dev, struct host_if_drv **hif_drv_handler)
-{
-	int result = 0;
-	struct host_if_drv *hif_drv;
-	struct wilc_vif *vif;
-	struct wilc *wilc;
-	int i;
-
-	vif = netdev_priv(dev);
-	wilc = vif->wilc;
-
-	scan_while_connected = false;
-
-	init_completion(&hif_wait_response);
-
-	hif_drv  = kzalloc(sizeof(*hif_drv), GFP_KERNEL);
-	if (!hif_drv) {
-		result = -ENOMEM;
-		goto _fail_;
-	}
-	*hif_drv_handler = hif_drv;
-	for (i = 0; i < wilc->vif_num; i++)
-		if (dev == wilc->vif[i]->ndev) {
-			wilc->vif[i]->hif_drv = hif_drv;
-			hif_drv->driver_handler_id = i + 1;
-			break;
-		}
-
-	wilc_optaining_ip = false;
-
-	if (clients_count == 0)	{
-		init_completion(&hif_thread_comp);
-		init_completion(&hif_driver_comp);
-		mutex_init(&hif_deinit_lock);
-	}
-
-	init_completion(&hif_drv->comp_test_key_block);
-	init_completion(&hif_drv->comp_test_disconn_block);
-	init_completion(&hif_drv->comp_get_rssi);
-	init_completion(&hif_drv->comp_inactive_time);
-
-	if (clients_count == 0)	{
-		hif_workqueue = create_singlethread_workqueue("WILC_wq");
-		if (!hif_workqueue) {
-			netdev_err(vif->ndev, "Failed to create workqueue\n");
-			result = -ENOMEM;
-			goto _fail_;
-		}
-
-		setup_timer(&periodic_rssi, GetPeriodicRSSI,
-			    (unsigned long)vif);
-		mod_timer(&periodic_rssi, jiffies + msecs_to_jiffies(5000));
-	}
-
-	setup_timer(&hif_drv->scan_timer, TimerCB_Scan, 0);
-	setup_timer(&hif_drv->connect_timer, TimerCB_Connect, 0);
-	setup_timer(&hif_drv->remain_on_ch_timer, ListenTimerCB, 0);
-
-	mutex_init(&hif_drv->cfg_values_lock);
-	mutex_lock(&hif_drv->cfg_values_lock);
-
-	hif_drv->hif_state = HOST_IF_IDLE;
-	hif_drv->cfg_values.site_survey_enabled = SITE_SURVEY_OFF;
-	hif_drv->cfg_values.scan_source = DEFAULT_SCAN;
-	hif_drv->cfg_values.active_scan_time = ACTIVE_SCAN_TIME;
-	hif_drv->cfg_values.passive_scan_time = PASSIVE_SCAN_TIME;
-	hif_drv->cfg_values.curr_tx_rate = AUTORATE;
-
-	hif_drv->p2p_timeout = 0;
-
-	mutex_unlock(&hif_drv->cfg_values_lock);
-
-	clients_count++;
-
-_fail_:
-	return result;
-}
-
-int wilc_deinit(struct wilc_vif *vif)
-{
-	int result = 0;
-	struct host_if_msg msg;
-	struct host_if_drv *hif_drv = vif->hif_drv;
-
-	if (!hif_drv)	{
-		netdev_err(vif->ndev, "hif_drv = NULL\n");
-		return -EFAULT;
-	}
-
-	mutex_lock(&hif_deinit_lock);
-
-	terminated_handle = hif_drv;
-
-	del_timer_sync(&hif_drv->scan_timer);
-	del_timer_sync(&hif_drv->connect_timer);
-	del_timer_sync(&periodic_rssi);
-	del_timer_sync(&hif_drv->remain_on_ch_timer);
-
-	wilc_set_wfi_drv_handler(vif, 0, 0, 0);
-	wait_for_completion(&hif_driver_comp);
-
-	if (hif_drv->usr_scan_req.scan_result) {
-		hif_drv->usr_scan_req.scan_result(SCAN_EVENT_ABORTED, NULL,
-						  hif_drv->usr_scan_req.arg, NULL);
-		hif_drv->usr_scan_req.scan_result = NULL;
-	}
-
-	hif_drv->hif_state = HOST_IF_IDLE;
-
-	scan_while_connected = false;
-
-	memset(&msg, 0, sizeof(struct host_if_msg));
-
-	if (clients_count == 1)	{
-		msg.id = HOST_IF_MSG_EXIT;
-		msg.vif = vif;
-
-		result = wilc_enqueue_cmd(&msg);
-		if (result != 0)
-			netdev_err(vif->ndev, "deinit : Error(%d)\n", result);
-		else
-			wait_for_completion(&hif_thread_comp);
-
-		destroy_workqueue(hif_workqueue);
-	}
-
-	kfree(hif_drv);
-
-	clients_count--;
-	terminated_handle = NULL;
-	mutex_unlock(&hif_deinit_lock);
-	return result;
-}
-
-void wilc_network_info_received(struct wilc *wilc, u8 *buffer, u32 length)
-{
-	s32 result = 0;
-	struct host_if_msg msg;
-	int id;
-	struct host_if_drv *hif_drv = NULL;
-	struct wilc_vif *vif;
-
-	id = ((buffer[length - 4]) | (buffer[length - 3] << 8) | (buffer[length - 2] << 16) | (buffer[length - 1] << 24));
-	vif = wilc_get_vif_from_idx(wilc, id);
-	if (!vif)
-		return;
-	hif_drv = vif->hif_drv;
-
-	if (!hif_drv || hif_drv == terminated_handle)	{
-		netdev_err(vif->ndev, "driver not init[%p]\n", hif_drv);
-		return;
-	}
-
-	memset(&msg, 0, sizeof(struct host_if_msg));
-
-	msg.id = HOST_IF_MSG_RCVD_NTWRK_INFO;
-	msg.vif = vif;
-
-	msg.body.net_info.len = length;
-	msg.body.net_info.buffer = kmalloc(length, GFP_KERNEL);
-	memcpy(msg.body.net_info.buffer, buffer, length);
-
-	result = wilc_enqueue_cmd(&msg);
-	if (result)
-		netdev_err(vif->ndev, "message parameters (%d)\n", result);
-}
-
-void wilc_gnrl_async_info_received(struct wilc *wilc, u8 *buffer, u32 length)
-{
-	s32 result = 0;
-	struct host_if_msg msg;
-	int id;
-	struct host_if_drv *hif_drv = NULL;
-	struct wilc_vif *vif;
-
-	mutex_lock(&hif_deinit_lock);
-
-	id = ((buffer[length - 4]) | (buffer[length - 3] << 8) | (buffer[length - 2] << 16) | (buffer[length - 1] << 24));
-	vif = wilc_get_vif_from_idx(wilc, id);
-	if (!vif) {
-		mutex_unlock(&hif_deinit_lock);
-		return;
-	}
-
-	hif_drv = vif->hif_drv;
-
-	if (!hif_drv || hif_drv == terminated_handle) {
-		mutex_unlock(&hif_deinit_lock);
-		return;
-	}
-
-	if (!hif_drv->usr_conn_req.conn_result) {
-		netdev_err(vif->ndev, "there is no current Connect Request\n");
-		mutex_unlock(&hif_deinit_lock);
-		return;
-	}
-
-	memset(&msg, 0, sizeof(struct host_if_msg));
-
-	msg.id = HOST_IF_MSG_RCVD_GNRL_ASYNC_INFO;
-	msg.vif = vif;
-
-	msg.body.async_info.len = length;
-	msg.body.async_info.buffer = kmalloc(length, GFP_KERNEL);
-	memcpy(msg.body.async_info.buffer, buffer, length);
-
-	result = wilc_enqueue_cmd(&msg);
-	if (result)
-		netdev_err(vif->ndev, "synchronous info (%d)\n", result);
-
-	mutex_unlock(&hif_deinit_lock);
-}
-
-void wilc_scan_complete_received(struct wilc *wilc, u8 *buffer, u32 length)
-{
-	s32 result = 0;
-	struct host_if_msg msg;
-	int id;
-	struct host_if_drv *hif_drv = NULL;
-	struct wilc_vif *vif;
-
-	id = ((buffer[length - 4]) | (buffer[length - 3] << 8) | (buffer[length - 2] << 16) | (buffer[length - 1] << 24));
-	vif = wilc_get_vif_from_idx(wilc, id);
-	if (!vif)
-		return;
-	hif_drv = vif->hif_drv;
-
-	if (!hif_drv || hif_drv == terminated_handle)
-		return;
-
-	if (hif_drv->usr_scan_req.scan_result) {
-		memset(&msg, 0, sizeof(struct host_if_msg));
-
-		msg.id = HOST_IF_MSG_RCVD_SCAN_COMPLETE;
-		msg.vif = vif;
-
-		result = wilc_enqueue_cmd(&msg);
-		if (result)
-			netdev_err(vif->ndev, "complete param (%d)\n", result);
-	}
-}
-
-int wilc_remain_on_channel(struct wilc_vif *vif, u32 session_id,
-			   u32 duration, u16 chan,
-			   wilc_remain_on_chan_expired expired,
-			   wilc_remain_on_chan_ready ready,
-			   void *user_arg)
-{
-	int result = 0;
-	struct host_if_msg msg;
-
-	memset(&msg, 0, sizeof(struct host_if_msg));
-
-	msg.id = HOST_IF_MSG_REMAIN_ON_CHAN;
-	msg.body.remain_on_ch.ch = chan;
-	msg.body.remain_on_ch.expired = expired;
-	msg.body.remain_on_ch.ready = ready;
-	msg.body.remain_on_ch.arg = user_arg;
-	msg.body.remain_on_ch.duration = duration;
-	msg.body.remain_on_ch.id = session_id;
-	msg.vif = vif;
-
-	result = wilc_enqueue_cmd(&msg);
-	if (result)
-		netdev_err(vif->ndev, "wilc mq send fail\n");
-
-	return result;
-}
-
-int wilc_listen_state_expired(struct wilc_vif *vif, u32 session_id)
-{
-	int result = 0;
-	struct host_if_msg msg;
-	struct host_if_drv *hif_drv = vif->hif_drv;
-
-	if (!hif_drv) {
-		netdev_err(vif->ndev, "driver is null\n");
-		return -EFAULT;
-	}
-
-	del_timer(&hif_drv->remain_on_ch_timer);
-
-	memset(&msg, 0, sizeof(struct host_if_msg));
-	msg.id = HOST_IF_MSG_LISTEN_TIMER_FIRED;
-	msg.vif = vif;
-	msg.body.remain_on_ch.id = session_id;
-
-	result = wilc_enqueue_cmd(&msg);
-	if (result)
-		netdev_err(vif->ndev, "wilc mq send fail\n");
-
-	return result;
-}
-
-int wilc_frame_register(struct wilc_vif *vif, u16 frame_type, bool reg)
-{
-	int result = 0;
-	struct host_if_msg msg;
-
-	memset(&msg, 0, sizeof(struct host_if_msg));
-
-	msg.id = HOST_IF_MSG_REGISTER_FRAME;
-	switch (frame_type) {
-	case ACTION:
-		msg.body.reg_frame.reg_id = ACTION_FRM_IDX;
-		break;
-
-	case PROBE_REQ:
-		msg.body.reg_frame.reg_id = PROBE_REQ_IDX;
-		break;
-
-	default:
-		break;
-	}
-	msg.body.reg_frame.frame_type = frame_type;
-	msg.body.reg_frame.reg = reg;
-	msg.vif = vif;
-
-	result = wilc_enqueue_cmd(&msg);
-	if (result)
-		netdev_err(vif->ndev, "wilc mq send fail\n");
-
-	return result;
-}
-
-int wilc_add_beacon(struct wilc_vif *vif, u32 interval, u32 dtim_period,
-		    u32 head_len, u8 *head, u32 tail_len, u8 *tail)
-{
-	int result = 0;
-	struct host_if_msg msg;
-	struct beacon_attr *beacon_info = &msg.body.beacon_info;
-
-	memset(&msg, 0, sizeof(struct host_if_msg));
-
-	msg.id = HOST_IF_MSG_ADD_BEACON;
-	msg.vif = vif;
-	beacon_info->interval = interval;
-	beacon_info->dtim_period = dtim_period;
-	beacon_info->head_len = head_len;
-	beacon_info->head = kmemdup(head, head_len, GFP_KERNEL);
-	if (!beacon_info->head) {
-		result = -ENOMEM;
-		goto ERRORHANDLER;
-	}
-	beacon_info->tail_len = tail_len;
-
-	if (tail_len > 0) {
-		beacon_info->tail = kmemdup(tail, tail_len, GFP_KERNEL);
-		if (!beacon_info->tail) {
-			result = -ENOMEM;
-			goto ERRORHANDLER;
-		}
-	} else {
-		beacon_info->tail = NULL;
-	}
-
-	result = wilc_enqueue_cmd(&msg);
-	if (result)
-		netdev_err(vif->ndev, "wilc mq send fail\n");
-
-ERRORHANDLER:
-	if (result) {
-		kfree(beacon_info->head);
-
-		kfree(beacon_info->tail);
-	}
-
-	return result;
-}
-
-int wilc_del_beacon(struct wilc_vif *vif)
-{
-	int result = 0;
-	struct host_if_msg msg;
-
-	msg.id = HOST_IF_MSG_DEL_BEACON;
-	msg.vif = vif;
-
-	result = wilc_enqueue_cmd(&msg);
-	if (result)
-		netdev_err(vif->ndev, "wilc_mq_send fail\n");
-
-	return result;
-}
-
-int wilc_add_station(struct wilc_vif *vif, struct add_sta_param *sta_param)
-{
-	int result = 0;
-	struct host_if_msg msg;
-	struct add_sta_param *add_sta_info = &msg.body.add_sta_info;
-
-	memset(&msg, 0, sizeof(struct host_if_msg));
-
-	msg.id = HOST_IF_MSG_ADD_STATION;
-	msg.vif = vif;
-
-	memcpy(add_sta_info, sta_param, sizeof(struct add_sta_param));
-	if (add_sta_info->rates_len > 0) {
-		add_sta_info->rates = kmemdup(sta_param->rates,
-				      add_sta_info->rates_len,
-				      GFP_KERNEL);
-		if (!add_sta_info->rates)
-			return -ENOMEM;
-	}
-
-	result = wilc_enqueue_cmd(&msg);
-	if (result)
-		netdev_err(vif->ndev, "wilc_mq_send fail\n");
-	return result;
-}
-
-int wilc_del_station(struct wilc_vif *vif, const u8 *mac_addr)
-{
-	int result = 0;
-	struct host_if_msg msg;
-	struct del_sta *del_sta_info = &msg.body.del_sta_info;
-
-	memset(&msg, 0, sizeof(struct host_if_msg));
-
-	msg.id = HOST_IF_MSG_DEL_STATION;
-	msg.vif = vif;
-
-	if (!mac_addr)
-		eth_broadcast_addr(del_sta_info->mac_addr);
-	else
-		memcpy(del_sta_info->mac_addr, mac_addr, ETH_ALEN);
-
-	result = wilc_enqueue_cmd(&msg);
-	if (result)
-		netdev_err(vif->ndev, "wilc_mq_send fail\n");
-	return result;
-}
-
-int wilc_del_allstation(struct wilc_vif *vif, u8 mac_addr[][ETH_ALEN])
-{
-	int result = 0;
-	struct host_if_msg msg;
-	struct del_all_sta *del_all_sta_info = &msg.body.del_all_sta_info;
-	u8 zero_addr[ETH_ALEN] = {0};
-	int i;
-	u8 assoc_sta = 0;
-
-	memset(&msg, 0, sizeof(struct host_if_msg));
-
-	msg.id = HOST_IF_MSG_DEL_ALL_STA;
-	msg.vif = vif;
-
-	for (i = 0; i < MAX_NUM_STA; i++) {
-		if (memcmp(mac_addr[i], zero_addr, ETH_ALEN)) {
-			memcpy(del_all_sta_info->del_all_sta[i], mac_addr[i], ETH_ALEN);
-			assoc_sta++;
-		}
-	}
-	if (!assoc_sta)
-		return result;
-
-	del_all_sta_info->assoc_sta = assoc_sta;
-	result = wilc_enqueue_cmd(&msg);
-
-	if (result)
-		netdev_err(vif->ndev, "wilc_mq_send fail\n");
-	else
-		wait_for_completion(&hif_wait_response);
-
-	return result;
-}
-
-int wilc_edit_station(struct wilc_vif *vif,
-		      struct add_sta_param *sta_param)
-{
-	int result = 0;
-	struct host_if_msg msg;
-	struct add_sta_param *add_sta_info = &msg.body.add_sta_info;
-
-	memset(&msg, 0, sizeof(struct host_if_msg));
-
-	msg.id = HOST_IF_MSG_EDIT_STATION;
-	msg.vif = vif;
-
-	memcpy(add_sta_info, sta_param, sizeof(struct add_sta_param));
-	if (add_sta_info->rates_len > 0) {
-		add_sta_info->rates = kmemdup(sta_param->rates,
-					      add_sta_info->rates_len,
-					      GFP_KERNEL);
-		if (!add_sta_info->rates)
-			return -ENOMEM;
-	}
-
-	result = wilc_enqueue_cmd(&msg);
-	if (result)
-		netdev_err(vif->ndev, "wilc_mq_send fail\n");
-
-	return result;
-}
-
-int wilc_set_power_mgmt(struct wilc_vif *vif, bool enabled, u32 timeout)
-{
-	int result = 0;
-	struct host_if_msg msg;
-	struct power_mgmt_param *pwr_mgmt_info = &msg.body.pwr_mgmt_info;
-
-	if (wilc_wlan_get_num_conn_ifcs(vif->wilc) == 2 && enabled)
-		return 0;
-
-	memset(&msg, 0, sizeof(struct host_if_msg));
-
-	msg.id = HOST_IF_MSG_POWER_MGMT;
-	msg.vif = vif;
-
-	pwr_mgmt_info->enabled = enabled;
-	pwr_mgmt_info->timeout = timeout;
-
-	result = wilc_enqueue_cmd(&msg);
-	if (result)
-		netdev_err(vif->ndev, "wilc_mq_send fail\n");
-	return result;
-}
-
-int wilc_setup_multicast_filter(struct wilc_vif *vif, bool enabled,
-				u32 count)
-{
-	int result = 0;
-	struct host_if_msg msg;
-	struct set_multicast *multicast_filter_param = &msg.body.multicast_info;
-
-	memset(&msg, 0, sizeof(struct host_if_msg));
-
-	msg.id = HOST_IF_MSG_SET_MULTICAST_FILTER;
-	msg.vif = vif;
-
-	multicast_filter_param->enabled = enabled;
-	multicast_filter_param->cnt = count;
-
-	result = wilc_enqueue_cmd(&msg);
-	if (result)
-		netdev_err(vif->ndev, "wilc_mq_send fail\n");
-	return result;
-}
-
-static void *host_int_ParseJoinBssParam(struct network_info *ptstrNetworkInfo)
-{
-	struct join_bss_param *pNewJoinBssParam = NULL;
-	u8 *pu8IEs;
-	u16 u16IEsLen;
-	u16 index = 0;
-	u8 suppRatesNo = 0;
-	u8 extSuppRatesNo;
-	u16 jumpOffset;
-	u8 pcipherCount;
-	u8 authCount;
-	u8 pcipherTotalCount = 0;
-	u8 authTotalCount = 0;
-	u8 i, j;
-
-	pu8IEs = ptstrNetworkInfo->ies;
-	u16IEsLen = ptstrNetworkInfo->ies_len;
-
-	pNewJoinBssParam = kzalloc(sizeof(*pNewJoinBssParam), GFP_KERNEL);
-	if (pNewJoinBssParam) {
-		pNewJoinBssParam->dtim_period = ptstrNetworkInfo->dtim_period;
-		pNewJoinBssParam->beacon_period = ptstrNetworkInfo->beacon_period;
-		pNewJoinBssParam->cap_info = ptstrNetworkInfo->cap_info;
-		memcpy(pNewJoinBssParam->bssid, ptstrNetworkInfo->bssid, 6);
-		memcpy((u8 *)pNewJoinBssParam->ssid, ptstrNetworkInfo->ssid,
-		       ptstrNetworkInfo->ssid_len + 1);
-		pNewJoinBssParam->ssid_len = ptstrNetworkInfo->ssid_len;
-		memset(pNewJoinBssParam->rsn_pcip_policy, 0xFF, 3);
-		memset(pNewJoinBssParam->rsn_auth_policy, 0xFF, 3);
-
-		while (index < u16IEsLen) {
-			if (pu8IEs[index] == SUPP_RATES_IE) {
-				suppRatesNo = pu8IEs[index + 1];
-				pNewJoinBssParam->supp_rates[0] = suppRatesNo;
-				index += 2;
-
-				for (i = 0; i < suppRatesNo; i++)
-					pNewJoinBssParam->supp_rates[i + 1] = pu8IEs[index + i];
-
-				index += suppRatesNo;
-			} else if (pu8IEs[index] == EXT_SUPP_RATES_IE) {
-				extSuppRatesNo = pu8IEs[index + 1];
-				if (extSuppRatesNo > (MAX_RATES_SUPPORTED - suppRatesNo))
-					pNewJoinBssParam->supp_rates[0] = MAX_RATES_SUPPORTED;
-				else
-					pNewJoinBssParam->supp_rates[0] += extSuppRatesNo;
-				index += 2;
-				for (i = 0; i < (pNewJoinBssParam->supp_rates[0] - suppRatesNo); i++)
-					pNewJoinBssParam->supp_rates[suppRatesNo + i + 1] = pu8IEs[index + i];
-
-				index += extSuppRatesNo;
-			} else if (pu8IEs[index] == HT_CAPABILITY_IE) {
-				pNewJoinBssParam->ht_capable = true;
-				index += pu8IEs[index + 1] + 2;
-			} else if ((pu8IEs[index] == WMM_IE) &&
-				   (pu8IEs[index + 2] == 0x00) && (pu8IEs[index + 3] == 0x50) &&
-				   (pu8IEs[index + 4] == 0xF2) &&
-				   (pu8IEs[index + 5] == 0x02) &&
-				   ((pu8IEs[index + 6] == 0x00) || (pu8IEs[index + 6] == 0x01)) &&
-				   (pu8IEs[index + 7] == 0x01)) {
-				pNewJoinBssParam->wmm_cap = true;
-
-				if (pu8IEs[index + 8] & BIT(7))
-					pNewJoinBssParam->uapsd_cap = true;
-				index += pu8IEs[index + 1] + 2;
-			} else if ((pu8IEs[index] == P2P_IE) &&
-				 (pu8IEs[index + 2] == 0x50) && (pu8IEs[index + 3] == 0x6f) &&
-				 (pu8IEs[index + 4] == 0x9a) &&
-				 (pu8IEs[index + 5] == 0x09) && (pu8IEs[index + 6] == 0x0c)) {
-				u16 u16P2P_count;
-
-				pNewJoinBssParam->tsf = ptstrNetworkInfo->tsf_lo;
-				pNewJoinBssParam->noa_enabled = 1;
-				pNewJoinBssParam->idx = pu8IEs[index + 9];
-
-				if (pu8IEs[index + 10] & BIT(7)) {
-					pNewJoinBssParam->opp_enabled = 1;
-					pNewJoinBssParam->ct_window = pu8IEs[index + 10];
-				} else {
-					pNewJoinBssParam->opp_enabled = 0;
-				}
-
-				pNewJoinBssParam->cnt = pu8IEs[index + 11];
-				u16P2P_count = index + 12;
-
-				memcpy(pNewJoinBssParam->duration, pu8IEs + u16P2P_count, 4);
-				u16P2P_count += 4;
-
-				memcpy(pNewJoinBssParam->interval, pu8IEs + u16P2P_count, 4);
-				u16P2P_count += 4;
-
-				memcpy(pNewJoinBssParam->start_time, pu8IEs + u16P2P_count, 4);
-
-				index += pu8IEs[index + 1] + 2;
-			} else if ((pu8IEs[index] == RSN_IE) ||
-				 ((pu8IEs[index] == WPA_IE) && (pu8IEs[index + 2] == 0x00) &&
-				  (pu8IEs[index + 3] == 0x50) && (pu8IEs[index + 4] == 0xF2) &&
-				  (pu8IEs[index + 5] == 0x01)))	{
-				u16 rsnIndex = index;
-
-				if (pu8IEs[rsnIndex] == RSN_IE)	{
-					pNewJoinBssParam->mode_802_11i = 2;
-				} else {
-					if (pNewJoinBssParam->mode_802_11i == 0)
-						pNewJoinBssParam->mode_802_11i = 1;
-					rsnIndex += 4;
-				}
-
-				rsnIndex += 7;
-				pNewJoinBssParam->rsn_grp_policy = pu8IEs[rsnIndex];
-				rsnIndex++;
-				jumpOffset = pu8IEs[rsnIndex] * 4;
-				pcipherCount = (pu8IEs[rsnIndex] > 3) ? 3 : pu8IEs[rsnIndex];
-				rsnIndex += 2;
-
-				for (i = pcipherTotalCount, j = 0; i < pcipherCount + pcipherTotalCount && i < 3; i++, j++)
-					pNewJoinBssParam->rsn_pcip_policy[i] = pu8IEs[rsnIndex + ((j + 1) * 4) - 1];
-
-				pcipherTotalCount += pcipherCount;
-				rsnIndex += jumpOffset;
-
-				jumpOffset = pu8IEs[rsnIndex] * 4;
-
-				authCount = (pu8IEs[rsnIndex] > 3) ? 3 : pu8IEs[rsnIndex];
-				rsnIndex += 2;
-
-				for (i = authTotalCount, j = 0; i < authTotalCount + authCount; i++, j++)
-					pNewJoinBssParam->rsn_auth_policy[i] = pu8IEs[rsnIndex + ((j + 1) * 4) - 1];
-
-				authTotalCount += authCount;
-				rsnIndex += jumpOffset;
-
-				if (pu8IEs[index] == RSN_IE) {
-					pNewJoinBssParam->rsn_cap[0] = pu8IEs[rsnIndex];
-					pNewJoinBssParam->rsn_cap[1] = pu8IEs[rsnIndex + 1];
-					rsnIndex += 2;
-				}
-				pNewJoinBssParam->rsn_found = true;
-				index += pu8IEs[index + 1] + 2;
-			} else {
-				index += pu8IEs[index + 1] + 2;
-			}
-		}
-	}
-
-	return (void *)pNewJoinBssParam;
-}
-
-int wilc_setup_ipaddress(struct wilc_vif *vif, u8 *ip_addr, u8 idx)
-{
-	int result = 0;
-	struct host_if_msg msg;
-
-	memset(&msg, 0, sizeof(struct host_if_msg));
-
-	msg.id = HOST_IF_MSG_SET_IPADDRESS;
-
-	msg.body.ip_info.ip_addr = ip_addr;
-	msg.vif = vif;
-	msg.body.ip_info.idx = idx;
-
-	result = wilc_enqueue_cmd(&msg);
-	if (result)
-		netdev_err(vif->ndev, "wilc_mq_send fail\n");
-
-	return result;
-}
-
-static int host_int_get_ipaddress(struct wilc_vif *vif, u8 *ip_addr, u8 idx)
-{
-	int result = 0;
-	struct host_if_msg msg;
-
-	memset(&msg, 0, sizeof(struct host_if_msg));
-
-	msg.id = HOST_IF_MSG_GET_IPADDRESS;
-
-	msg.body.ip_info.ip_addr = ip_addr;
-	msg.vif = vif;
-	msg.body.ip_info.idx = idx;
-
-	result = wilc_enqueue_cmd(&msg);
-	if (result)
-		netdev_err(vif->ndev, "wilc_mq_send fail\n");
-
-	return result;
-}
-
-int wilc_set_tx_power(struct wilc_vif *vif, u8 tx_power)
-{
-	int ret = 0;
-	struct host_if_msg msg;
-
-	memset(&msg, 0, sizeof(struct host_if_msg));
-
-	msg.id = HOST_IF_MSG_SET_TX_POWER;
-	msg.body.tx_power.tx_pwr = tx_power;
-	msg.vif = vif;
-
-	ret = wilc_enqueue_cmd(&msg);
-	if (ret)
-		netdev_err(vif->ndev, "wilc_mq_send fail\n");
-
-	return ret;
-}
-
-int wilc_get_tx_power(struct wilc_vif *vif, u8 *tx_power)
-{
-	int ret = 0;
-	struct host_if_msg msg;
-
-	memset(&msg, 0, sizeof(struct host_if_msg));
-
-	msg.id = HOST_IF_MSG_GET_TX_POWER;
-	msg.vif = vif;
-
-	ret = wilc_enqueue_cmd(&msg);
-	if (ret)
-		netdev_err(vif->ndev, "Failed to get TX PWR\n");
-
-	wait_for_completion(&hif_wait_response);
-	*tx_power = msg.body.tx_power.tx_pwr;
-
-	return ret;
-}
diff --git a/drivers/staging/wilc1000/linux_wlan.c b/drivers/staging/wilc1000/linux_wlan.c
deleted file mode 100644
index 119f345..0000000
--- a/drivers/staging/wilc1000/linux_wlan.c
+++ /dev/null
@@ -1,1280 +0,0 @@
-#include "wilc_wfi_cfgoperations.h"
-#include "wilc_wlan_if.h"
-#include "wilc_wlan.h"
-
-#include <linux/slab.h>
-#include <linux/sched.h>
-#include <linux/delay.h>
-#include <linux/workqueue.h>
-#include <linux/interrupt.h>
-#include <linux/irq.h>
-#include <linux/gpio.h>
-
-#include <linux/kthread.h>
-#include <linux/firmware.h>
-
-#include <linux/init.h>
-#include <linux/netdevice.h>
-#include <linux/inetdevice.h>
-#include <linux/etherdevice.h>
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/skbuff.h>
-#include <linux/mutex.h>
-#include <linux/completion.h>
-
-static int dev_state_ev_handler(struct notifier_block *this,
-				unsigned long event, void *ptr);
-
-static struct notifier_block g_dev_notifier = {
-	.notifier_call = dev_state_ev_handler
-};
-
-static int wlan_deinit_locks(struct net_device *dev);
-static void wlan_deinitialize_threads(struct net_device *dev);
-
-static void linux_wlan_tx_complete(void *priv, int status);
-static int  mac_init_fn(struct net_device *ndev);
-static struct net_device_stats *mac_stats(struct net_device *dev);
-static int  mac_ioctl(struct net_device *ndev, struct ifreq *req, int cmd);
-static int wilc_mac_open(struct net_device *ndev);
-static int wilc_mac_close(struct net_device *ndev);
-static void wilc_set_multicast_list(struct net_device *dev);
-
-bool wilc_enable_ps = true;
-
-static const struct net_device_ops wilc_netdev_ops = {
-	.ndo_init = mac_init_fn,
-	.ndo_open = wilc_mac_open,
-	.ndo_stop = wilc_mac_close,
-	.ndo_start_xmit = wilc_mac_xmit,
-	.ndo_do_ioctl = mac_ioctl,
-	.ndo_get_stats = mac_stats,
-	.ndo_set_rx_mode  = wilc_set_multicast_list,
-
-};
-
-static int dev_state_ev_handler(struct notifier_block *this,
-				unsigned long event, void *ptr)
-{
-	struct in_ifaddr *dev_iface = ptr;
-	struct wilc_priv *priv;
-	struct host_if_drv *hif_drv;
-	struct net_device *dev;
-	u8 *ip_addr_buf;
-	struct wilc_vif *vif;
-	u8 null_ip[4] = {0};
-	char wlan_dev_name[5] = "wlan0";
-
-	if (!dev_iface || !dev_iface->ifa_dev || !dev_iface->ifa_dev->dev)
-		return NOTIFY_DONE;
-
-	if (memcmp(dev_iface->ifa_label, "wlan0", 5) &&
-	    memcmp(dev_iface->ifa_label, "p2p0", 4))
-		return NOTIFY_DONE;
-
-	dev  = (struct net_device *)dev_iface->ifa_dev->dev;
-	if (!dev->ieee80211_ptr || !dev->ieee80211_ptr->wiphy)
-		return NOTIFY_DONE;
-
-	priv = wiphy_priv(dev->ieee80211_ptr->wiphy);
-	if (!priv)
-		return NOTIFY_DONE;
-
-	hif_drv = (struct host_if_drv *)priv->hif_drv;
-	vif = netdev_priv(dev);
-	if (!vif || !hif_drv)
-		return NOTIFY_DONE;
-
-	switch (event) {
-	case NETDEV_UP:
-		if (vif->iftype == STATION_MODE || vif->iftype == CLIENT_MODE) {
-			hif_drv->IFC_UP = 1;
-			wilc_optaining_ip = false;
-			del_timer(&wilc_during_ip_timer);
-		}
-
-		if (wilc_enable_ps)
-			wilc_set_power_mgmt(vif, 1, 0);
-
-		netdev_dbg(dev, "[%s] Up IP\n", dev_iface->ifa_label);
-
-		ip_addr_buf = (char *)&dev_iface->ifa_address;
-		netdev_dbg(dev, "IP add=%d:%d:%d:%d\n",
-			   ip_addr_buf[0], ip_addr_buf[1],
-			   ip_addr_buf[2], ip_addr_buf[3]);
-		wilc_setup_ipaddress(vif, ip_addr_buf, vif->idx);
-
-		break;
-
-	case NETDEV_DOWN:
-		if (vif->iftype == STATION_MODE || vif->iftype == CLIENT_MODE) {
-			hif_drv->IFC_UP = 0;
-			wilc_optaining_ip = false;
-		}
-
-		if (memcmp(dev_iface->ifa_label, wlan_dev_name, 5) == 0)
-			wilc_set_power_mgmt(vif, 0, 0);
-
-		wilc_resolve_disconnect_aberration(vif);
-
-		netdev_dbg(dev, "[%s] Down IP\n", dev_iface->ifa_label);
-
-		ip_addr_buf = null_ip;
-		netdev_dbg(dev, "IP add=%d:%d:%d:%d\n",
-			   ip_addr_buf[0], ip_addr_buf[1],
-			   ip_addr_buf[2], ip_addr_buf[3]);
-
-		wilc_setup_ipaddress(vif, ip_addr_buf, vif->idx);
-
-		break;
-
-	default:
-		break;
-	}
-
-	return NOTIFY_DONE;
-}
-
-static irqreturn_t isr_uh_routine(int irq, void *user_data)
-{
-	struct wilc_vif *vif;
-	struct wilc *wilc;
-	struct net_device *dev = user_data;
-
-	vif = netdev_priv(dev);
-	wilc = vif->wilc;
-
-	if (wilc->close) {
-		netdev_err(dev, "Can't handle UH interrupt\n");
-		return IRQ_HANDLED;
-	}
-	return IRQ_WAKE_THREAD;
-}
-
-static irqreturn_t isr_bh_routine(int irq, void *userdata)
-{
-	struct wilc_vif *vif;
-	struct wilc *wilc;
-	struct net_device *dev = userdata;
-
-	vif = netdev_priv(userdata);
-	wilc = vif->wilc;
-
-	if (wilc->close) {
-		netdev_err(dev, "Can't handle BH interrupt\n");
-		return IRQ_HANDLED;
-	}
-
-	wilc_handle_isr(wilc);
-
-	return IRQ_HANDLED;
-}
-
-static int init_irq(struct net_device *dev)
-{
-	int ret = 0;
-	struct wilc_vif *vif;
-	struct wilc *wl;
-
-	vif = netdev_priv(dev);
-	wl = vif->wilc;
-
-	if ((gpio_request(wl->gpio, "WILC_INTR") == 0) &&
-	    (gpio_direction_input(wl->gpio) == 0)) {
-		wl->dev_irq_num = gpio_to_irq(wl->gpio);
-	} else {
-		ret = -1;
-		netdev_err(dev, "could not obtain gpio for WILC_INTR\n");
-	}
-
-	if (ret != -1 && request_threaded_irq(wl->dev_irq_num,
-					      isr_uh_routine,
-					      isr_bh_routine,
-					      IRQF_TRIGGER_LOW | IRQF_ONESHOT,
-					      "WILC_IRQ", dev) < 0) {
-		netdev_err(dev, "Failed to request IRQ GPIO: %d\n", wl->gpio);
-		gpio_free(wl->gpio);
-		ret = -1;
-	} else {
-		netdev_dbg(dev,
-			   "IRQ request succeeded IRQ-NUM= %d on GPIO: %d\n",
-			   wl->dev_irq_num, wl->gpio);
-	}
-
-	return ret;
-}
-
-static void deinit_irq(struct net_device *dev)
-{
-	struct wilc_vif *vif;
-	struct wilc *wilc;
-
-	vif = netdev_priv(dev);
-	wilc = vif->wilc;
-
-	/* Deinitialize IRQ */
-	if (wilc->dev_irq_num) {
-		free_irq(wilc->dev_irq_num, wilc);
-		gpio_free(wilc->gpio);
-	}
-}
-
-void wilc_mac_indicate(struct wilc *wilc, int flag)
-{
-	int status;
-
-	if (flag == WILC_MAC_INDICATE_STATUS) {
-		wilc_wlan_cfg_get_val(WID_STATUS,
-				      (unsigned char *)&status, 4);
-		if (wilc->mac_status == WILC_MAC_STATUS_INIT) {
-			wilc->mac_status = status;
-			complete(&wilc->sync_event);
-		} else {
-			wilc->mac_status = status;
-		}
-	}
-}
-
-static struct net_device *get_if_handler(struct wilc *wilc, u8 *mac_header)
-{
-	u8 *bssid, *bssid1;
-	int i = 0;
-
-	bssid = mac_header + 10;
-	bssid1 = mac_header + 4;
-
-	for (i = 0; i < wilc->vif_num; i++) {
-		if (wilc->vif[i]->mode == STATION_MODE)
-			if (ether_addr_equal_unaligned(bssid,
-						       wilc->vif[i]->bssid))
-				return wilc->vif[i]->ndev;
-		if (wilc->vif[i]->mode == AP_MODE)
-			if (ether_addr_equal_unaligned(bssid1,
-						       wilc->vif[i]->bssid))
-				return wilc->vif[i]->ndev;
-	}
-
-	return NULL;
-}
-
-int wilc_wlan_set_bssid(struct net_device *wilc_netdev, u8 *bssid, u8 mode)
-{
-	struct wilc_vif *vif = netdev_priv(wilc_netdev);
-
-	memcpy(vif->bssid, bssid, 6);
-	vif->mode = mode;
-
-	return 0;
-}
-
-int wilc_wlan_get_num_conn_ifcs(struct wilc *wilc)
-{
-	u8 i = 0;
-	u8 null_bssid[6] = {0};
-	u8 ret_val = 0;
-
-	for (i = 0; i < wilc->vif_num; i++)
-		if (memcmp(wilc->vif[i]->bssid, null_bssid, 6))
-			ret_val++;
-
-	return ret_val;
-}
-
-static int linux_wlan_txq_task(void *vp)
-{
-	int ret;
-	u32 txq_count;
-	struct wilc_vif *vif;
-	struct wilc *wl;
-	struct net_device *dev = vp;
-
-	vif = netdev_priv(dev);
-	wl = vif->wilc;
-
-	complete(&wl->txq_thread_started);
-	while (1) {
-		wait_for_completion(&wl->txq_event);
-
-		if (wl->close) {
-			complete(&wl->txq_thread_started);
-
-			while (!kthread_should_stop())
-				schedule();
-			break;
-		}
-		do {
-			ret = wilc_wlan_handle_txq(dev, &txq_count);
-			if (txq_count < FLOW_CONTROL_LOWER_THRESHOLD) {
-				if (netif_queue_stopped(wl->vif[0]->ndev))
-					netif_wake_queue(wl->vif[0]->ndev);
-				if (netif_queue_stopped(wl->vif[1]->ndev))
-					netif_wake_queue(wl->vif[1]->ndev);
-			}
-		} while (ret == WILC_TX_ERR_NO_BUF && !wl->close);
-	}
-	return 0;
-}
-
-int wilc_wlan_get_firmware(struct net_device *dev)
-{
-	struct wilc_vif *vif;
-	struct wilc *wilc;
-	int chip_id, ret = 0;
-	const struct firmware *wilc_firmware;
-	char *firmware;
-
-	vif = netdev_priv(dev);
-	wilc = vif->wilc;
-
-	chip_id = wilc_get_chipid(wilc, false);
-
-	if (chip_id < 0x1003a0)
-		firmware = FIRMWARE_1002;
-	else
-		firmware = FIRMWARE_1003;
-
-	netdev_info(dev, "loading firmware %s\n", firmware);
-
-	if (!(&vif->ndev->dev))
-		goto _fail_;
-
-	if (request_firmware(&wilc_firmware, firmware, wilc->dev) != 0) {
-		netdev_err(dev, "%s - firmware not available\n", firmware);
-		ret = -1;
-		goto _fail_;
-	}
-	wilc->firmware = wilc_firmware;
-
-_fail_:
-
-	return ret;
-}
-
-static int linux_wlan_start_firmware(struct net_device *dev)
-{
-	struct wilc_vif *vif;
-	struct wilc *wilc;
-	int ret = 0;
-
-	vif = netdev_priv(dev);
-	wilc = vif->wilc;
-
-	ret = wilc_wlan_start(wilc);
-	if (ret < 0)
-		return ret;
-
-	if (!wait_for_completion_timeout(&wilc->sync_event,
-					 msecs_to_jiffies(5000)))
-		return -ETIME;
-
-	return 0;
-}
-
-static int wilc1000_firmware_download(struct net_device *dev)
-{
-	struct wilc_vif *vif;
-	struct wilc *wilc;
-	int ret = 0;
-
-	vif = netdev_priv(dev);
-	wilc = vif->wilc;
-
-	if (!wilc->firmware) {
-		netdev_err(dev, "Firmware buffer is NULL\n");
-		return -ENOBUFS;
-	}
-
-	ret = wilc_wlan_firmware_download(wilc, wilc->firmware->data,
-					  wilc->firmware->size);
-	if (ret < 0)
-		return ret;
-
-	release_firmware(wilc->firmware);
-	wilc->firmware = NULL;
-
-	netdev_dbg(dev, "Download Succeeded\n");
-
-	return 0;
-}
-
-static int linux_wlan_init_test_config(struct net_device *dev,
-				       struct wilc_vif *vif)
-{
-	unsigned char c_val[64];
-	struct wilc *wilc = vif->wilc;
-	struct wilc_priv *priv;
-	struct host_if_drv *hif_drv;
-
-	netdev_dbg(dev, "Start configuring Firmware\n");
-	priv = wiphy_priv(dev->ieee80211_ptr->wiphy);
-	hif_drv = (struct host_if_drv *)priv->hif_drv;
-	netdev_dbg(dev, "Host = %p\n", hif_drv);
-	wilc_get_chipid(wilc, false);
-
-	*(int *)c_val = 1;
-
-	if (!wilc_wlan_cfg_set(vif, 1, WID_SET_DRV_HANDLER, c_val, 4, 0, 0))
-		goto _fail_;
-
-	c_val[0] = 0;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_PC_TEST_MODE, c_val, 1, 0, 0))
-		goto _fail_;
-
-	c_val[0] = INFRASTRUCTURE;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_BSS_TYPE, c_val, 1, 0, 0))
-		goto _fail_;
-
-	c_val[0] = RATE_AUTO;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_CURRENT_TX_RATE, c_val, 1, 0, 0))
-		goto _fail_;
-
-	c_val[0] = G_MIXED_11B_2_MODE;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_11G_OPERATING_MODE, c_val, 1, 0,
-			       0))
-		goto _fail_;
-
-	c_val[0] = 1;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_CURRENT_CHANNEL, c_val, 1, 0, 0))
-		goto _fail_;
-
-	c_val[0] = G_SHORT_PREAMBLE;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_PREAMBLE, c_val, 1, 0, 0))
-		goto _fail_;
-
-	c_val[0] = AUTO_PROT;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_11N_PROT_MECH, c_val, 1, 0, 0))
-		goto _fail_;
-
-	c_val[0] = ACTIVE_SCAN;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_SCAN_TYPE, c_val, 1, 0, 0))
-		goto _fail_;
-
-	c_val[0] = SITE_SURVEY_OFF;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_SITE_SURVEY, c_val, 1, 0, 0))
-		goto _fail_;
-
-	*((int *)c_val) = 0xffff;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_RTS_THRESHOLD, c_val, 2, 0, 0))
-		goto _fail_;
-
-	*((int *)c_val) = 2346;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_FRAG_THRESHOLD, c_val, 2, 0, 0))
-		goto _fail_;
-
-	c_val[0] = 0;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_BCAST_SSID, c_val, 1, 0, 0))
-		goto _fail_;
-
-	c_val[0] = 1;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_QOS_ENABLE, c_val, 1, 0, 0))
-		goto _fail_;
-
-	c_val[0] = NO_POWERSAVE;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_POWER_MANAGEMENT, c_val, 1, 0, 0))
-		goto _fail_;
-
-	c_val[0] = NO_SECURITY; /* NO_ENCRYPT, 0x79 */
-	if (!wilc_wlan_cfg_set(vif, 0, WID_11I_MODE, c_val, 1, 0, 0))
-		goto _fail_;
-
-	c_val[0] = OPEN_SYSTEM;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_AUTH_TYPE, c_val, 1, 0, 0))
-		goto _fail_;
-
-	strcpy(c_val, "123456790abcdef1234567890");
-	if (!wilc_wlan_cfg_set(vif, 0, WID_WEP_KEY_VALUE, c_val,
-			       (strlen(c_val) + 1), 0, 0))
-		goto _fail_;
-
-	strcpy(c_val, "12345678");
-	if (!wilc_wlan_cfg_set(vif, 0, WID_11I_PSK, c_val, (strlen(c_val)), 0,
-			       0))
-		goto _fail_;
-
-	strcpy(c_val, "password");
-	if (!wilc_wlan_cfg_set(vif, 0, WID_1X_KEY, c_val, (strlen(c_val) + 1),
-			       0, 0))
-		goto _fail_;
-
-	c_val[0] = 192;
-	c_val[1] = 168;
-	c_val[2] = 1;
-	c_val[3] = 112;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_1X_SERV_ADDR, c_val, 4, 0, 0))
-		goto _fail_;
-
-	c_val[0] = 3;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_LISTEN_INTERVAL, c_val, 1, 0, 0))
-		goto _fail_;
-
-	c_val[0] = 3;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_DTIM_PERIOD, c_val, 1, 0, 0))
-		goto _fail_;
-
-	c_val[0] = NORMAL_ACK;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_ACK_POLICY, c_val, 1, 0, 0))
-		goto _fail_;
-
-	c_val[0] = 0;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_USER_CONTROL_ON_TX_POWER, c_val, 1,
-			       0, 0))
-		goto _fail_;
-
-	c_val[0] = 48;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_TX_POWER_LEVEL_11A, c_val, 1, 0,
-			       0))
-		goto _fail_;
-
-	c_val[0] = 28;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_TX_POWER_LEVEL_11B, c_val, 1, 0,
-			       0))
-		goto _fail_;
-
-	*((int *)c_val) = 100;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_BEACON_INTERVAL, c_val, 2, 0, 0))
-		goto _fail_;
-
-	c_val[0] = REKEY_DISABLE;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_REKEY_POLICY, c_val, 1, 0, 0))
-		goto _fail_;
-
-	*((int *)c_val) = 84600;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_REKEY_PERIOD, c_val, 4, 0, 0))
-		goto _fail_;
-
-	*((int *)c_val) = 500;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_REKEY_PACKET_COUNT, c_val, 4, 0,
-			       0))
-		goto _fail_;
-
-	c_val[0] = 1;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_SHORT_SLOT_ALLOWED, c_val, 1, 0,
-			       0))
-		goto _fail_;
-
-	c_val[0] = G_SELF_CTS_PROT;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_11N_ERP_PROT_TYPE, c_val, 1, 0, 0))
-		goto _fail_;
-
-	c_val[0] = 1;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_11N_ENABLE, c_val, 1, 0, 0))
-		goto _fail_;
-
-	c_val[0] = HT_MIXED_MODE;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_11N_OPERATING_MODE, c_val, 1, 0,
-			       0))
-		goto _fail_;
-
-	c_val[0] = 1;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_11N_TXOP_PROT_DISABLE, c_val, 1, 0,
-			       0))
-		goto _fail_;
-
-	c_val[0] = DETECT_PROTECT_REPORT;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_11N_OBSS_NONHT_DETECTION, c_val, 1,
-			       0, 0))
-		goto _fail_;
-
-	c_val[0] = RTS_CTS_NONHT_PROT;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_11N_HT_PROT_TYPE, c_val, 1, 0, 0))
-		goto _fail_;
-
-	c_val[0] = 0;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_11N_RIFS_PROT_ENABLE, c_val, 1, 0,
-			       0))
-		goto _fail_;
-
-	c_val[0] = MIMO_MODE;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_11N_SMPS_MODE, c_val, 1, 0, 0))
-		goto _fail_;
-
-	c_val[0] = 7;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_11N_CURRENT_TX_MCS, c_val, 1, 0,
-			       0))
-		goto _fail_;
-
-	c_val[0] = 1;
-	if (!wilc_wlan_cfg_set(vif, 0, WID_11N_IMMEDIATE_BA_ENABLED, c_val, 1,
-			       1, 1))
-		goto _fail_;
-
-	return 0;
-
-_fail_:
-	return -1;
-}
-
-void wilc1000_wlan_deinit(struct net_device *dev)
-{
-	struct wilc_vif *vif;
-	struct wilc *wl;
-
-	vif = netdev_priv(dev);
-	wl = vif->wilc;
-
-	if (!wl) {
-		netdev_err(dev, "wl is NULL\n");
-		return;
-	}
-
-	if (wl->initialized)	{
-		netdev_info(dev, "Deinitializing wilc1000...\n");
-
-		if (!wl->dev_irq_num &&
-		    wl->hif_func->disable_interrupt) {
-			mutex_lock(&wl->hif_cs);
-			wl->hif_func->disable_interrupt(wl);
-			mutex_unlock(&wl->hif_cs);
-		}
-		if (&wl->txq_event)
-			complete(&wl->txq_event);
-
-		wlan_deinitialize_threads(dev);
-		deinit_irq(dev);
-
-		wilc_wlan_stop(wl);
-		wilc_wlan_cleanup(dev);
-		wlan_deinit_locks(dev);
-
-		wl->initialized = false;
-
-		netdev_dbg(dev, "wilc1000 deinitialization Done\n");
-	} else {
-		netdev_dbg(dev, "wilc1000 is not initialized\n");
-	}
-}
-
-static int wlan_init_locks(struct net_device *dev)
-{
-	struct wilc_vif *vif;
-	struct wilc *wl;
-
-	vif = netdev_priv(dev);
-	wl = vif->wilc;
-
-	mutex_init(&wl->hif_cs);
-	mutex_init(&wl->rxq_cs);
-
-	spin_lock_init(&wl->txq_spinlock);
-	mutex_init(&wl->txq_add_to_head_cs);
-
-	init_completion(&wl->txq_event);
-
-	init_completion(&wl->cfg_event);
-	init_completion(&wl->sync_event);
-	init_completion(&wl->txq_thread_started);
-
-	return 0;
-}
-
-static int wlan_deinit_locks(struct net_device *dev)
-{
-	struct wilc_vif *vif;
-	struct wilc *wilc;
-
-	vif = netdev_priv(dev);
-	wilc = vif->wilc;
-
-	if (&wilc->hif_cs)
-		mutex_destroy(&wilc->hif_cs);
-
-	if (&wilc->rxq_cs)
-		mutex_destroy(&wilc->rxq_cs);
-
-	return 0;
-}
-
-static int wlan_initialize_threads(struct net_device *dev)
-{
-	struct wilc_vif *vif;
-	struct wilc *wilc;
-
-	vif = netdev_priv(dev);
-	wilc = vif->wilc;
-
-	wilc->txq_thread = kthread_run(linux_wlan_txq_task, (void *)dev,
-				     "K_TXQ_TASK");
-	if (IS_ERR(wilc->txq_thread)) {
-		netdev_err(dev, "couldn't create TXQ thread\n");
-		wilc->close = 0;
-		return PTR_ERR(wilc->txq_thread);
-	}
-	wait_for_completion(&wilc->txq_thread_started);
-
-	return 0;
-}
-
-static void wlan_deinitialize_threads(struct net_device *dev)
-{
-	struct wilc_vif *vif;
-	struct wilc *wl;
-
-	vif = netdev_priv(dev);
-	wl = vif->wilc;
-
-	wl->close = 1;
-
-	if (&wl->txq_event)
-		complete(&wl->txq_event);
-
-	if (wl->txq_thread) {
-		kthread_stop(wl->txq_thread);
-		wl->txq_thread = NULL;
-	}
-}
-
-int wilc1000_wlan_init(struct net_device *dev, struct wilc_vif *vif)
-{
-	int ret = 0;
-	struct wilc *wl = vif->wilc;
-
-	if (!wl->initialized) {
-		wl->mac_status = WILC_MAC_STATUS_INIT;
-		wl->close = 0;
-
-		wlan_init_locks(dev);
-
-		ret = wilc_wlan_init(dev);
-		if (ret < 0) {
-			ret = -EIO;
-			goto _fail_locks_;
-		}
-
-		if (wl->gpio >= 0 && init_irq(dev)) {
-			ret = -EIO;
-			goto _fail_locks_;
-		}
-
-		ret = wlan_initialize_threads(dev);
-		if (ret < 0) {
-			ret = -EIO;
-			goto _fail_wilc_wlan_;
-		}
-
-		if (!wl->dev_irq_num &&
-		    wl->hif_func->enable_interrupt &&
-		    wl->hif_func->enable_interrupt(wl)) {
-			ret = -EIO;
-			goto _fail_irq_init_;
-		}
-
-		if (wilc_wlan_get_firmware(dev)) {
-			ret = -EIO;
-			goto _fail_irq_enable_;
-		}
-
-		ret = wilc1000_firmware_download(dev);
-		if (ret < 0) {
-			ret = -EIO;
-			goto _fail_irq_enable_;
-		}
-
-		ret = linux_wlan_start_firmware(dev);
-		if (ret < 0) {
-			ret = -EIO;
-			goto _fail_irq_enable_;
-		}
-
-		if (wilc_wlan_cfg_get(vif, 1, WID_FIRMWARE_VERSION, 1, 0)) {
-			int size;
-			char firmware_ver[20];
-
-			size = wilc_wlan_cfg_get_val(WID_FIRMWARE_VERSION,
-						     firmware_ver,
-						     sizeof(firmware_ver));
-			firmware_ver[size] = '\0';
-			netdev_dbg(dev, "Firmware Ver = %s\n", firmware_ver);
-		}
-		ret = linux_wlan_init_test_config(dev, vif);
-
-		if (ret < 0) {
-			netdev_err(dev, "Failed to configure firmware\n");
-			ret = -EIO;
-			goto _fail_fw_start_;
-		}
-
-		wl->initialized = true;
-		return 0;
-
-_fail_fw_start_:
-		wilc_wlan_stop(wl);
-
-_fail_irq_enable_:
-		if (!wl->dev_irq_num &&
-		    wl->hif_func->disable_interrupt)
-			wl->hif_func->disable_interrupt(wl);
-_fail_irq_init_:
-		if (wl->dev_irq_num)
-			deinit_irq(dev);
-
-		wlan_deinitialize_threads(dev);
-_fail_wilc_wlan_:
-		wilc_wlan_cleanup(dev);
-_fail_locks_:
-		wlan_deinit_locks(dev);
-		netdev_err(dev, "WLAN initialization FAILED\n");
-	} else {
-		netdev_dbg(dev, "wilc1000 already initialized\n");
-	}
-	return ret;
-}
-
-static int mac_init_fn(struct net_device *ndev)
-{
-	netif_start_queue(ndev);
-	netif_stop_queue(ndev);
-
-	return 0;
-}
-
-static int wilc_mac_open(struct net_device *ndev)
-{
-	struct wilc_vif *vif;
-
-	unsigned char mac_add[ETH_ALEN] = {0};
-	int ret = 0;
-	int i = 0;
-	struct wilc *wl;
-
-	vif = netdev_priv(ndev);
-	wl = vif->wilc;
-
-	if (!wl || !wl->dev) {
-		netdev_err(ndev, "device not ready\n");
-		return -ENODEV;
-	}
-
-	netdev_dbg(ndev, "MAC OPEN[%p]\n", ndev);
-
-	ret = wilc_init_host_int(ndev);
-	if (ret < 0)
-		return ret;
-
-	ret = wilc1000_wlan_init(ndev, vif);
-	if (ret < 0) {
-		wilc_deinit_host_int(ndev);
-		return ret;
-	}
-
-	for (i = 0; i < wl->vif_num; i++) {
-		if (ndev == wl->vif[i]->ndev) {
-			wilc_set_wfi_drv_handler(vif, wilc_get_vif_idx(vif),
-						 vif->iftype, vif->ifc_id);
-			wilc_set_operation_mode(vif, vif->iftype);
-			break;
-		}
-	}
-			wilc_get_mac_address(vif, mac_add);
-			netdev_dbg(ndev, "Mac address: %pM\n", mac_add);
-			memcpy(wl->vif[i]->src_addr, mac_add, ETH_ALEN);
-
-	memcpy(ndev->dev_addr, wl->vif[i]->src_addr, ETH_ALEN);
-
-	if (!is_valid_ether_addr(ndev->dev_addr)) {
-		netdev_err(ndev, "Wrong MAC address\n");
-		wilc_deinit_host_int(ndev);
-		wilc1000_wlan_deinit(ndev);
-		return -EINVAL;
-	}
-
-	wilc_mgmt_frame_register(vif->ndev->ieee80211_ptr->wiphy,
-				 vif->ndev->ieee80211_ptr,
-				 vif->frame_reg[0].type,
-				 vif->frame_reg[0].reg);
-	wilc_mgmt_frame_register(vif->ndev->ieee80211_ptr->wiphy,
-				 vif->ndev->ieee80211_ptr,
-				 vif->frame_reg[1].type,
-				 vif->frame_reg[1].reg);
-	netif_wake_queue(ndev);
-	wl->open_ifcs++;
-	vif->mac_opened = 1;
-	return 0;
-}
-
-static struct net_device_stats *mac_stats(struct net_device *dev)
-{
-	struct wilc_vif *vif = netdev_priv(dev);
-
-	return &vif->netstats;
-}
-
-static void wilc_set_multicast_list(struct net_device *dev)
-{
-	struct netdev_hw_addr *ha;
-	struct wilc_vif *vif;
-	int i = 0;
-
-	vif = netdev_priv(dev);
-
-	if (dev->flags & IFF_PROMISC)
-		return;
-
-	if ((dev->flags & IFF_ALLMULTI) ||
-	    (dev->mc.count) > WILC_MULTICAST_TABLE_SIZE) {
-		wilc_setup_multicast_filter(vif, false, 0);
-		return;
-	}
-
-	if ((dev->mc.count) == 0) {
-		wilc_setup_multicast_filter(vif, true, 0);
-		return;
-	}
-
-	netdev_for_each_mc_addr(ha, dev) {
-		memcpy(wilc_multicast_mac_addr_list[i], ha->addr, ETH_ALEN);
-		netdev_dbg(dev, "Entry[%d]: %x:%x:%x:%x:%x:%x\n", i,
-			   wilc_multicast_mac_addr_list[i][0],
-			   wilc_multicast_mac_addr_list[i][1],
-			   wilc_multicast_mac_addr_list[i][2],
-			   wilc_multicast_mac_addr_list[i][3],
-			   wilc_multicast_mac_addr_list[i][4],
-			   wilc_multicast_mac_addr_list[i][5]);
-		i++;
-	}
-
-	wilc_setup_multicast_filter(vif, true, (dev->mc.count));
-}
-
-static void linux_wlan_tx_complete(void *priv, int status)
-{
-	struct tx_complete_data *pv_data = priv;
-
-	dev_kfree_skb(pv_data->skb);
-	kfree(pv_data);
-}
-
-int wilc_mac_xmit(struct sk_buff *skb, struct net_device *ndev)
-{
-	struct wilc_vif *vif;
-	struct tx_complete_data *tx_data = NULL;
-	int queue_count;
-	char *udp_buf;
-	struct iphdr *ih;
-	struct ethhdr *eth_h;
-	struct wilc *wilc;
-
-	vif = netdev_priv(ndev);
-	wilc = vif->wilc;
-
-	if (skb->dev != ndev) {
-		netdev_err(ndev, "Packet not destined to this device\n");
-		return 0;
-	}
-
-	tx_data = kmalloc(sizeof(*tx_data), GFP_ATOMIC);
-	if (!tx_data) {
-		dev_kfree_skb(skb);
-		netif_wake_queue(ndev);
-		return 0;
-	}
-
-	tx_data->buff = skb->data;
-	tx_data->size = skb->len;
-	tx_data->skb  = skb;
-
-	eth_h = (struct ethhdr *)(skb->data);
-	if (eth_h->h_proto == cpu_to_be16(0x8e88))
-		netdev_dbg(ndev, "EAPOL transmitted\n");
-
-	ih = (struct iphdr *)(skb->data + sizeof(struct ethhdr));
-
-	udp_buf = (char *)ih + sizeof(struct iphdr);
-	if ((udp_buf[1] == 68 && udp_buf[3] == 67) ||
-	    (udp_buf[1] == 67 && udp_buf[3] == 68))
-		netdev_dbg(ndev, "DHCP Message transmitted, type:%x %x %x\n",
-			   udp_buf[248], udp_buf[249], udp_buf[250]);
-
-	vif->netstats.tx_packets++;
-	vif->netstats.tx_bytes += tx_data->size;
-	tx_data->bssid = wilc->vif[vif->idx]->bssid;
-	queue_count = wilc_wlan_txq_add_net_pkt(ndev, (void *)tx_data,
-						tx_data->buff, tx_data->size,
-						linux_wlan_tx_complete);
-
-	if (queue_count > FLOW_CONTROL_UPPER_THRESHOLD) {
-		netif_stop_queue(wilc->vif[0]->ndev);
-		netif_stop_queue(wilc->vif[1]->ndev);
-	}
-
-	return 0;
-}
-
-static int wilc_mac_close(struct net_device *ndev)
-{
-	struct wilc_priv *priv;
-	struct wilc_vif *vif;
-	struct host_if_drv *hif_drv;
-	struct wilc *wl;
-
-	vif = netdev_priv(ndev);
-
-	if (!vif || !vif->ndev || !vif->ndev->ieee80211_ptr ||
-	    !vif->ndev->ieee80211_ptr->wiphy)
-		return 0;
-
-	priv = wiphy_priv(vif->ndev->ieee80211_ptr->wiphy);
-	wl = vif->wilc;
-
-	if (!priv)
-		return 0;
-
-	hif_drv = (struct host_if_drv *)priv->hif_drv;
-
-	netdev_dbg(ndev, "Mac close\n");
-
-	if (!wl)
-		return 0;
-
-	if (!hif_drv)
-		return 0;
-
-	if ((wl->open_ifcs) > 0)
-		wl->open_ifcs--;
-	else
-		return 0;
-
-	if (vif->ndev) {
-		netif_stop_queue(vif->ndev);
-
-		wilc_deinit_host_int(vif->ndev);
-	}
-
-	if (wl->open_ifcs == 0) {
-		netdev_dbg(ndev, "Deinitializing wilc1000\n");
-		wl->close = 1;
-		wilc1000_wlan_deinit(ndev);
-		WILC_WFI_deinit_mon_interface();
-	}
-
-	vif->mac_opened = 0;
-
-	return 0;
-}
-
-static int mac_ioctl(struct net_device *ndev, struct ifreq *req, int cmd)
-{
-	u8 *buff = NULL;
-	s8 rssi;
-	u32 size = 0;
-	struct wilc_vif *vif;
-	s32 ret = 0;
-	struct wilc *wilc;
-
-	vif = netdev_priv(ndev);
-	wilc = vif->wilc;
-
-	if (!wilc->initialized)
-		return 0;
-
-	switch (cmd) {
-	case SIOCSIWPRIV:
-	{
-		struct iwreq *wrq = (struct iwreq *)req;
-
-		size = wrq->u.data.length;
-
-		if (size && wrq->u.data.pointer) {
-			buff = memdup_user(wrq->u.data.pointer,
-					   wrq->u.data.length);
-			if (IS_ERR(buff))
-				return PTR_ERR(buff);
-
-			if (strncasecmp(buff, "RSSI", size) == 0) {
-				ret = wilc_get_rssi(vif, &rssi);
-				netdev_info(ndev, "RSSI :%d\n", rssi);
-
-				rssi += 5;
-
-				snprintf(buff, size, "rssi %d", rssi);
-
-				if (copy_to_user(wrq->u.data.pointer, buff, size)) {
-					netdev_err(ndev, "failed to copy\n");
-					ret = -EFAULT;
-					goto done;
-				}
-			}
-		}
-	}
-	break;
-
-	default:
-	{
-		netdev_info(ndev, "Command - %d - has been received\n", cmd);
-		ret = -EOPNOTSUPP;
-		goto done;
-	}
-	}
-
-done:
-
-	kfree(buff);
-
-	return ret;
-}
-
-void wilc_frmw_to_linux(struct wilc *wilc, u8 *buff, u32 size, u32 pkt_offset)
-{
-	unsigned int frame_len = 0;
-	int stats;
-	unsigned char *buff_to_send = NULL;
-	struct sk_buff *skb;
-	struct net_device *wilc_netdev;
-	struct wilc_vif *vif;
-
-	if (!wilc)
-		return;
-
-	wilc_netdev = get_if_handler(wilc, buff);
-	if (!wilc_netdev)
-		return;
-
-	buff += pkt_offset;
-	vif = netdev_priv(wilc_netdev);
-
-	if (size > 0) {
-		frame_len = size;
-		buff_to_send = buff;
-
-		skb = dev_alloc_skb(frame_len);
-		if (!skb)
-			return;
-
-		skb->dev = wilc_netdev;
-
-		skb_put_data(skb, buff_to_send, frame_len);
-
-		skb->protocol = eth_type_trans(skb, wilc_netdev);
-		vif->netstats.rx_packets++;
-		vif->netstats.rx_bytes += frame_len;
-		skb->ip_summed = CHECKSUM_UNNECESSARY;
-		stats = netif_rx(skb);
-		netdev_dbg(wilc_netdev, "netif_rx ret value is: %d\n", stats);
-	}
-}
-
-void WILC_WFI_mgmt_rx(struct wilc *wilc, u8 *buff, u32 size)
-{
-	int i = 0;
-	struct wilc_vif *vif;
-
-	for (i = 0; i < wilc->vif_num; i++) {
-		vif = netdev_priv(wilc->vif[i]->ndev);
-		if (vif->monitor_flag) {
-			WILC_WFI_monitor_rx(buff, size);
-			return;
-		}
-	}
-
-	vif = netdev_priv(wilc->vif[1]->ndev);
-	if ((buff[0] == vif->frame_reg[0].type && vif->frame_reg[0].reg) ||
-	    (buff[0] == vif->frame_reg[1].type && vif->frame_reg[1].reg))
-		WILC_WFI_p2p_rx(wilc->vif[1]->ndev, buff, size);
-}
-
-void wilc_netdev_cleanup(struct wilc *wilc)
-{
-	int i;
-
-	if (wilc && (wilc->vif[0]->ndev || wilc->vif[1]->ndev))
-		unregister_inetaddr_notifier(&g_dev_notifier);
-
-	if (wilc && wilc->firmware) {
-		release_firmware(wilc->firmware);
-		wilc->firmware = NULL;
-	}
-
-	if (wilc && (wilc->vif[0]->ndev || wilc->vif[1]->ndev)) {
-		for (i = 0; i < NUM_CONCURRENT_IFC; i++)
-			if (wilc->vif[i]->ndev)
-				if (wilc->vif[i]->mac_opened)
-					wilc_mac_close(wilc->vif[i]->ndev);
-
-		for (i = 0; i < NUM_CONCURRENT_IFC; i++) {
-			unregister_netdev(wilc->vif[i]->ndev);
-			wilc_free_wiphy(wilc->vif[i]->ndev);
-			free_netdev(wilc->vif[i]->ndev);
-		}
-	}
-
-	kfree(wilc);
-}
-EXPORT_SYMBOL_GPL(wilc_netdev_cleanup);
-
-int wilc_netdev_init(struct wilc **wilc, struct device *dev, int io_type,
-		     int gpio, const struct wilc_hif_func *ops)
-{
-	int i, ret;
-	struct wilc_vif *vif;
-	struct net_device *ndev;
-	struct wilc *wl;
-
-	wl = kzalloc(sizeof(*wl), GFP_KERNEL);
-	if (!wl)
-		return -ENOMEM;
-
-	*wilc = wl;
-	wl->io_type = io_type;
-	wl->gpio = gpio;
-	wl->hif_func = ops;
-
-	register_inetaddr_notifier(&g_dev_notifier);
-
-	for (i = 0; i < NUM_CONCURRENT_IFC; i++) {
-		ndev = alloc_etherdev(sizeof(struct wilc_vif));
-		if (!ndev)
-			return -ENOMEM;
-
-		vif = netdev_priv(ndev);
-		memset(vif, 0, sizeof(struct wilc_vif));
-
-		if (i == 0) {
-			strcpy(ndev->name, "wlan%d");
-			vif->ifc_id = 1;
-		} else {
-			strcpy(ndev->name, "p2p%d");
-			vif->ifc_id = 0;
-		}
-		vif->wilc = *wilc;
-		vif->ndev = ndev;
-		wl->vif[i] = vif;
-		wl->vif_num = i;
-		vif->idx = wl->vif_num;
-
-		ndev->netdev_ops = &wilc_netdev_ops;
-
-		{
-			struct wireless_dev *wdev;
-
-			wdev = wilc_create_wiphy(ndev, dev);
-
-			if (dev)
-				SET_NETDEV_DEV(ndev, dev);
-
-			if (!wdev) {
-				netdev_err(ndev, "Can't register WILC Wiphy\n");
-				return -1;
-			}
-
-			vif->ndev->ieee80211_ptr = wdev;
-			vif->ndev->ml_priv = vif;
-			wdev->netdev = vif->ndev;
-			vif->netstats.rx_packets = 0;
-			vif->netstats.tx_packets = 0;
-			vif->netstats.rx_bytes = 0;
-			vif->netstats.tx_bytes = 0;
-		}
-
-		ret = register_netdev(ndev);
-		if (ret)
-			return ret;
-
-		vif->iftype = STATION_MODE;
-		vif->mac_opened = 0;
-	}
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(wilc_netdev_init);
-
-MODULE_LICENSE("GPL");
diff --git a/drivers/staging/wilc1000/wilc_wfi_cfgoperations.c b/drivers/staging/wilc1000/wilc_wfi_cfgoperations.c
deleted file mode 100644
index af12925..0000000
--- a/drivers/staging/wilc1000/wilc_wfi_cfgoperations.c
+++ /dev/null
@@ -1,2343 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-#include "wilc_wfi_cfgoperations.h"
-#include "host_interface.h"
-#include <linux/errno.h>
-
-#define NO_ENCRYPT		0
-#define ENCRYPT_ENABLED		BIT(0)
-#define WEP			BIT(1)
-#define WEP_EXTENDED		BIT(2)
-#define WPA			BIT(3)
-#define WPA2			BIT(4)
-#define AES			BIT(5)
-#define TKIP			BIT(6)
-
-#define FRAME_TYPE_ID			0
-#define ACTION_CAT_ID			24
-#define ACTION_SUBTYPE_ID		25
-#define P2P_PUB_ACTION_SUBTYPE		30
-
-#define ACTION_FRAME			0xd0
-#define GO_INTENT_ATTR_ID		0x04
-#define CHANLIST_ATTR_ID		0x0b
-#define OPERCHAN_ATTR_ID		0x11
-#define PUB_ACTION_ATTR_ID		0x04
-#define P2PELEM_ATTR_ID			0xdd
-
-#define GO_NEG_REQ			0x00
-#define GO_NEG_RSP			0x01
-#define GO_NEG_CONF			0x02
-#define P2P_INV_REQ			0x03
-#define P2P_INV_RSP			0x04
-#define PUBLIC_ACT_VENDORSPEC		0x09
-#define GAS_INITIAL_REQ			0x0a
-#define GAS_INITIAL_RSP			0x0b
-
-#define INVALID_CHANNEL			0
-
-#define nl80211_SCAN_RESULT_EXPIRE	(3 * HZ)
-#define SCAN_RESULT_EXPIRE		(40 * HZ)
-
-static const u32 cipher_suites[] = {
-	WLAN_CIPHER_SUITE_WEP40,
-	WLAN_CIPHER_SUITE_WEP104,
-	WLAN_CIPHER_SUITE_TKIP,
-	WLAN_CIPHER_SUITE_CCMP,
-	WLAN_CIPHER_SUITE_AES_CMAC,
-};
-
-static const struct ieee80211_txrx_stypes
-	wilc_wfi_cfg80211_mgmt_types[NUM_NL80211_IFTYPES] = {
-	[NL80211_IFTYPE_STATION] = {
-		.tx = 0xffff,
-		.rx = BIT(IEEE80211_STYPE_ACTION >> 4) |
-			BIT(IEEE80211_STYPE_PROBE_REQ >> 4)
-	},
-	[NL80211_IFTYPE_AP] = {
-		.tx = 0xffff,
-		.rx = BIT(IEEE80211_STYPE_ASSOC_REQ >> 4) |
-			BIT(IEEE80211_STYPE_REASSOC_REQ >> 4) |
-			BIT(IEEE80211_STYPE_PROBE_REQ >> 4) |
-			BIT(IEEE80211_STYPE_DISASSOC >> 4) |
-			BIT(IEEE80211_STYPE_AUTH >> 4) |
-			BIT(IEEE80211_STYPE_DEAUTH >> 4) |
-			BIT(IEEE80211_STYPE_ACTION >> 4)
-	},
-	[NL80211_IFTYPE_P2P_CLIENT] = {
-		.tx = 0xffff,
-		.rx = BIT(IEEE80211_STYPE_ACTION >> 4) |
-			BIT(IEEE80211_STYPE_PROBE_REQ >> 4) |
-			BIT(IEEE80211_STYPE_ASSOC_REQ >> 4) |
-			BIT(IEEE80211_STYPE_REASSOC_REQ >> 4) |
-			BIT(IEEE80211_STYPE_DISASSOC >> 4) |
-			BIT(IEEE80211_STYPE_AUTH >> 4) |
-			BIT(IEEE80211_STYPE_DEAUTH >> 4)
-	}
-};
-
-static const struct wiphy_wowlan_support wowlan_support = {
-	.flags = WIPHY_WOWLAN_ANY
-};
-
-#define WILC_WFI_DWELL_PASSIVE 100
-#define WILC_WFI_DWELL_ACTIVE  40
-
-#define TCP_ACK_FILTER_LINK_SPEED_THRESH	54
-#define DEFAULT_LINK_SPEED			72
-
-#define IS_MANAGMEMENT				0x100
-#define IS_MANAGMEMENT_CALLBACK			0x080
-#define IS_MGMT_STATUS_SUCCES			0x040
-#define GET_PKT_OFFSET(a) (((a) >> 22) & 0x1ff)
-
-static struct network_info last_scanned_shadow[MAX_NUM_SCANNED_NETWORKS_SHADOW];
-static u32 last_scanned_cnt;
-struct timer_list wilc_during_ip_timer;
-static struct timer_list hAgingTimer;
-static u8 op_ifcs;
-
-#define CHAN2G(_channel, _freq, _flags) {	 \
-		.band             = NL80211_BAND_2GHZ, \
-		.center_freq      = (_freq),		 \
-		.hw_value         = (_channel),		 \
-		.flags            = (_flags),		 \
-		.max_antenna_gain = 0,			 \
-		.max_power        = 30,			 \
-}
-
-static struct ieee80211_channel ieee80211_2ghz_channels[] = {
-	CHAN2G(1,  2412, 0),
-	CHAN2G(2,  2417, 0),
-	CHAN2G(3,  2422, 0),
-	CHAN2G(4,  2427, 0),
-	CHAN2G(5,  2432, 0),
-	CHAN2G(6,  2437, 0),
-	CHAN2G(7,  2442, 0),
-	CHAN2G(8,  2447, 0),
-	CHAN2G(9,  2452, 0),
-	CHAN2G(10, 2457, 0),
-	CHAN2G(11, 2462, 0),
-	CHAN2G(12, 2467, 0),
-	CHAN2G(13, 2472, 0),
-	CHAN2G(14, 2484, 0),
-};
-
-#define RATETAB_ENT(_rate, _hw_value, _flags) {	\
-		.bitrate  = (_rate),			\
-		.hw_value = (_hw_value),		\
-		.flags    = (_flags),			\
-}
-
-static struct ieee80211_rate ieee80211_bitrates[] = {
-	RATETAB_ENT(10,  0,  0),
-	RATETAB_ENT(20,  1,  0),
-	RATETAB_ENT(55,  2,  0),
-	RATETAB_ENT(110, 3,  0),
-	RATETAB_ENT(60,  9,  0),
-	RATETAB_ENT(90,  6,  0),
-	RATETAB_ENT(120, 7,  0),
-	RATETAB_ENT(180, 8,  0),
-	RATETAB_ENT(240, 9,  0),
-	RATETAB_ENT(360, 10, 0),
-	RATETAB_ENT(480, 11, 0),
-	RATETAB_ENT(540, 12, 0),
-};
-
-struct p2p_mgmt_data {
-	int size;
-	u8 *buff;
-};
-
-static u8 wlan_channel = INVALID_CHANNEL;
-static u8 curr_channel;
-static u8 p2p_oui[] = {0x50, 0x6f, 0x9A, 0x09};
-static u8 p2p_local_random = 0x01;
-static u8 p2p_recv_random;
-static u8 p2p_vendor_spec[] = {0xdd, 0x05, 0x00, 0x08, 0x40, 0x03};
-static bool wilc_ie;
-
-static struct ieee80211_supported_band WILC_WFI_band_2ghz = {
-	.channels = ieee80211_2ghz_channels,
-	.n_channels = ARRAY_SIZE(ieee80211_2ghz_channels),
-	.bitrates = ieee80211_bitrates,
-	.n_bitrates = ARRAY_SIZE(ieee80211_bitrates),
-};
-
-struct add_key_params {
-	u8 key_idx;
-	bool pairwise;
-	u8 *mac_addr;
-};
-
-static struct add_key_params g_add_gtk_key_params;
-static struct wilc_wfi_key g_key_gtk_params;
-static struct add_key_params g_add_ptk_key_params;
-static struct wilc_wfi_key g_key_ptk_params;
-static struct wilc_wfi_wep_key g_key_wep_params;
-static bool g_ptk_keys_saved;
-static bool g_gtk_keys_saved;
-static bool g_wep_keys_saved;
-
-#define AGING_TIME	(9 * 1000)
-#define during_ip_time	15000
-
-static void clear_shadow_scan(void)
-{
-	int i;
-
-	if (op_ifcs == 0) {
-		del_timer_sync(&hAgingTimer);
-
-		for (i = 0; i < last_scanned_cnt; i++) {
-			if (last_scanned_shadow[last_scanned_cnt].ies) {
-				kfree(last_scanned_shadow[i].ies);
-				last_scanned_shadow[last_scanned_cnt].ies = NULL;
-			}
-
-			kfree(last_scanned_shadow[i].join_params);
-			last_scanned_shadow[i].join_params = NULL;
-		}
-		last_scanned_cnt = 0;
-	}
-}
-
-static u32 get_rssi_avg(struct network_info *network_info)
-{
-	u8 i;
-	int rssi_v = 0;
-	u8 num_rssi = (network_info->rssi_history.full) ?
-		       NUM_RSSI : (network_info->rssi_history.index);
-
-	for (i = 0; i < num_rssi; i++)
-		rssi_v += network_info->rssi_history.samples[i];
-
-	rssi_v /= num_rssi;
-	return rssi_v;
-}
-
-static void refresh_scan(struct wilc_priv *priv, bool direct_scan)
-{
-	struct wiphy *wiphy = priv->dev->ieee80211_ptr->wiphy;
-	int i;
-
-	for (i = 0; i < last_scanned_cnt; i++) {
-		struct network_info *network_info;
-		s32 freq;
-		struct ieee80211_channel *channel;
-		int rssi;
-		struct cfg80211_bss *bss;
-
-		network_info = &last_scanned_shadow[i];
-
-		if (!memcmp("DIRECT-", network_info->ssid, 7) && !direct_scan)
-			continue;
-
-		freq = ieee80211_channel_to_frequency((s32)network_info->ch,
-						      NL80211_BAND_2GHZ);
-		channel = ieee80211_get_channel(wiphy, freq);
-		rssi = get_rssi_avg(network_info);
-		bss = cfg80211_inform_bss(wiphy,
-					  channel,
-					  CFG80211_BSS_FTYPE_UNKNOWN,
-					  network_info->bssid,
-					  network_info->tsf_hi,
-					  network_info->cap_info,
-					  network_info->beacon_period,
-					  (const u8 *)network_info->ies,
-					  (size_t)network_info->ies_len,
-					  (s32)rssi * 100,
-					  GFP_KERNEL);
-		cfg80211_put_bss(wiphy, bss);
-	}
-}
-
-static void reset_shadow_found(void)
-{
-	int i;
-
-	for (i = 0; i < last_scanned_cnt; i++)
-		last_scanned_shadow[i].found = 0;
-}
-
-static void update_scan_time(void)
-{
-	int i;
-
-	for (i = 0; i < last_scanned_cnt; i++)
-		last_scanned_shadow[i].time_scan = jiffies;
-}
-
-static void remove_network_from_shadow(unsigned long arg)
-{
-	unsigned long now = jiffies;
-	int i, j;
-
-	for (i = 0; i < last_scanned_cnt; i++) {
-		if (time_after(now, last_scanned_shadow[i].time_scan +
-			       (unsigned long)(SCAN_RESULT_EXPIRE))) {
-			kfree(last_scanned_shadow[i].ies);
-			last_scanned_shadow[i].ies = NULL;
-
-			kfree(last_scanned_shadow[i].join_params);
-
-			for (j = i; (j < last_scanned_cnt - 1); j++)
-				last_scanned_shadow[j] = last_scanned_shadow[j + 1];
-
-			last_scanned_cnt--;
-		}
-	}
-
-	if (last_scanned_cnt != 0) {
-		hAgingTimer.data = arg;
-		mod_timer(&hAgingTimer, jiffies + msecs_to_jiffies(AGING_TIME));
-	}
-}
-
-static void clear_duringIP(unsigned long arg)
-{
-	wilc_optaining_ip = false;
-}
-
-static int is_network_in_shadow(struct network_info *pstrNetworkInfo,
-				void *user_void)
-{
-	int state = -1;
-	int i;
-
-	if (last_scanned_cnt == 0) {
-		hAgingTimer.data = (unsigned long)user_void;
-		mod_timer(&hAgingTimer, jiffies + msecs_to_jiffies(AGING_TIME));
-		state = -1;
-	} else {
-		for (i = 0; i < last_scanned_cnt; i++) {
-			if (memcmp(last_scanned_shadow[i].bssid,
-				   pstrNetworkInfo->bssid, 6) == 0) {
-				state = i;
-				break;
-			}
-		}
-	}
-	return state;
-}
-
-static void add_network_to_shadow(struct network_info *pstrNetworkInfo,
-				  void *user_void, void *pJoinParams)
-{
-	int ap_found = is_network_in_shadow(pstrNetworkInfo, user_void);
-	u32 ap_index = 0;
-	u8 rssi_index = 0;
-
-	if (last_scanned_cnt >= MAX_NUM_SCANNED_NETWORKS_SHADOW)
-		return;
-
-	if (ap_found == -1) {
-		ap_index = last_scanned_cnt;
-		last_scanned_cnt++;
-	} else {
-		ap_index = ap_found;
-	}
-	rssi_index = last_scanned_shadow[ap_index].rssi_history.index;
-	last_scanned_shadow[ap_index].rssi_history.samples[rssi_index++] = pstrNetworkInfo->rssi;
-	if (rssi_index == NUM_RSSI) {
-		rssi_index = 0;
-		last_scanned_shadow[ap_index].rssi_history.full = true;
-	}
-	last_scanned_shadow[ap_index].rssi_history.index = rssi_index;
-	last_scanned_shadow[ap_index].rssi = pstrNetworkInfo->rssi;
-	last_scanned_shadow[ap_index].cap_info = pstrNetworkInfo->cap_info;
-	last_scanned_shadow[ap_index].ssid_len = pstrNetworkInfo->ssid_len;
-	memcpy(last_scanned_shadow[ap_index].ssid,
-	       pstrNetworkInfo->ssid, pstrNetworkInfo->ssid_len);
-	memcpy(last_scanned_shadow[ap_index].bssid,
-	       pstrNetworkInfo->bssid, ETH_ALEN);
-	last_scanned_shadow[ap_index].beacon_period = pstrNetworkInfo->beacon_period;
-	last_scanned_shadow[ap_index].dtim_period = pstrNetworkInfo->dtim_period;
-	last_scanned_shadow[ap_index].ch = pstrNetworkInfo->ch;
-	last_scanned_shadow[ap_index].ies_len = pstrNetworkInfo->ies_len;
-	last_scanned_shadow[ap_index].tsf_hi = pstrNetworkInfo->tsf_hi;
-	if (ap_found != -1)
-		kfree(last_scanned_shadow[ap_index].ies);
-	last_scanned_shadow[ap_index].ies = kmalloc(pstrNetworkInfo->ies_len,
-						    GFP_KERNEL);
-	memcpy(last_scanned_shadow[ap_index].ies,
-	       pstrNetworkInfo->ies, pstrNetworkInfo->ies_len);
-	last_scanned_shadow[ap_index].time_scan = jiffies;
-	last_scanned_shadow[ap_index].time_scan_cached = jiffies;
-	last_scanned_shadow[ap_index].found = 1;
-	if (ap_found != -1)
-		kfree(last_scanned_shadow[ap_index].join_params);
-	last_scanned_shadow[ap_index].join_params = pJoinParams;
-}
-
-static void CfgScanResult(enum scan_event scan_event,
-			  struct network_info *network_info,
-			  void *user_void,
-			  void *join_params)
-{
-	struct wilc_priv *priv;
-	struct wiphy *wiphy;
-	s32 s32Freq;
-	struct ieee80211_channel *channel;
-	struct cfg80211_bss *bss = NULL;
-
-	priv = user_void;
-	if (priv->bCfgScanning) {
-		if (scan_event == SCAN_EVENT_NETWORK_FOUND) {
-			wiphy = priv->dev->ieee80211_ptr->wiphy;
-
-			if (!wiphy)
-				return;
-
-			if (wiphy->signal_type == CFG80211_SIGNAL_TYPE_UNSPEC &&
-			    (((s32)network_info->rssi * 100) < 0 ||
-			    ((s32)network_info->rssi * 100) > 100))
-				return;
-
-			if (network_info) {
-				s32Freq = ieee80211_channel_to_frequency((s32)network_info->ch, NL80211_BAND_2GHZ);
-				channel = ieee80211_get_channel(wiphy, s32Freq);
-
-				if (!channel)
-					return;
-
-				if (network_info->new_network) {
-					if (priv->u32RcvdChCount < MAX_NUM_SCANNED_NETWORKS) {
-						priv->u32RcvdChCount++;
-
-						add_network_to_shadow(network_info, priv, join_params);
-
-						if (!(memcmp("DIRECT-", network_info->ssid, 7))) {
-							bss = cfg80211_inform_bss(wiphy,
-										  channel,
-										  CFG80211_BSS_FTYPE_UNKNOWN,
-										  network_info->bssid,
-										  network_info->tsf_hi,
-										  network_info->cap_info,
-										  network_info->beacon_period,
-										  (const u8 *)network_info->ies,
-										  (size_t)network_info->ies_len,
-										  (s32)network_info->rssi * 100,
-										  GFP_KERNEL);
-							cfg80211_put_bss(wiphy, bss);
-						}
-					}
-				} else {
-					u32 i;
-
-					for (i = 0; i < priv->u32RcvdChCount; i++) {
-						if (memcmp(last_scanned_shadow[i].bssid, network_info->bssid, 6) == 0) {
-							last_scanned_shadow[i].rssi = network_info->rssi;
-							last_scanned_shadow[i].time_scan = jiffies;
-							break;
-						}
-					}
-				}
-			}
-		} else if (scan_event == SCAN_EVENT_DONE) {
-			refresh_scan(priv, false);
-
-			mutex_lock(&priv->scan_req_lock);
-
-			if (priv->pstrScanReq) {
-				struct cfg80211_scan_info info = {
-					.aborted = false,
-				};
-
-				cfg80211_scan_done(priv->pstrScanReq, &info);
-				priv->u32RcvdChCount = 0;
-				priv->bCfgScanning = false;
-				priv->pstrScanReq = NULL;
-			}
-			mutex_unlock(&priv->scan_req_lock);
-		} else if (scan_event == SCAN_EVENT_ABORTED) {
-			mutex_lock(&priv->scan_req_lock);
-
-			if (priv->pstrScanReq) {
-				struct cfg80211_scan_info info = {
-					.aborted = false,
-				};
-
-				update_scan_time();
-				refresh_scan(priv, false);
-
-				cfg80211_scan_done(priv->pstrScanReq, &info);
-				priv->bCfgScanning = false;
-				priv->pstrScanReq = NULL;
-			}
-			mutex_unlock(&priv->scan_req_lock);
-		}
-	}
-}
-
-int wilc_connecting;
-
-static void CfgConnectResult(enum conn_event enuConnDisconnEvent,
-			     struct connect_info *pstrConnectInfo,
-			     u8 u8MacStatus,
-			     struct disconnect_info *pstrDisconnectNotifInfo,
-			     void *pUserVoid)
-{
-	struct wilc_priv *priv;
-	struct net_device *dev;
-	struct host_if_drv *pstrWFIDrv;
-	u8 NullBssid[ETH_ALEN] = {0};
-	struct wilc *wl;
-	struct wilc_vif *vif;
-
-	wilc_connecting = 0;
-
-	priv = pUserVoid;
-	dev = priv->dev;
-	vif = netdev_priv(dev);
-	wl = vif->wilc;
-	pstrWFIDrv = (struct host_if_drv *)priv->hif_drv;
-
-	if (enuConnDisconnEvent == CONN_DISCONN_EVENT_CONN_RESP) {
-		u16 u16ConnectStatus;
-
-		u16ConnectStatus = pstrConnectInfo->status;
-
-		if ((u8MacStatus == MAC_DISCONNECTED) &&
-		    (pstrConnectInfo->status == SUCCESSFUL_STATUSCODE)) {
-			u16ConnectStatus = WLAN_STATUS_UNSPECIFIED_FAILURE;
-			wilc_wlan_set_bssid(priv->dev, NullBssid,
-					    STATION_MODE);
-			eth_zero_addr(wilc_connected_ssid);
-
-			if (!pstrWFIDrv->p2p_connect)
-				wlan_channel = INVALID_CHANNEL;
-
-			netdev_err(dev, "Unspecified failure\n");
-		}
-
-		if (u16ConnectStatus == WLAN_STATUS_SUCCESS) {
-			bool bNeedScanRefresh = false;
-			u32 i;
-
-			memcpy(priv->au8AssociatedBss, pstrConnectInfo->bssid, ETH_ALEN);
-
-			for (i = 0; i < last_scanned_cnt; i++) {
-				if (memcmp(last_scanned_shadow[i].bssid,
-					   pstrConnectInfo->bssid,
-					   ETH_ALEN) == 0) {
-					unsigned long now = jiffies;
-
-					if (time_after(now,
-						       last_scanned_shadow[i].time_scan_cached +
-						       (unsigned long)(nl80211_SCAN_RESULT_EXPIRE - (1 * HZ))))
-						bNeedScanRefresh = true;
-
-					break;
-				}
-			}
-
-			if (bNeedScanRefresh)
-				refresh_scan(priv, true);
-		}
-
-		cfg80211_connect_result(dev, pstrConnectInfo->bssid,
-					pstrConnectInfo->req_ies, pstrConnectInfo->req_ies_len,
-					pstrConnectInfo->resp_ies, pstrConnectInfo->resp_ies_len,
-					u16ConnectStatus, GFP_KERNEL);
-	} else if (enuConnDisconnEvent == CONN_DISCONN_EVENT_DISCONN_NOTIF)    {
-		wilc_optaining_ip = false;
-		p2p_local_random = 0x01;
-		p2p_recv_random = 0x00;
-		wilc_ie = false;
-		eth_zero_addr(priv->au8AssociatedBss);
-		wilc_wlan_set_bssid(priv->dev, NullBssid, STATION_MODE);
-		eth_zero_addr(wilc_connected_ssid);
-
-		if (!pstrWFIDrv->p2p_connect)
-			wlan_channel = INVALID_CHANNEL;
-		if ((pstrWFIDrv->IFC_UP) && (dev == wl->vif[1]->ndev))
-			pstrDisconnectNotifInfo->reason = 3;
-		else if ((!pstrWFIDrv->IFC_UP) && (dev == wl->vif[1]->ndev))
-			pstrDisconnectNotifInfo->reason = 1;
-
-		cfg80211_disconnected(dev, pstrDisconnectNotifInfo->reason, pstrDisconnectNotifInfo->ie,
-				      pstrDisconnectNotifInfo->ie_len, false,
-				      GFP_KERNEL);
-	}
-}
-
-static int set_channel(struct wiphy *wiphy,
-		       struct cfg80211_chan_def *chandef)
-{
-	u32 channelnum = 0;
-	struct wilc_priv *priv;
-	int result = 0;
-	struct wilc_vif *vif;
-
-	priv = wiphy_priv(wiphy);
-	vif = netdev_priv(priv->dev);
-
-	channelnum = ieee80211_frequency_to_channel(chandef->chan->center_freq);
-
-	curr_channel = channelnum;
-	result = wilc_set_mac_chnl_num(vif, channelnum);
-
-	if (result != 0)
-		netdev_err(priv->dev, "Error in setting channel\n");
-
-	return result;
-}
-
-static int scan(struct wiphy *wiphy, struct cfg80211_scan_request *request)
-{
-	struct wilc_priv *priv;
-	u32 i;
-	s32 s32Error = 0;
-	u8 au8ScanChanList[MAX_NUM_SCANNED_NETWORKS];
-	struct hidden_network strHiddenNetwork;
-	struct wilc_vif *vif;
-
-	priv = wiphy_priv(wiphy);
-	vif = netdev_priv(priv->dev);
-
-	priv->pstrScanReq = request;
-
-	priv->u32RcvdChCount = 0;
-
-	reset_shadow_found();
-
-	priv->bCfgScanning = true;
-	if (request->n_channels <= MAX_NUM_SCANNED_NETWORKS) {
-		for (i = 0; i < request->n_channels; i++)
-			au8ScanChanList[i] = (u8)ieee80211_frequency_to_channel(request->channels[i]->center_freq);
-
-		if (request->n_ssids >= 1) {
-			strHiddenNetwork.net_info =
-				kmalloc_array(request->n_ssids,
-					      sizeof(struct hidden_network),
-					      GFP_KERNEL);
-			if (!strHiddenNetwork.net_info)
-				return -ENOMEM;
-			strHiddenNetwork.n_ssids = request->n_ssids;
-
-			for (i = 0; i < request->n_ssids; i++) {
-				if (request->ssids[i].ssid_len != 0) {
-					strHiddenNetwork.net_info[i].ssid = kmalloc(request->ssids[i].ssid_len, GFP_KERNEL);
-					memcpy(strHiddenNetwork.net_info[i].ssid, request->ssids[i].ssid, request->ssids[i].ssid_len);
-					strHiddenNetwork.net_info[i].ssid_len = request->ssids[i].ssid_len;
-				} else {
-					strHiddenNetwork.n_ssids -= 1;
-				}
-			}
-			s32Error = wilc_scan(vif, USER_SCAN, ACTIVE_SCAN,
-					     au8ScanChanList,
-					     request->n_channels,
-					     (const u8 *)request->ie,
-					     request->ie_len, CfgScanResult,
-					     (void *)priv, &strHiddenNetwork);
-		} else {
-			s32Error = wilc_scan(vif, USER_SCAN, ACTIVE_SCAN,
-					     au8ScanChanList,
-					     request->n_channels,
-					     (const u8 *)request->ie,
-					     request->ie_len, CfgScanResult,
-					     (void *)priv, NULL);
-		}
-	} else {
-		netdev_err(priv->dev, "Requested scanned channels over\n");
-	}
-
-	if (s32Error != 0)
-		s32Error = -EBUSY;
-
-	return s32Error;
-}
-
-static int connect(struct wiphy *wiphy, struct net_device *dev,
-		   struct cfg80211_connect_params *sme)
-{
-	s32 s32Error = 0;
-	u32 i;
-	u32 sel_bssi_idx = UINT_MAX;
-	u8 u8security = NO_ENCRYPT;
-	enum AUTHTYPE tenuAuth_type = ANY;
-
-	struct wilc_priv *priv;
-	struct host_if_drv *pstrWFIDrv;
-	struct network_info *pstrNetworkInfo = NULL;
-	struct wilc_vif *vif;
-
-	wilc_connecting = 1;
-	priv = wiphy_priv(wiphy);
-	vif = netdev_priv(priv->dev);
-	pstrWFIDrv = (struct host_if_drv *)priv->hif_drv;
-
-	if (!(strncmp(sme->ssid, "DIRECT-", 7)))
-		pstrWFIDrv->p2p_connect = 1;
-	else
-		pstrWFIDrv->p2p_connect = 0;
-
-	for (i = 0; i < last_scanned_cnt; i++) {
-		if ((sme->ssid_len == last_scanned_shadow[i].ssid_len) &&
-		    memcmp(last_scanned_shadow[i].ssid,
-			   sme->ssid,
-			   sme->ssid_len) == 0) {
-			if (!sme->bssid) {
-				if (sel_bssi_idx == UINT_MAX ||
-				    last_scanned_shadow[i].rssi >
-				    last_scanned_shadow[sel_bssi_idx].rssi)
-					sel_bssi_idx = i;
-			} else {
-				if (memcmp(last_scanned_shadow[i].bssid,
-					   sme->bssid,
-					   ETH_ALEN) == 0) {
-					sel_bssi_idx = i;
-					break;
-				}
-			}
-		}
-	}
-
-	if (sel_bssi_idx < last_scanned_cnt) {
-		pstrNetworkInfo = &last_scanned_shadow[sel_bssi_idx];
-	} else {
-		s32Error = -ENOENT;
-		wilc_connecting = 0;
-		return s32Error;
-	}
-
-	memset(priv->WILC_WFI_wep_key, 0, sizeof(priv->WILC_WFI_wep_key));
-	memset(priv->WILC_WFI_wep_key_len, 0, sizeof(priv->WILC_WFI_wep_key_len));
-
-	if (sme->crypto.cipher_group != NO_ENCRYPT) {
-		if (sme->crypto.cipher_group == WLAN_CIPHER_SUITE_WEP40) {
-			u8security = ENCRYPT_ENABLED | WEP;
-
-			priv->WILC_WFI_wep_key_len[sme->key_idx] = sme->key_len;
-			memcpy(priv->WILC_WFI_wep_key[sme->key_idx], sme->key, sme->key_len);
-
-			g_key_wep_params.key_len = sme->key_len;
-			g_key_wep_params.key = kmalloc(sme->key_len, GFP_KERNEL);
-			memcpy(g_key_wep_params.key, sme->key, sme->key_len);
-			g_key_wep_params.key_idx = sme->key_idx;
-			g_wep_keys_saved = true;
-
-			wilc_set_wep_default_keyid(vif, sme->key_idx);
-			wilc_add_wep_key_bss_sta(vif, sme->key, sme->key_len,
-						 sme->key_idx);
-		} else if (sme->crypto.cipher_group == WLAN_CIPHER_SUITE_WEP104)   {
-			u8security = ENCRYPT_ENABLED | WEP | WEP_EXTENDED;
-
-			priv->WILC_WFI_wep_key_len[sme->key_idx] = sme->key_len;
-			memcpy(priv->WILC_WFI_wep_key[sme->key_idx], sme->key, sme->key_len);
-
-			g_key_wep_params.key_len = sme->key_len;
-			g_key_wep_params.key = kmalloc(sme->key_len, GFP_KERNEL);
-			memcpy(g_key_wep_params.key, sme->key, sme->key_len);
-			g_key_wep_params.key_idx = sme->key_idx;
-			g_wep_keys_saved = true;
-
-			wilc_set_wep_default_keyid(vif, sme->key_idx);
-			wilc_add_wep_key_bss_sta(vif, sme->key, sme->key_len,
-						 sme->key_idx);
-		} else if (sme->crypto.wpa_versions & NL80211_WPA_VERSION_2)   {
-			if (sme->crypto.cipher_group == WLAN_CIPHER_SUITE_TKIP)
-				u8security = ENCRYPT_ENABLED | WPA2 | TKIP;
-			else
-				u8security = ENCRYPT_ENABLED | WPA2 | AES;
-		} else if (sme->crypto.wpa_versions & NL80211_WPA_VERSION_1)   {
-			if (sme->crypto.cipher_group == WLAN_CIPHER_SUITE_TKIP)
-				u8security = ENCRYPT_ENABLED | WPA | TKIP;
-			else
-				u8security = ENCRYPT_ENABLED | WPA | AES;
-		} else {
-			s32Error = -ENOTSUPP;
-			netdev_err(dev, "Not supported cipher\n");
-			wilc_connecting = 0;
-			return s32Error;
-		}
-	}
-
-	if ((sme->crypto.wpa_versions & NL80211_WPA_VERSION_1) ||
-	    (sme->crypto.wpa_versions & NL80211_WPA_VERSION_2)) {
-		for (i = 0; i < sme->crypto.n_ciphers_pairwise; i++) {
-			if (sme->crypto.ciphers_pairwise[i] == WLAN_CIPHER_SUITE_TKIP)
-				u8security = u8security | TKIP;
-			else
-				u8security = u8security | AES;
-		}
-	}
-
-	switch (sme->auth_type)	{
-	case NL80211_AUTHTYPE_OPEN_SYSTEM:
-		tenuAuth_type = OPEN_SYSTEM;
-		break;
-
-	case NL80211_AUTHTYPE_SHARED_KEY:
-		tenuAuth_type = SHARED_KEY;
-		break;
-
-	default:
-		break;
-	}
-
-	if (sme->crypto.n_akm_suites) {
-		switch (sme->crypto.akm_suites[0]) {
-		case WLAN_AKM_SUITE_8021X:
-			tenuAuth_type = IEEE8021;
-			break;
-
-		default:
-			break;
-		}
-	}
-
-	curr_channel = pstrNetworkInfo->ch;
-
-	if (!pstrWFIDrv->p2p_connect)
-		wlan_channel = pstrNetworkInfo->ch;
-
-	wilc_wlan_set_bssid(dev, pstrNetworkInfo->bssid, STATION_MODE);
-
-	s32Error = wilc_set_join_req(vif, pstrNetworkInfo->bssid, sme->ssid,
-				     sme->ssid_len, sme->ie, sme->ie_len,
-				     CfgConnectResult, (void *)priv,
-				     u8security, tenuAuth_type,
-				     pstrNetworkInfo->ch,
-				     pstrNetworkInfo->join_params);
-	if (s32Error != 0) {
-		netdev_err(dev, "wilc_set_join_req(): Error\n");
-		s32Error = -ENOENT;
-		wilc_connecting = 0;
-		return s32Error;
-	}
-
-	return s32Error;
-}
-
-static int disconnect(struct wiphy *wiphy, struct net_device *dev, u16 reason_code)
-{
-	s32 s32Error = 0;
-	struct wilc_priv *priv;
-	struct host_if_drv *pstrWFIDrv;
-	struct wilc_vif *vif;
-	struct wilc *wilc;
-	u8 NullBssid[ETH_ALEN] = {0};
-
-	wilc_connecting = 0;
-	priv = wiphy_priv(wiphy);
-	vif = netdev_priv(priv->dev);
-	wilc = vif->wilc;
-
-	if (!wilc)
-		return -EIO;
-
-	if (wilc->close) {
-		/* already disconnected done */
-		cfg80211_disconnected(dev, 0, NULL, 0, true, GFP_KERNEL);
-		return 0;
-	}
-
-	pstrWFIDrv = (struct host_if_drv *)priv->hif_drv;
-	if (!pstrWFIDrv->p2p_connect)
-		wlan_channel = INVALID_CHANNEL;
-	wilc_wlan_set_bssid(priv->dev, NullBssid, STATION_MODE);
-
-	p2p_local_random = 0x01;
-	p2p_recv_random = 0x00;
-	wilc_ie = false;
-	pstrWFIDrv->p2p_timeout = 0;
-
-	s32Error = wilc_disconnect(vif, reason_code);
-	if (s32Error != 0) {
-		netdev_err(priv->dev, "Error in disconnecting\n");
-		s32Error = -EINVAL;
-	}
-
-	return s32Error;
-}
-
-static int add_key(struct wiphy *wiphy, struct net_device *netdev, u8 key_index,
-		   bool pairwise,
-		   const u8 *mac_addr, struct key_params *params)
-
-{
-	s32 s32Error = 0, KeyLen = params->key_len;
-	struct wilc_priv *priv;
-	const u8 *pu8RxMic = NULL;
-	const u8 *pu8TxMic = NULL;
-	u8 u8mode = NO_ENCRYPT;
-	u8 u8gmode = NO_ENCRYPT;
-	u8 u8pmode = NO_ENCRYPT;
-	enum AUTHTYPE tenuAuth_type = ANY;
-	struct wilc *wl;
-	struct wilc_vif *vif;
-
-	priv = wiphy_priv(wiphy);
-	vif = netdev_priv(netdev);
-	wl = vif->wilc;
-
-	switch (params->cipher)	{
-	case WLAN_CIPHER_SUITE_WEP40:
-	case WLAN_CIPHER_SUITE_WEP104:
-		if (priv->wdev->iftype == NL80211_IFTYPE_AP) {
-			priv->WILC_WFI_wep_key_len[key_index] = params->key_len;
-			memcpy(priv->WILC_WFI_wep_key[key_index], params->key, params->key_len);
-
-			tenuAuth_type = OPEN_SYSTEM;
-
-			if (params->cipher == WLAN_CIPHER_SUITE_WEP40)
-				u8mode = ENCRYPT_ENABLED | WEP;
-			else
-				u8mode = ENCRYPT_ENABLED | WEP | WEP_EXTENDED;
-
-			wilc_add_wep_key_bss_ap(vif, params->key,
-						params->key_len, key_index,
-						u8mode, tenuAuth_type);
-			break;
-		}
-		if (memcmp(params->key, priv->WILC_WFI_wep_key[key_index], params->key_len)) {
-			priv->WILC_WFI_wep_key_len[key_index] = params->key_len;
-			memcpy(priv->WILC_WFI_wep_key[key_index], params->key, params->key_len);
-
-			wilc_add_wep_key_bss_sta(vif, params->key,
-						 params->key_len, key_index);
-		}
-
-		break;
-
-	case WLAN_CIPHER_SUITE_TKIP:
-	case WLAN_CIPHER_SUITE_CCMP:
-		if (priv->wdev->iftype == NL80211_IFTYPE_AP || priv->wdev->iftype == NL80211_IFTYPE_P2P_GO) {
-			if (!priv->wilc_gtk[key_index]) {
-				priv->wilc_gtk[key_index] = kmalloc(sizeof(struct wilc_wfi_key), GFP_KERNEL);
-				priv->wilc_gtk[key_index]->key = NULL;
-				priv->wilc_gtk[key_index]->seq = NULL;
-			}
-			if (!priv->wilc_ptk[key_index]) {
-				priv->wilc_ptk[key_index] = kmalloc(sizeof(struct wilc_wfi_key), GFP_KERNEL);
-				priv->wilc_ptk[key_index]->key = NULL;
-				priv->wilc_ptk[key_index]->seq = NULL;
-			}
-
-			if (!pairwise) {
-				if (params->cipher == WLAN_CIPHER_SUITE_TKIP)
-					u8gmode = ENCRYPT_ENABLED | WPA | TKIP;
-				else
-					u8gmode = ENCRYPT_ENABLED | WPA2 | AES;
-
-				priv->wilc_groupkey = u8gmode;
-
-				if (params->key_len > 16 && params->cipher == WLAN_CIPHER_SUITE_TKIP) {
-					pu8TxMic = params->key + 24;
-					pu8RxMic = params->key + 16;
-					KeyLen = params->key_len - 16;
-				}
-				kfree(priv->wilc_gtk[key_index]->key);
-
-				priv->wilc_gtk[key_index]->key = kmalloc(params->key_len, GFP_KERNEL);
-				memcpy(priv->wilc_gtk[key_index]->key, params->key, params->key_len);
-				kfree(priv->wilc_gtk[key_index]->seq);
-
-				if ((params->seq_len) > 0) {
-					priv->wilc_gtk[key_index]->seq = kmalloc(params->seq_len, GFP_KERNEL);
-					memcpy(priv->wilc_gtk[key_index]->seq, params->seq, params->seq_len);
-				}
-
-				priv->wilc_gtk[key_index]->cipher = params->cipher;
-				priv->wilc_gtk[key_index]->key_len = params->key_len;
-				priv->wilc_gtk[key_index]->seq_len = params->seq_len;
-
-				wilc_add_rx_gtk(vif, params->key, KeyLen,
-						key_index, params->seq_len,
-						params->seq, pu8RxMic,
-						pu8TxMic, AP_MODE, u8gmode);
-
-			} else {
-				if (params->cipher == WLAN_CIPHER_SUITE_TKIP)
-					u8pmode = ENCRYPT_ENABLED | WPA | TKIP;
-				else
-					u8pmode = priv->wilc_groupkey | AES;
-
-				if (params->key_len > 16 && params->cipher == WLAN_CIPHER_SUITE_TKIP) {
-					pu8TxMic = params->key + 24;
-					pu8RxMic = params->key + 16;
-					KeyLen = params->key_len - 16;
-				}
-
-				kfree(priv->wilc_ptk[key_index]->key);
-
-				priv->wilc_ptk[key_index]->key = kmalloc(params->key_len, GFP_KERNEL);
-
-				kfree(priv->wilc_ptk[key_index]->seq);
-
-				if ((params->seq_len) > 0)
-					priv->wilc_ptk[key_index]->seq = kmalloc(params->seq_len, GFP_KERNEL);
-
-				memcpy(priv->wilc_ptk[key_index]->key, params->key, params->key_len);
-
-				if ((params->seq_len) > 0)
-					memcpy(priv->wilc_ptk[key_index]->seq, params->seq, params->seq_len);
-
-				priv->wilc_ptk[key_index]->cipher = params->cipher;
-				priv->wilc_ptk[key_index]->key_len = params->key_len;
-				priv->wilc_ptk[key_index]->seq_len = params->seq_len;
-
-				wilc_add_ptk(vif, params->key, KeyLen,
-					     mac_addr, pu8RxMic, pu8TxMic,
-					     AP_MODE, u8pmode, key_index);
-			}
-			break;
-		}
-
-		{
-			u8mode = 0;
-			if (!pairwise) {
-				if (params->key_len > 16 && params->cipher == WLAN_CIPHER_SUITE_TKIP) {
-					pu8RxMic = params->key + 24;
-					pu8TxMic = params->key + 16;
-					KeyLen = params->key_len - 16;
-				}
-
-				if (!g_gtk_keys_saved && netdev == wl->vif[0]->ndev) {
-					g_add_gtk_key_params.key_idx = key_index;
-					g_add_gtk_key_params.pairwise = pairwise;
-					if (!mac_addr) {
-						g_add_gtk_key_params.mac_addr = NULL;
-					} else {
-						g_add_gtk_key_params.mac_addr = kmalloc(ETH_ALEN, GFP_KERNEL);
-						memcpy(g_add_gtk_key_params.mac_addr, mac_addr, ETH_ALEN);
-					}
-					g_key_gtk_params.key_len = params->key_len;
-					g_key_gtk_params.seq_len = params->seq_len;
-					g_key_gtk_params.key =  kmalloc(params->key_len, GFP_KERNEL);
-					memcpy(g_key_gtk_params.key, params->key, params->key_len);
-					if (params->seq_len > 0) {
-						g_key_gtk_params.seq =  kmalloc(params->seq_len, GFP_KERNEL);
-						memcpy(g_key_gtk_params.seq, params->seq, params->seq_len);
-					}
-					g_key_gtk_params.cipher = params->cipher;
-					g_gtk_keys_saved = true;
-				}
-
-				wilc_add_rx_gtk(vif, params->key, KeyLen,
-						key_index, params->seq_len,
-						params->seq, pu8RxMic,
-						pu8TxMic, STATION_MODE,
-						u8mode);
-			} else {
-				if (params->key_len > 16 && params->cipher == WLAN_CIPHER_SUITE_TKIP) {
-					pu8RxMic = params->key + 24;
-					pu8TxMic = params->key + 16;
-					KeyLen = params->key_len - 16;
-				}
-
-				if (!g_ptk_keys_saved && netdev == wl->vif[0]->ndev) {
-					g_add_ptk_key_params.key_idx = key_index;
-					g_add_ptk_key_params.pairwise = pairwise;
-					if (!mac_addr) {
-						g_add_ptk_key_params.mac_addr = NULL;
-					} else {
-						g_add_ptk_key_params.mac_addr = kmalloc(ETH_ALEN, GFP_KERNEL);
-						memcpy(g_add_ptk_key_params.mac_addr, mac_addr, ETH_ALEN);
-					}
-					g_key_ptk_params.key_len = params->key_len;
-					g_key_ptk_params.seq_len = params->seq_len;
-					g_key_ptk_params.key =  kmalloc(params->key_len, GFP_KERNEL);
-					memcpy(g_key_ptk_params.key, params->key, params->key_len);
-					if (params->seq_len > 0) {
-						g_key_ptk_params.seq =  kmalloc(params->seq_len, GFP_KERNEL);
-						memcpy(g_key_ptk_params.seq, params->seq, params->seq_len);
-					}
-					g_key_ptk_params.cipher = params->cipher;
-					g_ptk_keys_saved = true;
-				}
-
-				wilc_add_ptk(vif, params->key, KeyLen,
-					     mac_addr, pu8RxMic, pu8TxMic,
-					     STATION_MODE, u8mode, key_index);
-			}
-		}
-		break;
-
-	default:
-		netdev_err(netdev, "Not supported cipher\n");
-		s32Error = -ENOTSUPP;
-	}
-
-	return s32Error;
-}
-
-static int del_key(struct wiphy *wiphy, struct net_device *netdev,
-		   u8 key_index,
-		   bool pairwise,
-		   const u8 *mac_addr)
-{
-	struct wilc_priv *priv;
-	struct wilc *wl;
-	struct wilc_vif *vif;
-
-	priv = wiphy_priv(wiphy);
-	vif = netdev_priv(netdev);
-	wl = vif->wilc;
-
-	if (netdev == wl->vif[0]->ndev) {
-		g_ptk_keys_saved = false;
-		g_gtk_keys_saved = false;
-		g_wep_keys_saved = false;
-
-		kfree(g_key_wep_params.key);
-		g_key_wep_params.key = NULL;
-
-		if ((priv->wilc_gtk[key_index]) != NULL) {
-			kfree(priv->wilc_gtk[key_index]->key);
-			priv->wilc_gtk[key_index]->key = NULL;
-			kfree(priv->wilc_gtk[key_index]->seq);
-			priv->wilc_gtk[key_index]->seq = NULL;
-
-			kfree(priv->wilc_gtk[key_index]);
-			priv->wilc_gtk[key_index] = NULL;
-		}
-
-		if ((priv->wilc_ptk[key_index]) != NULL) {
-			kfree(priv->wilc_ptk[key_index]->key);
-			priv->wilc_ptk[key_index]->key = NULL;
-			kfree(priv->wilc_ptk[key_index]->seq);
-			priv->wilc_ptk[key_index]->seq = NULL;
-			kfree(priv->wilc_ptk[key_index]);
-			priv->wilc_ptk[key_index] = NULL;
-		}
-
-		kfree(g_key_ptk_params.key);
-		g_key_ptk_params.key = NULL;
-		kfree(g_key_ptk_params.seq);
-		g_key_ptk_params.seq = NULL;
-
-		kfree(g_key_gtk_params.key);
-		g_key_gtk_params.key = NULL;
-		kfree(g_key_gtk_params.seq);
-		g_key_gtk_params.seq = NULL;
-
-	}
-
-	if (key_index >= 0 && key_index <= 3) {
-		if (priv->WILC_WFI_wep_key_len[key_index]) {
-			memset(priv->WILC_WFI_wep_key[key_index], 0,
-			       priv->WILC_WFI_wep_key_len[key_index]);
-			priv->WILC_WFI_wep_key_len[key_index] = 0;
-			wilc_remove_wep_key(vif, key_index);
-		}
-	} else {
-		wilc_remove_key(priv->hif_drv, mac_addr);
-	}
-
-	return 0;
-}
-
-static int get_key(struct wiphy *wiphy, struct net_device *netdev, u8 key_index,
-		   bool pairwise,
-		   const u8 *mac_addr, void *cookie, void (*callback)(void *cookie, struct key_params *))
-{
-	struct wilc_priv *priv;
-	struct  key_params key_params;
-
-	priv = wiphy_priv(wiphy);
-
-	if (!pairwise) {
-		key_params.key = priv->wilc_gtk[key_index]->key;
-		key_params.cipher = priv->wilc_gtk[key_index]->cipher;
-		key_params.key_len = priv->wilc_gtk[key_index]->key_len;
-		key_params.seq = priv->wilc_gtk[key_index]->seq;
-		key_params.seq_len = priv->wilc_gtk[key_index]->seq_len;
-	} else {
-		key_params.key = priv->wilc_ptk[key_index]->key;
-		key_params.cipher = priv->wilc_ptk[key_index]->cipher;
-		key_params.key_len = priv->wilc_ptk[key_index]->key_len;
-		key_params.seq = priv->wilc_ptk[key_index]->seq;
-		key_params.seq_len = priv->wilc_ptk[key_index]->seq_len;
-	}
-
-	callback(cookie, &key_params);
-
-	return 0;
-}
-
-static int set_default_key(struct wiphy *wiphy, struct net_device *netdev, u8 key_index,
-			   bool unicast, bool multicast)
-{
-	struct wilc_priv *priv;
-	struct wilc_vif *vif;
-
-	priv = wiphy_priv(wiphy);
-	vif = netdev_priv(priv->dev);
-
-	wilc_set_wep_default_keyid(vif, key_index);
-
-	return 0;
-}
-
-static int get_station(struct wiphy *wiphy, struct net_device *dev,
-		       const u8 *mac, struct station_info *sinfo)
-{
-	struct wilc_priv *priv;
-	struct wilc_vif *vif;
-	u32 i = 0;
-	u32 associatedsta = ~0;
-	u32 inactive_time = 0;
-
-	priv = wiphy_priv(wiphy);
-	vif = netdev_priv(dev);
-
-	if (vif->iftype == AP_MODE || vif->iftype == GO_MODE) {
-		for (i = 0; i < NUM_STA_ASSOCIATED; i++) {
-			if (!(memcmp(mac, priv->assoc_stainfo.au8Sta_AssociatedBss[i], ETH_ALEN))) {
-				associatedsta = i;
-				break;
-			}
-		}
-
-		if (associatedsta == ~0) {
-			netdev_err(dev, "sta required is not associated\n");
-			return -ENOENT;
-		}
-
-		sinfo->filled |= BIT(NL80211_STA_INFO_INACTIVE_TIME);
-
-		wilc_get_inactive_time(vif, mac, &inactive_time);
-		sinfo->inactive_time = 1000 * inactive_time;
-	}
-
-	if (vif->iftype == STATION_MODE) {
-		struct rf_info strStatistics;
-
-		wilc_get_statistics(vif, &strStatistics);
-
-		sinfo->filled |= BIT(NL80211_STA_INFO_SIGNAL) |
-						BIT(NL80211_STA_INFO_RX_PACKETS) |
-						BIT(NL80211_STA_INFO_TX_PACKETS) |
-						BIT(NL80211_STA_INFO_TX_FAILED) |
-						BIT(NL80211_STA_INFO_TX_BITRATE);
-
-		sinfo->signal = strStatistics.rssi;
-		sinfo->rx_packets = strStatistics.rx_cnt;
-		sinfo->tx_packets = strStatistics.tx_cnt + strStatistics.tx_fail_cnt;
-		sinfo->tx_failed = strStatistics.tx_fail_cnt;
-		sinfo->txrate.legacy = strStatistics.link_speed * 10;
-
-		if ((strStatistics.link_speed > TCP_ACK_FILTER_LINK_SPEED_THRESH) &&
-		    (strStatistics.link_speed != DEFAULT_LINK_SPEED))
-			wilc_enable_tcp_ack_filter(true);
-		else if (strStatistics.link_speed != DEFAULT_LINK_SPEED)
-			wilc_enable_tcp_ack_filter(false);
-	}
-	return 0;
-}
-
-static int change_bss(struct wiphy *wiphy, struct net_device *dev,
-		      struct bss_parameters *params)
-{
-	return 0;
-}
-
-static int set_wiphy_params(struct wiphy *wiphy, u32 changed)
-{
-	s32 s32Error = 0;
-	struct cfg_param_attr pstrCfgParamVal;
-	struct wilc_priv *priv;
-	struct wilc_vif *vif;
-
-	priv = wiphy_priv(wiphy);
-	vif = netdev_priv(priv->dev);
-
-	pstrCfgParamVal.flag = 0;
-
-	if (changed & WIPHY_PARAM_RETRY_SHORT) {
-		pstrCfgParamVal.flag  |= RETRY_SHORT;
-		pstrCfgParamVal.short_retry_limit = priv->dev->ieee80211_ptr->wiphy->retry_short;
-	}
-	if (changed & WIPHY_PARAM_RETRY_LONG) {
-		pstrCfgParamVal.flag |= RETRY_LONG;
-		pstrCfgParamVal.long_retry_limit = priv->dev->ieee80211_ptr->wiphy->retry_long;
-	}
-	if (changed & WIPHY_PARAM_FRAG_THRESHOLD) {
-		pstrCfgParamVal.flag |= FRAG_THRESHOLD;
-		pstrCfgParamVal.frag_threshold = priv->dev->ieee80211_ptr->wiphy->frag_threshold;
-	}
-
-	if (changed & WIPHY_PARAM_RTS_THRESHOLD) {
-		pstrCfgParamVal.flag |= RTS_THRESHOLD;
-		pstrCfgParamVal.rts_threshold = priv->dev->ieee80211_ptr->wiphy->rts_threshold;
-	}
-
-	s32Error = wilc_hif_set_cfg(vif, &pstrCfgParamVal);
-	if (s32Error)
-		netdev_err(priv->dev, "Error in setting WIPHY PARAMS\n");
-
-	return s32Error;
-}
-
-static int set_pmksa(struct wiphy *wiphy, struct net_device *netdev,
-		     struct cfg80211_pmksa *pmksa)
-{
-	u32 i;
-	s32 s32Error = 0;
-	u8 flag = 0;
-	struct wilc_vif *vif;
-	struct wilc_priv *priv = wiphy_priv(wiphy);
-
-	vif = netdev_priv(priv->dev);
-
-	for (i = 0; i < priv->pmkid_list.numpmkid; i++)	{
-		if (!memcmp(pmksa->bssid, priv->pmkid_list.pmkidlist[i].bssid,
-			    ETH_ALEN)) {
-			flag = PMKID_FOUND;
-			break;
-		}
-	}
-	if (i < WILC_MAX_NUM_PMKIDS) {
-		memcpy(priv->pmkid_list.pmkidlist[i].bssid, pmksa->bssid,
-		       ETH_ALEN);
-		memcpy(priv->pmkid_list.pmkidlist[i].pmkid, pmksa->pmkid,
-		       PMKID_LEN);
-		if (!(flag == PMKID_FOUND))
-			priv->pmkid_list.numpmkid++;
-	} else {
-		netdev_err(netdev, "Invalid PMKID index\n");
-		s32Error = -EINVAL;
-	}
-
-	if (!s32Error)
-		s32Error = wilc_set_pmkid_info(vif, &priv->pmkid_list);
-
-	return s32Error;
-}
-
-static int del_pmksa(struct wiphy *wiphy, struct net_device *netdev,
-		     struct cfg80211_pmksa *pmksa)
-{
-	u32 i;
-	s32 s32Error = 0;
-
-	struct wilc_priv *priv = wiphy_priv(wiphy);
-
-	for (i = 0; i < priv->pmkid_list.numpmkid; i++)	{
-		if (!memcmp(pmksa->bssid, priv->pmkid_list.pmkidlist[i].bssid,
-			    ETH_ALEN)) {
-			memset(&priv->pmkid_list.pmkidlist[i], 0, sizeof(struct host_if_pmkid));
-			break;
-		}
-	}
-
-	if (i < priv->pmkid_list.numpmkid && priv->pmkid_list.numpmkid > 0) {
-		for (; i < (priv->pmkid_list.numpmkid - 1); i++) {
-			memcpy(priv->pmkid_list.pmkidlist[i].bssid,
-			       priv->pmkid_list.pmkidlist[i + 1].bssid,
-			       ETH_ALEN);
-			memcpy(priv->pmkid_list.pmkidlist[i].pmkid,
-			       priv->pmkid_list.pmkidlist[i + 1].pmkid,
-			       PMKID_LEN);
-		}
-		priv->pmkid_list.numpmkid--;
-	} else {
-		s32Error = -EINVAL;
-	}
-
-	return s32Error;
-}
-
-static int flush_pmksa(struct wiphy *wiphy, struct net_device *netdev)
-{
-	struct wilc_priv *priv = wiphy_priv(wiphy);
-
-	memset(&priv->pmkid_list, 0, sizeof(struct host_if_pmkid_attr));
-
-	return 0;
-}
-
-static void WILC_WFI_CfgParseRxAction(u8 *buf, u32 len)
-{
-	u32 index = 0;
-	u32 i = 0, j = 0;
-
-	u8 op_channel_attr_index = 0;
-	u8 channel_list_attr_index = 0;
-
-	while (index < len) {
-		if (buf[index] == GO_INTENT_ATTR_ID)
-			buf[index + 3] = (buf[index + 3]  & 0x01) | (0x00 << 1);
-
-		if (buf[index] ==  CHANLIST_ATTR_ID)
-			channel_list_attr_index = index;
-		else if (buf[index] ==  OPERCHAN_ATTR_ID)
-			op_channel_attr_index = index;
-		index += buf[index + 1] + 3;
-	}
-	if (wlan_channel != INVALID_CHANNEL) {
-		if (channel_list_attr_index) {
-			for (i = channel_list_attr_index + 3; i < ((channel_list_attr_index + 3) + buf[channel_list_attr_index + 1]); i++) {
-				if (buf[i] == 0x51) {
-					for (j = i + 2; j < ((i + 2) + buf[i + 1]); j++)
-						buf[j] = wlan_channel;
-					break;
-				}
-			}
-		}
-
-		if (op_channel_attr_index) {
-			buf[op_channel_attr_index + 6] = 0x51;
-			buf[op_channel_attr_index + 7] = wlan_channel;
-		}
-	}
-}
-
-static void WILC_WFI_CfgParseTxAction(u8 *buf, u32 len, bool bOperChan, u8 iftype)
-{
-	u32 index = 0;
-	u32 i = 0, j = 0;
-
-	u8 op_channel_attr_index = 0;
-	u8 channel_list_attr_index = 0;
-
-	while (index < len) {
-		if (buf[index] == GO_INTENT_ATTR_ID) {
-			buf[index + 3] = (buf[index + 3]  & 0x01) | (0x0f << 1);
-
-			break;
-		}
-
-		if (buf[index] ==  CHANLIST_ATTR_ID)
-			channel_list_attr_index = index;
-		else if (buf[index] ==  OPERCHAN_ATTR_ID)
-			op_channel_attr_index = index;
-		index += buf[index + 1] + 3;
-	}
-	if (wlan_channel != INVALID_CHANNEL && bOperChan) {
-		if (channel_list_attr_index) {
-			for (i = channel_list_attr_index + 3; i < ((channel_list_attr_index + 3) + buf[channel_list_attr_index + 1]); i++) {
-				if (buf[i] == 0x51) {
-					for (j = i + 2; j < ((i + 2) + buf[i + 1]); j++)
-						buf[j] = wlan_channel;
-					break;
-				}
-			}
-		}
-
-		if (op_channel_attr_index) {
-			buf[op_channel_attr_index + 6] = 0x51;
-			buf[op_channel_attr_index + 7] = wlan_channel;
-		}
-	}
-}
-
-void WILC_WFI_p2p_rx(struct net_device *dev, u8 *buff, u32 size)
-{
-	struct wilc_priv *priv;
-	u32 header, pkt_offset;
-	struct host_if_drv *pstrWFIDrv;
-	u32 i = 0;
-	s32 s32Freq;
-
-	priv = wiphy_priv(dev->ieee80211_ptr->wiphy);
-	pstrWFIDrv = (struct host_if_drv *)priv->hif_drv;
-
-	memcpy(&header, (buff - HOST_HDR_OFFSET), HOST_HDR_OFFSET);
-
-	pkt_offset = GET_PKT_OFFSET(header);
-
-	if (pkt_offset & IS_MANAGMEMENT_CALLBACK) {
-		if (buff[FRAME_TYPE_ID] == IEEE80211_STYPE_PROBE_RESP) {
-			cfg80211_mgmt_tx_status(priv->wdev, priv->u64tx_cookie, buff, size, true, GFP_KERNEL);
-			return;
-		} else {
-			if (pkt_offset & IS_MGMT_STATUS_SUCCES)
-				cfg80211_mgmt_tx_status(priv->wdev, priv->u64tx_cookie, buff, size, true, GFP_KERNEL);
-			else
-				cfg80211_mgmt_tx_status(priv->wdev, priv->u64tx_cookie, buff, size, false, GFP_KERNEL);
-			return;
-		}
-	} else {
-		s32Freq = ieee80211_channel_to_frequency(curr_channel, NL80211_BAND_2GHZ);
-
-		if (ieee80211_is_action(buff[FRAME_TYPE_ID])) {
-			if (priv->bCfgScanning && time_after_eq(jiffies, (unsigned long)pstrWFIDrv->p2p_timeout)) {
-				netdev_dbg(dev, "Receiving action wrong ch\n");
-				return;
-			}
-			if (buff[ACTION_CAT_ID] == PUB_ACTION_ATTR_ID) {
-				switch (buff[ACTION_SUBTYPE_ID]) {
-				case GAS_INITIAL_REQ:
-					break;
-
-				case GAS_INITIAL_RSP:
-					break;
-
-				case PUBLIC_ACT_VENDORSPEC:
-					if (!memcmp(p2p_oui, &buff[ACTION_SUBTYPE_ID + 1], 4)) {
-						if ((buff[P2P_PUB_ACTION_SUBTYPE] == GO_NEG_REQ || buff[P2P_PUB_ACTION_SUBTYPE] == GO_NEG_RSP))	{
-							if (!wilc_ie) {
-								for (i = P2P_PUB_ACTION_SUBTYPE; i < size; i++)	{
-									if (!memcmp(p2p_vendor_spec, &buff[i], 6)) {
-										p2p_recv_random = buff[i + 6];
-										wilc_ie = true;
-										break;
-									}
-								}
-							}
-						}
-						if (p2p_local_random > p2p_recv_random)	{
-							if ((buff[P2P_PUB_ACTION_SUBTYPE] == GO_NEG_REQ || buff[P2P_PUB_ACTION_SUBTYPE] == GO_NEG_RSP ||
-							     buff[P2P_PUB_ACTION_SUBTYPE] == P2P_INV_REQ || buff[P2P_PUB_ACTION_SUBTYPE] == P2P_INV_RSP)) {
-								for (i = P2P_PUB_ACTION_SUBTYPE + 2; i < size; i++) {
-									if (buff[i] == P2PELEM_ATTR_ID && !(memcmp(p2p_oui, &buff[i + 2], 4))) {
-										WILC_WFI_CfgParseRxAction(&buff[i + 6], size - (i + 6));
-										break;
-									}
-								}
-							}
-						} else {
-							netdev_dbg(dev, "PEER WILL BE GO LocaRand=%02x RecvRand %02x\n", p2p_local_random, p2p_recv_random);
-						}
-					}
-
-					if ((buff[P2P_PUB_ACTION_SUBTYPE] == GO_NEG_REQ || buff[P2P_PUB_ACTION_SUBTYPE] == GO_NEG_RSP) && (wilc_ie))	{
-						cfg80211_rx_mgmt(priv->wdev, s32Freq, 0, buff, size - 7, 0);
-						return;
-					}
-					break;
-
-				default:
-					netdev_dbg(dev, "NOT HANDLED PUBLIC ACTION FRAME TYPE:%x\n", buff[ACTION_SUBTYPE_ID]);
-					break;
-				}
-			}
-		}
-
-		cfg80211_rx_mgmt(priv->wdev, s32Freq, 0, buff, size, 0);
-	}
-}
-
-static void WILC_WFI_mgmt_tx_complete(void *priv, int status)
-{
-	struct p2p_mgmt_data *pv_data = priv;
-
-	kfree(pv_data->buff);
-	kfree(pv_data);
-}
-
-static void WILC_WFI_RemainOnChannelReady(void *pUserVoid)
-{
-	struct wilc_priv *priv;
-
-	priv = pUserVoid;
-
-	priv->bInP2PlistenState = true;
-
-	cfg80211_ready_on_channel(priv->wdev,
-				  priv->strRemainOnChanParams.u64ListenCookie,
-				  priv->strRemainOnChanParams.pstrListenChan,
-				  priv->strRemainOnChanParams.u32ListenDuration,
-				  GFP_KERNEL);
-}
-
-static void WILC_WFI_RemainOnChannelExpired(void *pUserVoid, u32 u32SessionID)
-{
-	struct wilc_priv *priv;
-
-	priv = pUserVoid;
-
-	if (u32SessionID == priv->strRemainOnChanParams.u32ListenSessionID) {
-		priv->bInP2PlistenState = false;
-
-		cfg80211_remain_on_channel_expired(priv->wdev,
-						   priv->strRemainOnChanParams.u64ListenCookie,
-						   priv->strRemainOnChanParams.pstrListenChan,
-						   GFP_KERNEL);
-	}
-}
-
-static int remain_on_channel(struct wiphy *wiphy,
-			     struct wireless_dev *wdev,
-			     struct ieee80211_channel *chan,
-			     unsigned int duration, u64 *cookie)
-{
-	s32 s32Error = 0;
-	struct wilc_priv *priv;
-	struct wilc_vif *vif;
-
-	priv = wiphy_priv(wiphy);
-	vif = netdev_priv(priv->dev);
-
-	if (wdev->iftype == NL80211_IFTYPE_AP) {
-		netdev_dbg(vif->ndev, "Required while in AP mode\n");
-		return s32Error;
-	}
-
-	curr_channel = chan->hw_value;
-
-	priv->strRemainOnChanParams.pstrListenChan = chan;
-	priv->strRemainOnChanParams.u64ListenCookie = *cookie;
-	priv->strRemainOnChanParams.u32ListenDuration = duration;
-	priv->strRemainOnChanParams.u32ListenSessionID++;
-
-	return wilc_remain_on_channel(vif,
-				priv->strRemainOnChanParams.u32ListenSessionID,
-				duration, chan->hw_value,
-				WILC_WFI_RemainOnChannelExpired,
-				WILC_WFI_RemainOnChannelReady, (void *)priv);
-}
-
-static int cancel_remain_on_channel(struct wiphy *wiphy,
-				    struct wireless_dev *wdev,
-				    u64 cookie)
-{
-	struct wilc_priv *priv;
-	struct wilc_vif *vif;
-
-	priv = wiphy_priv(wiphy);
-	vif = netdev_priv(priv->dev);
-
-	return wilc_listen_state_expired(vif,
-			priv->strRemainOnChanParams.u32ListenSessionID);
-}
-
-static int mgmt_tx(struct wiphy *wiphy,
-		   struct wireless_dev *wdev,
-		   struct cfg80211_mgmt_tx_params *params,
-		   u64 *cookie)
-{
-	struct ieee80211_channel *chan = params->chan;
-	unsigned int wait = params->wait;
-	const u8 *buf = params->buf;
-	size_t len = params->len;
-	const struct ieee80211_mgmt *mgmt;
-	struct p2p_mgmt_data *mgmt_tx;
-	struct wilc_priv *priv;
-	struct host_if_drv *pstrWFIDrv;
-	u32 i;
-	struct wilc_vif *vif;
-	u32 buf_len = len + sizeof(p2p_vendor_spec) + sizeof(p2p_local_random);
-
-	vif = netdev_priv(wdev->netdev);
-	priv = wiphy_priv(wiphy);
-	pstrWFIDrv = (struct host_if_drv *)priv->hif_drv;
-
-	*cookie = (unsigned long)buf;
-	priv->u64tx_cookie = *cookie;
-	mgmt = (const struct ieee80211_mgmt *) buf;
-
-	if (ieee80211_is_mgmt(mgmt->frame_control)) {
-		mgmt_tx = kmalloc(sizeof(struct p2p_mgmt_data), GFP_KERNEL);
-		if (!mgmt_tx)
-			return -EFAULT;
-
-		mgmt_tx->buff = kmalloc(buf_len, GFP_KERNEL);
-		if (!mgmt_tx->buff) {
-			kfree(mgmt_tx);
-			return -ENOMEM;
-		}
-
-		memcpy(mgmt_tx->buff, buf, len);
-		mgmt_tx->size = len;
-
-		if (ieee80211_is_probe_resp(mgmt->frame_control)) {
-			wilc_set_mac_chnl_num(vif, chan->hw_value);
-			curr_channel = chan->hw_value;
-		} else if (ieee80211_is_action(mgmt->frame_control))   {
-			if (buf[ACTION_CAT_ID] == PUB_ACTION_ATTR_ID) {
-				if (buf[ACTION_SUBTYPE_ID] != PUBLIC_ACT_VENDORSPEC ||
-				    buf[P2P_PUB_ACTION_SUBTYPE] != GO_NEG_CONF)	{
-					wilc_set_mac_chnl_num(vif,
-							      chan->hw_value);
-					curr_channel = chan->hw_value;
-				}
-				switch (buf[ACTION_SUBTYPE_ID])	{
-				case GAS_INITIAL_REQ:
-					break;
-
-				case GAS_INITIAL_RSP:
-					break;
-
-				case PUBLIC_ACT_VENDORSPEC:
-				{
-					if (!memcmp(p2p_oui, &buf[ACTION_SUBTYPE_ID + 1], 4)) {
-						if ((buf[P2P_PUB_ACTION_SUBTYPE] == GO_NEG_REQ || buf[P2P_PUB_ACTION_SUBTYPE] == GO_NEG_RSP)) {
-							if (p2p_local_random == 1 && p2p_recv_random < p2p_local_random) {
-								get_random_bytes(&p2p_local_random, 1);
-								p2p_local_random++;
-							}
-						}
-
-						if ((buf[P2P_PUB_ACTION_SUBTYPE] == GO_NEG_REQ || buf[P2P_PUB_ACTION_SUBTYPE] == GO_NEG_RSP ||
-						     buf[P2P_PUB_ACTION_SUBTYPE] == P2P_INV_REQ || buf[P2P_PUB_ACTION_SUBTYPE] == P2P_INV_RSP)) {
-							if (p2p_local_random > p2p_recv_random)	{
-								for (i = P2P_PUB_ACTION_SUBTYPE + 2; i < len; i++) {
-									if (buf[i] == P2PELEM_ATTR_ID && !(memcmp(p2p_oui, &buf[i + 2], 4))) {
-										if (buf[P2P_PUB_ACTION_SUBTYPE] == P2P_INV_REQ || buf[P2P_PUB_ACTION_SUBTYPE] == P2P_INV_RSP)
-											WILC_WFI_CfgParseTxAction(&mgmt_tx->buff[i + 6], len - (i + 6), true, vif->iftype);
-										else
-											WILC_WFI_CfgParseTxAction(&mgmt_tx->buff[i + 6], len - (i + 6), false, vif->iftype);
-										break;
-									}
-								}
-
-								if (buf[P2P_PUB_ACTION_SUBTYPE] != P2P_INV_REQ && buf[P2P_PUB_ACTION_SUBTYPE] != P2P_INV_RSP) {
-									memcpy(&mgmt_tx->buff[len], p2p_vendor_spec, sizeof(p2p_vendor_spec));
-									mgmt_tx->buff[len + sizeof(p2p_vendor_spec)] = p2p_local_random;
-									mgmt_tx->size = buf_len;
-								}
-							}
-						}
-
-					} else {
-						netdev_dbg(vif->ndev, "Not a P2P public action frame\n");
-					}
-
-					break;
-				}
-
-				default:
-				{
-					netdev_dbg(vif->ndev, "NOT HANDLED PUBLIC ACTION FRAME TYPE:%x\n", buf[ACTION_SUBTYPE_ID]);
-					break;
-				}
-				}
-			}
-
-			pstrWFIDrv->p2p_timeout = (jiffies + msecs_to_jiffies(wait));
-		}
-
-		wilc_wlan_txq_add_mgmt_pkt(wdev->netdev, mgmt_tx,
-					   mgmt_tx->buff, mgmt_tx->size,
-					   WILC_WFI_mgmt_tx_complete);
-	}
-	return 0;
-}
-
-static int mgmt_tx_cancel_wait(struct wiphy *wiphy,
-			       struct wireless_dev *wdev,
-			       u64 cookie)
-{
-	struct wilc_priv *priv;
-	struct host_if_drv *pstrWFIDrv;
-
-	priv = wiphy_priv(wiphy);
-	pstrWFIDrv = (struct host_if_drv *)priv->hif_drv;
-	pstrWFIDrv->p2p_timeout = jiffies;
-
-	if (!priv->bInP2PlistenState) {
-		cfg80211_remain_on_channel_expired(priv->wdev,
-						   priv->strRemainOnChanParams.u64ListenCookie,
-						   priv->strRemainOnChanParams.pstrListenChan,
-						   GFP_KERNEL);
-	}
-
-	return 0;
-}
-
-void wilc_mgmt_frame_register(struct wiphy *wiphy, struct wireless_dev *wdev,
-			      u16 frame_type, bool reg)
-{
-	struct wilc_priv *priv;
-	struct wilc_vif *vif;
-	struct wilc *wl;
-
-	priv = wiphy_priv(wiphy);
-	vif = netdev_priv(priv->wdev->netdev);
-	wl = vif->wilc;
-
-	if (!frame_type)
-		return;
-
-	switch (frame_type) {
-	case PROBE_REQ:
-	{
-		vif->frame_reg[0].type = frame_type;
-		vif->frame_reg[0].reg = reg;
-	}
-	break;
-
-	case ACTION:
-	{
-		vif->frame_reg[1].type = frame_type;
-		vif->frame_reg[1].reg = reg;
-	}
-	break;
-
-	default:
-	{
-		break;
-	}
-	}
-
-	if (!wl->initialized)
-		return;
-	wilc_frame_register(vif, frame_type, reg);
-}
-
-static int set_cqm_rssi_config(struct wiphy *wiphy, struct net_device *dev,
-			       s32 rssi_thold, u32 rssi_hyst)
-{
-	return 0;
-}
-
-static int dump_station(struct wiphy *wiphy, struct net_device *dev,
-			int idx, u8 *mac, struct station_info *sinfo)
-{
-	struct wilc_priv *priv;
-	struct wilc_vif *vif;
-
-	if (idx != 0)
-		return -ENOENT;
-
-	priv = wiphy_priv(wiphy);
-	vif = netdev_priv(priv->dev);
-
-	sinfo->filled |= BIT(NL80211_STA_INFO_SIGNAL);
-
-	wilc_get_rssi(vif, &sinfo->signal);
-
-	memcpy(mac, priv->au8AssociatedBss, ETH_ALEN);
-	return 0;
-}
-
-static int set_power_mgmt(struct wiphy *wiphy, struct net_device *dev,
-			  bool enabled, int timeout)
-{
-	struct wilc_priv *priv;
-	struct wilc_vif *vif;
-
-	if (!wiphy)
-		return -ENOENT;
-
-	priv = wiphy_priv(wiphy);
-	vif = netdev_priv(priv->dev);
-	if (!priv->hif_drv)
-		return -EIO;
-
-	if (wilc_enable_ps)
-		wilc_set_power_mgmt(vif, enabled, timeout);
-
-	return 0;
-}
-
-static int change_virtual_intf(struct wiphy *wiphy, struct net_device *dev,
-			       enum nl80211_iftype type, struct vif_params *params)
-{
-	struct wilc_priv *priv;
-	struct wilc_vif *vif;
-	struct wilc *wl;
-
-	vif = netdev_priv(dev);
-	priv = wiphy_priv(wiphy);
-	wl = vif->wilc;
-	p2p_local_random = 0x01;
-	p2p_recv_random = 0x00;
-	wilc_ie = false;
-	wilc_optaining_ip = false;
-	del_timer(&wilc_during_ip_timer);
-
-	switch (type) {
-	case NL80211_IFTYPE_STATION:
-		wilc_connecting = 0;
-		dev->ieee80211_ptr->iftype = type;
-		priv->wdev->iftype = type;
-		vif->monitor_flag = 0;
-		vif->iftype = STATION_MODE;
-		wilc_set_operation_mode(vif, STATION_MODE);
-
-		memset(priv->assoc_stainfo.au8Sta_AssociatedBss, 0, MAX_NUM_STA * ETH_ALEN);
-
-		wilc_enable_ps = true;
-		wilc_set_power_mgmt(vif, 1, 0);
-		break;
-
-	case NL80211_IFTYPE_P2P_CLIENT:
-		wilc_connecting = 0;
-		dev->ieee80211_ptr->iftype = type;
-		priv->wdev->iftype = type;
-		vif->monitor_flag = 0;
-		vif->iftype = CLIENT_MODE;
-		wilc_set_operation_mode(vif, STATION_MODE);
-
-		wilc_enable_ps = false;
-		wilc_set_power_mgmt(vif, 0, 0);
-		break;
-
-	case NL80211_IFTYPE_AP:
-		wilc_enable_ps = false;
-		dev->ieee80211_ptr->iftype = type;
-		priv->wdev->iftype = type;
-		vif->iftype = AP_MODE;
-
-		if (wl->initialized) {
-			wilc_set_wfi_drv_handler(vif, wilc_get_vif_idx(vif),
-						 0, vif->ifc_id);
-			wilc_set_operation_mode(vif, AP_MODE);
-			wilc_set_power_mgmt(vif, 0, 0);
-		}
-		break;
-
-	case NL80211_IFTYPE_P2P_GO:
-		wilc_optaining_ip = true;
-		mod_timer(&wilc_during_ip_timer,
-			  jiffies + msecs_to_jiffies(during_ip_time));
-		wilc_set_operation_mode(vif, AP_MODE);
-		dev->ieee80211_ptr->iftype = type;
-		priv->wdev->iftype = type;
-		vif->iftype = GO_MODE;
-
-		wilc_enable_ps = false;
-		wilc_set_power_mgmt(vif, 0, 0);
-		break;
-
-	default:
-		netdev_err(dev, "Unknown interface type= %d\n", type);
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-static int start_ap(struct wiphy *wiphy, struct net_device *dev,
-		    struct cfg80211_ap_settings *settings)
-{
-	struct cfg80211_beacon_data *beacon = &(settings->beacon);
-	struct wilc_priv *priv;
-	s32 s32Error = 0;
-	struct wilc *wl;
-	struct wilc_vif *vif;
-
-	priv = wiphy_priv(wiphy);
-	vif = netdev_priv(dev);
-	wl = vif->wilc;
-
-	s32Error = set_channel(wiphy, &settings->chandef);
-
-	if (s32Error != 0)
-		netdev_err(dev, "Error in setting channel\n");
-
-	wilc_wlan_set_bssid(dev, wl->vif[vif->idx]->src_addr, AP_MODE);
-	wilc_set_power_mgmt(vif, 0, 0);
-
-	return wilc_add_beacon(vif, settings->beacon_interval,
-				   settings->dtim_period, beacon->head_len,
-				   (u8 *)beacon->head, beacon->tail_len,
-				   (u8 *)beacon->tail);
-}
-
-static int change_beacon(struct wiphy *wiphy, struct net_device *dev,
-			 struct cfg80211_beacon_data *beacon)
-{
-	struct wilc_priv *priv;
-	struct wilc_vif *vif;
-
-	priv = wiphy_priv(wiphy);
-	vif = netdev_priv(priv->dev);
-
-	return wilc_add_beacon(vif, 0, 0, beacon->head_len,
-				   (u8 *)beacon->head, beacon->tail_len,
-				   (u8 *)beacon->tail);
-}
-
-static int stop_ap(struct wiphy *wiphy, struct net_device *dev)
-{
-	s32 s32Error = 0;
-	struct wilc_priv *priv;
-	struct wilc_vif *vif;
-	u8 NullBssid[ETH_ALEN] = {0};
-
-	if (!wiphy)
-		return -EFAULT;
-
-	priv = wiphy_priv(wiphy);
-	vif = netdev_priv(priv->dev);
-
-	wilc_wlan_set_bssid(dev, NullBssid, AP_MODE);
-
-	s32Error = wilc_del_beacon(vif);
-
-	if (s32Error)
-		netdev_err(dev, "Host delete beacon fail\n");
-
-	return s32Error;
-}
-
-static int add_station(struct wiphy *wiphy, struct net_device *dev,
-		       const u8 *mac, struct station_parameters *params)
-{
-	s32 s32Error = 0;
-	struct wilc_priv *priv;
-	struct add_sta_param strStaParams = { {0} };
-	struct wilc_vif *vif;
-
-	if (!wiphy)
-		return -EFAULT;
-
-	priv = wiphy_priv(wiphy);
-	vif = netdev_priv(dev);
-
-	if (vif->iftype == AP_MODE || vif->iftype == GO_MODE) {
-		memcpy(strStaParams.bssid, mac, ETH_ALEN);
-		memcpy(priv->assoc_stainfo.au8Sta_AssociatedBss[params->aid], mac, ETH_ALEN);
-		strStaParams.aid = params->aid;
-		strStaParams.rates_len = params->supported_rates_len;
-		strStaParams.rates = params->supported_rates;
-
-		if (!params->ht_capa) {
-			strStaParams.ht_supported = false;
-		} else {
-			strStaParams.ht_supported = true;
-			strStaParams.ht_capa = *params->ht_capa;
-		}
-
-		strStaParams.flags_mask = params->sta_flags_mask;
-		strStaParams.flags_set = params->sta_flags_set;
-
-		s32Error = wilc_add_station(vif, &strStaParams);
-		if (s32Error)
-			netdev_err(dev, "Host add station fail\n");
-	}
-
-	return s32Error;
-}
-
-static int del_station(struct wiphy *wiphy, struct net_device *dev,
-		       struct station_del_parameters *params)
-{
-	const u8 *mac = params->mac;
-	s32 s32Error = 0;
-	struct wilc_priv *priv;
-	struct wilc_vif *vif;
-
-	if (!wiphy)
-		return -EFAULT;
-
-	priv = wiphy_priv(wiphy);
-	vif = netdev_priv(dev);
-
-	if (vif->iftype == AP_MODE || vif->iftype == GO_MODE) {
-		if (!mac)
-			s32Error = wilc_del_allstation(vif,
-				     priv->assoc_stainfo.au8Sta_AssociatedBss);
-
-		s32Error = wilc_del_station(vif, mac);
-
-		if (s32Error)
-			netdev_err(dev, "Host delete station fail\n");
-	}
-	return s32Error;
-}
-
-static int change_station(struct wiphy *wiphy, struct net_device *dev,
-			  const u8 *mac, struct station_parameters *params)
-{
-	s32 s32Error = 0;
-	struct wilc_priv *priv;
-	struct add_sta_param strStaParams = { {0} };
-	struct wilc_vif *vif;
-
-	if (!wiphy)
-		return -EFAULT;
-
-	priv = wiphy_priv(wiphy);
-	vif = netdev_priv(dev);
-
-	if (vif->iftype == AP_MODE || vif->iftype == GO_MODE) {
-		memcpy(strStaParams.bssid, mac, ETH_ALEN);
-		strStaParams.aid = params->aid;
-		strStaParams.rates_len = params->supported_rates_len;
-		strStaParams.rates = params->supported_rates;
-
-		if (!params->ht_capa) {
-			strStaParams.ht_supported = false;
-		} else {
-			strStaParams.ht_supported = true;
-			strStaParams.ht_capa = *params->ht_capa;
-		}
-
-		strStaParams.flags_mask = params->sta_flags_mask;
-		strStaParams.flags_set = params->sta_flags_set;
-
-		s32Error = wilc_edit_station(vif, &strStaParams);
-		if (s32Error)
-			netdev_err(dev, "Host edit station fail\n");
-	}
-	return s32Error;
-}
-
-static struct wireless_dev *add_virtual_intf(struct wiphy *wiphy,
-					     const char *name,
-					     unsigned char name_assign_type,
-					     enum nl80211_iftype type,
-					     struct vif_params *params)
-{
-	struct wilc_vif *vif;
-	struct wilc_priv *priv;
-	struct net_device *new_ifc = NULL;
-
-	priv = wiphy_priv(wiphy);
-	vif = netdev_priv(priv->wdev->netdev);
-
-	if (type == NL80211_IFTYPE_MONITOR) {
-		new_ifc = WILC_WFI_init_mon_interface(name, vif->ndev);
-		if (new_ifc) {
-			vif = netdev_priv(priv->wdev->netdev);
-			vif->monitor_flag = 1;
-		}
-	}
-	return priv->wdev;
-}
-
-static int del_virtual_intf(struct wiphy *wiphy, struct wireless_dev *wdev)
-{
-	return 0;
-}
-
-static int wilc_suspend(struct wiphy *wiphy, struct cfg80211_wowlan *wow)
-{
-	struct wilc_priv *priv = wiphy_priv(wiphy);
-	struct wilc_vif *vif = netdev_priv(priv->dev);
-
-	if (!wow && wilc_wlan_get_num_conn_ifcs(vif->wilc))
-		vif->wilc->suspend_event = true;
-	else
-		vif->wilc->suspend_event = false;
-
-	return 0;
-}
-
-static int wilc_resume(struct wiphy *wiphy)
-{
-	struct wilc_priv *priv = wiphy_priv(wiphy);
-	struct wilc_vif *vif = netdev_priv(priv->dev);
-
-	netdev_info(vif->ndev, "cfg resume\n");
-	return 0;
-}
-
-static void wilc_set_wakeup(struct wiphy *wiphy, bool enabled)
-{
-	struct wilc_priv *priv = wiphy_priv(wiphy);
-	struct wilc_vif *vif = netdev_priv(priv->dev);
-
-	netdev_info(vif->ndev, "cfg set wake up = %d\n", enabled);
-}
-
-static int set_tx_power(struct wiphy *wiphy, struct wireless_dev *wdev,
-			enum nl80211_tx_power_setting type, int mbm)
-{
-	int ret;
-	s32 tx_power = MBM_TO_DBM(mbm);
-	struct wilc_priv *priv = wiphy_priv(wiphy);
-	struct wilc_vif *vif = netdev_priv(priv->dev);
-
-	if (tx_power < 0)
-		tx_power = 0;
-	else if (tx_power > 18)
-		tx_power = 18;
-	ret = wilc_set_tx_power(vif, tx_power);
-	if (ret)
-		netdev_err(vif->ndev, "Failed to set tx power\n");
-
-	return ret;
-}
-
-static int get_tx_power(struct wiphy *wiphy, struct wireless_dev *wdev,
-			int *dbm)
-{
-	int ret;
-	struct wilc_priv *priv = wiphy_priv(wiphy);
-	struct wilc_vif *vif = netdev_priv(priv->dev);
-	struct wilc *wl;
-
-	wl = vif->wilc;
-
-	/* If firmware is not started, return. */
-	if (!wl->initialized)
-		return -EIO;
-
-	ret = wilc_get_tx_power(vif, (u8 *)dbm);
-	if (ret)
-		netdev_err(vif->ndev, "Failed to get tx power\n");
-
-	return ret;
-}
-
-static const struct cfg80211_ops wilc_cfg80211_ops = {
-	.set_monitor_channel = set_channel,
-	.scan = scan,
-	.connect = connect,
-	.disconnect = disconnect,
-	.add_key = add_key,
-	.del_key = del_key,
-	.get_key = get_key,
-	.set_default_key = set_default_key,
-	.add_virtual_intf = add_virtual_intf,
-	.del_virtual_intf = del_virtual_intf,
-	.change_virtual_intf = change_virtual_intf,
-
-	.start_ap = start_ap,
-	.change_beacon = change_beacon,
-	.stop_ap = stop_ap,
-	.add_station = add_station,
-	.del_station = del_station,
-	.change_station = change_station,
-	.get_station = get_station,
-	.dump_station = dump_station,
-	.change_bss = change_bss,
-	.set_wiphy_params = set_wiphy_params,
-
-	.set_pmksa = set_pmksa,
-	.del_pmksa = del_pmksa,
-	.flush_pmksa = flush_pmksa,
-	.remain_on_channel = remain_on_channel,
-	.cancel_remain_on_channel = cancel_remain_on_channel,
-	.mgmt_tx_cancel_wait = mgmt_tx_cancel_wait,
-	.mgmt_tx = mgmt_tx,
-	.mgmt_frame_register = wilc_mgmt_frame_register,
-	.set_power_mgmt = set_power_mgmt,
-	.set_cqm_rssi_config = set_cqm_rssi_config,
-
-	.suspend = wilc_suspend,
-	.resume = wilc_resume,
-	.set_wakeup = wilc_set_wakeup,
-	.set_tx_power = set_tx_power,
-	.get_tx_power = get_tx_power,
-
-};
-
-static struct wireless_dev *WILC_WFI_CfgAlloc(void)
-{
-	struct wireless_dev *wdev;
-
-	wdev = kzalloc(sizeof(struct wireless_dev), GFP_KERNEL);
-	if (!wdev)
-		goto _fail_;
-
-	wdev->wiphy = wiphy_new(&wilc_cfg80211_ops, sizeof(struct wilc_priv));
-	if (!wdev->wiphy)
-		goto _fail_mem_;
-
-	WILC_WFI_band_2ghz.ht_cap.ht_supported = 1;
-	WILC_WFI_band_2ghz.ht_cap.cap |= (1 << IEEE80211_HT_CAP_RX_STBC_SHIFT);
-	WILC_WFI_band_2ghz.ht_cap.mcs.rx_mask[0] = 0xff;
-	WILC_WFI_band_2ghz.ht_cap.ampdu_factor = IEEE80211_HT_MAX_AMPDU_8K;
-	WILC_WFI_band_2ghz.ht_cap.ampdu_density = IEEE80211_HT_MPDU_DENSITY_NONE;
-
-	wdev->wiphy->bands[NL80211_BAND_2GHZ] = &WILC_WFI_band_2ghz;
-
-	return wdev;
-
-_fail_mem_:
-	kfree(wdev);
-_fail_:
-	return NULL;
-}
-
-struct wireless_dev *wilc_create_wiphy(struct net_device *net, struct device *dev)
-{
-	struct wilc_priv *priv;
-	struct wireless_dev *wdev;
-	s32 s32Error = 0;
-
-	wdev = WILC_WFI_CfgAlloc();
-	if (!wdev) {
-		netdev_err(net, "wiphy new allocate failed\n");
-		return NULL;
-	}
-
-	priv = wdev_priv(wdev);
-	priv->wdev = wdev;
-	wdev->wiphy->max_scan_ssids = MAX_NUM_PROBED_SSID;
-#ifdef CONFIG_PM
-	wdev->wiphy->wowlan = &wowlan_support;
-#endif
-	wdev->wiphy->max_num_pmkids = WILC_MAX_NUM_PMKIDS;
-	wdev->wiphy->max_scan_ie_len = 1000;
-	wdev->wiphy->signal_type = CFG80211_SIGNAL_TYPE_MBM;
-	wdev->wiphy->cipher_suites = cipher_suites;
-	wdev->wiphy->n_cipher_suites = ARRAY_SIZE(cipher_suites);
-	wdev->wiphy->mgmt_stypes = wilc_wfi_cfg80211_mgmt_types;
-
-	wdev->wiphy->max_remain_on_channel_duration = 500;
-	wdev->wiphy->interface_modes = BIT(NL80211_IFTYPE_STATION) |
-					BIT(NL80211_IFTYPE_AP) |
-					BIT(NL80211_IFTYPE_MONITOR) |
-					BIT(NL80211_IFTYPE_P2P_GO) |
-					BIT(NL80211_IFTYPE_P2P_CLIENT);
-	wdev->wiphy->flags |= WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL;
-	wdev->iftype = NL80211_IFTYPE_STATION;
-
-	set_wiphy_dev(wdev->wiphy, dev);
-
-	s32Error = wiphy_register(wdev->wiphy);
-	if (s32Error)
-		netdev_err(net, "Cannot register wiphy device\n");
-
-	priv->dev = net;
-	return wdev;
-}
-
-int wilc_init_host_int(struct net_device *net)
-{
-	int s32Error = 0;
-
-	struct wilc_priv *priv;
-
-	priv = wdev_priv(net->ieee80211_ptr);
-	if (op_ifcs == 0) {
-		setup_timer(&hAgingTimer, remove_network_from_shadow, 0);
-		setup_timer(&wilc_during_ip_timer, clear_duringIP, 0);
-	}
-	op_ifcs++;
-
-	priv->gbAutoRateAdjusted = false;
-
-	priv->bInP2PlistenState = false;
-
-	mutex_init(&priv->scan_req_lock);
-	s32Error = wilc_init(net, &priv->hif_drv);
-	if (s32Error)
-		netdev_err(net, "Error while initializing hostinterface\n");
-
-	return s32Error;
-}
-
-int wilc_deinit_host_int(struct net_device *net)
-{
-	int s32Error = 0;
-	struct wilc_vif *vif;
-	struct wilc_priv *priv;
-
-	priv = wdev_priv(net->ieee80211_ptr);
-	vif = netdev_priv(priv->dev);
-
-	priv->gbAutoRateAdjusted = false;
-
-	priv->bInP2PlistenState = false;
-
-	op_ifcs--;
-
-	s32Error = wilc_deinit(vif);
-
-	clear_shadow_scan();
-	if (op_ifcs == 0)
-		del_timer_sync(&wilc_during_ip_timer);
-
-	if (s32Error)
-		netdev_err(net, "Error while deinitializing host interface\n");
-
-	return s32Error;
-}
-
-void wilc_free_wiphy(struct net_device *net)
-{
-	if (!net)
-		return;
-
-	if (!net->ieee80211_ptr)
-		return;
-
-	if (!net->ieee80211_ptr->wiphy)
-		return;
-
-	wiphy_unregister(net->ieee80211_ptr->wiphy);
-
-	wiphy_free(net->ieee80211_ptr->wiphy);
-	kfree(net->ieee80211_ptr);
-}
diff --git a/drivers/staging/wilc1000/wilc_wlan.c b/drivers/staging/wilc1000/wilc_wlan.c
deleted file mode 100644
index f49dfa8..0000000
--- a/drivers/staging/wilc1000/wilc_wlan.c
+++ /dev/null
@@ -1,1439 +0,0 @@
-#include <linux/completion.h>
-#include "wilc_wlan_if.h"
-#include "wilc_wlan.h"
-#include "wilc_wfi_netdevice.h"
-#include "wilc_wlan_cfg.h"
-
-static CHIP_PS_STATE_T chip_ps_state = CHIP_WAKEDUP;
-
-static inline void acquire_bus(struct wilc *wilc, BUS_ACQUIRE_T acquire)
-{
-	mutex_lock(&wilc->hif_cs);
-	if (acquire == ACQUIRE_AND_WAKEUP)
-		chip_wakeup(wilc);
-}
-
-static inline void release_bus(struct wilc *wilc, BUS_RELEASE_T release)
-{
-	if (release == RELEASE_ALLOW_SLEEP)
-		chip_allow_sleep(wilc);
-	mutex_unlock(&wilc->hif_cs);
-}
-
-static void wilc_wlan_txq_remove(struct wilc *wilc, struct txq_entry_t *tqe)
-{
-	if (tqe == wilc->txq_head) {
-		wilc->txq_head = tqe->next;
-		if (wilc->txq_head)
-			wilc->txq_head->prev = NULL;
-	} else if (tqe == wilc->txq_tail) {
-		wilc->txq_tail = (tqe->prev);
-		if (wilc->txq_tail)
-			wilc->txq_tail->next = NULL;
-	} else {
-		tqe->prev->next = tqe->next;
-		tqe->next->prev = tqe->prev;
-	}
-	wilc->txq_entries -= 1;
-}
-
-static struct txq_entry_t *
-wilc_wlan_txq_remove_from_head(struct net_device *dev)
-{
-	struct txq_entry_t *tqe;
-	unsigned long flags;
-	struct wilc_vif *vif;
-	struct wilc *wilc;
-
-	vif = netdev_priv(dev);
-	wilc = vif->wilc;
-
-	spin_lock_irqsave(&wilc->txq_spinlock, flags);
-	if (wilc->txq_head) {
-		tqe = wilc->txq_head;
-		wilc->txq_head = tqe->next;
-		if (wilc->txq_head)
-			wilc->txq_head->prev = NULL;
-
-		wilc->txq_entries -= 1;
-	} else {
-		tqe = NULL;
-	}
-	spin_unlock_irqrestore(&wilc->txq_spinlock, flags);
-	return tqe;
-}
-
-static void wilc_wlan_txq_add_to_tail(struct net_device *dev,
-				      struct txq_entry_t *tqe)
-{
-	unsigned long flags;
-	struct wilc_vif *vif;
-	struct wilc *wilc;
-
-	vif = netdev_priv(dev);
-	wilc = vif->wilc;
-
-	spin_lock_irqsave(&wilc->txq_spinlock, flags);
-
-	if (!wilc->txq_head) {
-		tqe->next = NULL;
-		tqe->prev = NULL;
-		wilc->txq_head = tqe;
-		wilc->txq_tail = tqe;
-	} else {
-		tqe->next = NULL;
-		tqe->prev = wilc->txq_tail;
-		wilc->txq_tail->next = tqe;
-		wilc->txq_tail = tqe;
-	}
-	wilc->txq_entries += 1;
-
-	spin_unlock_irqrestore(&wilc->txq_spinlock, flags);
-
-	complete(&wilc->txq_event);
-}
-
-static int wilc_wlan_txq_add_to_head(struct wilc_vif *vif,
-				     struct txq_entry_t *tqe)
-{
-	unsigned long flags;
-	struct wilc *wilc = vif->wilc;
-
-	mutex_lock(&wilc->txq_add_to_head_cs);
-
-	spin_lock_irqsave(&wilc->txq_spinlock, flags);
-
-	if (!wilc->txq_head) {
-		tqe->next = NULL;
-		tqe->prev = NULL;
-		wilc->txq_head = tqe;
-		wilc->txq_tail = tqe;
-	} else {
-		tqe->next = wilc->txq_head;
-		tqe->prev = NULL;
-		wilc->txq_head->prev = tqe;
-		wilc->txq_head = tqe;
-	}
-	wilc->txq_entries += 1;
-
-	spin_unlock_irqrestore(&wilc->txq_spinlock, flags);
-	mutex_unlock(&wilc->txq_add_to_head_cs);
-	complete(&wilc->txq_event);
-
-	return 0;
-}
-
-struct ack_session_info;
-struct ack_session_info {
-	u32 seq_num;
-	u32 bigger_ack_num;
-	u16 src_port;
-	u16 dst_port;
-	u16 status;
-};
-
-struct pending_acks_info {
-	u32 ack_num;
-	u32 session_index;
-	struct txq_entry_t  *txqe;
-};
-
-#define NOT_TCP_ACK			(-1)
-
-#define MAX_TCP_SESSION		25
-#define MAX_PENDING_ACKS		256
-static struct ack_session_info ack_session_info[2 * MAX_TCP_SESSION];
-static struct pending_acks_info pending_acks_info[MAX_PENDING_ACKS];
-
-static u32 pending_base;
-static u32 tcp_session;
-static u32 pending_acks;
-
-static inline int add_tcp_session(u32 src_prt, u32 dst_prt, u32 seq)
-{
-	if (tcp_session < 2 * MAX_TCP_SESSION) {
-		ack_session_info[tcp_session].seq_num = seq;
-		ack_session_info[tcp_session].bigger_ack_num = 0;
-		ack_session_info[tcp_session].src_port = src_prt;
-		ack_session_info[tcp_session].dst_port = dst_prt;
-		tcp_session++;
-	}
-	return 0;
-}
-
-static inline int update_tcp_session(u32 index, u32 ack)
-{
-	if (index < 2 * MAX_TCP_SESSION &&
-	    ack > ack_session_info[index].bigger_ack_num)
-		ack_session_info[index].bigger_ack_num = ack;
-	return 0;
-}
-
-static inline int add_tcp_pending_ack(u32 ack, u32 session_index,
-				      struct txq_entry_t *txqe)
-{
-	if (pending_base + pending_acks < MAX_PENDING_ACKS) {
-		pending_acks_info[pending_base + pending_acks].ack_num = ack;
-		pending_acks_info[pending_base + pending_acks].txqe = txqe;
-		pending_acks_info[pending_base + pending_acks].session_index = session_index;
-		txqe->tcp_pending_ack_idx = pending_base + pending_acks;
-		pending_acks++;
-	}
-	return 0;
-}
-
-static inline void tcp_process(struct net_device *dev, struct txq_entry_t *tqe)
-{
-	u8 *eth_hdr_ptr;
-	u8 *buffer = tqe->buffer;
-	unsigned short h_proto;
-	int i;
-	unsigned long flags;
-	struct wilc_vif *vif;
-	struct wilc *wilc;
-
-	vif = netdev_priv(dev);
-	wilc = vif->wilc;
-
-	spin_lock_irqsave(&wilc->txq_spinlock, flags);
-
-	eth_hdr_ptr = &buffer[0];
-	h_proto = ntohs(*((unsigned short *)&eth_hdr_ptr[12]));
-	if (h_proto == ETH_P_IP) {
-		u8 *ip_hdr_ptr;
-		u8 protocol;
-
-		ip_hdr_ptr = &buffer[ETHERNET_HDR_LEN];
-		protocol = ip_hdr_ptr[9];
-
-		if (protocol == 0x06) {
-			u8 *tcp_hdr_ptr;
-			u32 IHL, total_length, data_offset;
-
-			tcp_hdr_ptr = &ip_hdr_ptr[IP_HDR_LEN];
-			IHL = (ip_hdr_ptr[0] & 0xf) << 2;
-			total_length = ((u32)ip_hdr_ptr[2] << 8) +
-					(u32)ip_hdr_ptr[3];
-			data_offset = ((u32)tcp_hdr_ptr[12] & 0xf0) >> 2;
-			if (total_length == (IHL + data_offset)) {
-				u32 seq_no, ack_no;
-
-				seq_no = ((u32)tcp_hdr_ptr[4] << 24) +
-					 ((u32)tcp_hdr_ptr[5] << 16) +
-					 ((u32)tcp_hdr_ptr[6] << 8) +
-					 (u32)tcp_hdr_ptr[7];
-
-				ack_no = ((u32)tcp_hdr_ptr[8] << 24) +
-					 ((u32)tcp_hdr_ptr[9] << 16) +
-					 ((u32)tcp_hdr_ptr[10] << 8) +
-					 (u32)tcp_hdr_ptr[11];
-
-				for (i = 0; i < tcp_session; i++) {
-					if (i < 2 * MAX_TCP_SESSION &&
-					    ack_session_info[i].seq_num == seq_no) {
-						update_tcp_session(i, ack_no);
-						break;
-					}
-				}
-				if (i == tcp_session)
-					add_tcp_session(0, 0, seq_no);
-
-				add_tcp_pending_ack(ack_no, i, tqe);
-			}
-		}
-	}
-	spin_unlock_irqrestore(&wilc->txq_spinlock, flags);
-}
-
-static int wilc_wlan_txq_filter_dup_tcp_ack(struct net_device *dev)
-{
-	struct wilc_vif *vif;
-	struct wilc *wilc;
-	u32 i = 0;
-	u32 dropped = 0;
-
-	vif = netdev_priv(dev);
-	wilc = vif->wilc;
-
-	spin_lock_irqsave(&wilc->txq_spinlock, wilc->txq_spinlock_flags);
-	for (i = pending_base; i < (pending_base + pending_acks); i++) {
-		if (i >= MAX_PENDING_ACKS ||
-		    pending_acks_info[i].session_index >= 2 * MAX_TCP_SESSION)
-			break;
-		if (pending_acks_info[i].ack_num < ack_session_info[pending_acks_info[i].session_index].bigger_ack_num) {
-			struct txq_entry_t *tqe;
-
-			tqe = pending_acks_info[i].txqe;
-			if (tqe) {
-				wilc_wlan_txq_remove(wilc, tqe);
-				tqe->status = 1;
-				if (tqe->tx_complete_func)
-					tqe->tx_complete_func(tqe->priv,
-							      tqe->status);
-				kfree(tqe);
-				dropped++;
-			}
-		}
-	}
-	pending_acks = 0;
-	tcp_session = 0;
-
-	if (pending_base == 0)
-		pending_base = MAX_TCP_SESSION;
-	else
-		pending_base = 0;
-
-	spin_unlock_irqrestore(&wilc->txq_spinlock, wilc->txq_spinlock_flags);
-
-	while (dropped > 0) {
-		wait_for_completion_timeout(&wilc->txq_event,
-					    msecs_to_jiffies(1));
-		dropped--;
-	}
-
-	return 1;
-}
-
-static bool enabled;
-
-void wilc_enable_tcp_ack_filter(bool value)
-{
-	enabled = value;
-}
-
-static int wilc_wlan_txq_add_cfg_pkt(struct wilc_vif *vif, u8 *buffer,
-				     u32 buffer_size)
-{
-	struct txq_entry_t *tqe;
-	struct wilc *wilc = vif->wilc;
-
-	netdev_dbg(vif->ndev, "Adding config packet ...\n");
-	if (wilc->quit) {
-		netdev_dbg(vif->ndev, "Return due to clear function\n");
-		complete(&wilc->cfg_event);
-		return 0;
-	}
-
-	tqe = kmalloc(sizeof(*tqe), GFP_ATOMIC);
-	if (!tqe)
-		return 0;
-
-	tqe->type = WILC_CFG_PKT;
-	tqe->buffer = buffer;
-	tqe->buffer_size = buffer_size;
-	tqe->tx_complete_func = NULL;
-	tqe->priv = NULL;
-	tqe->tcp_pending_ack_idx = NOT_TCP_ACK;
-
-	if (wilc_wlan_txq_add_to_head(vif, tqe)) {
-		kfree(tqe);
-		return 0;
-	}
-
-	return 1;
-}
-
-int wilc_wlan_txq_add_net_pkt(struct net_device *dev, void *priv, u8 *buffer,
-			      u32 buffer_size, wilc_tx_complete_func_t func)
-{
-	struct txq_entry_t *tqe;
-	struct wilc_vif *vif = netdev_priv(dev);
-	struct wilc *wilc;
-
-	wilc = vif->wilc;
-
-	if (wilc->quit)
-		return 0;
-
-	tqe = kmalloc(sizeof(*tqe), GFP_ATOMIC);
-
-	if (!tqe)
-		return 0;
-	tqe->type = WILC_NET_PKT;
-	tqe->buffer = buffer;
-	tqe->buffer_size = buffer_size;
-	tqe->tx_complete_func = func;
-	tqe->priv = priv;
-
-	tqe->tcp_pending_ack_idx = NOT_TCP_ACK;
-	if (enabled)
-		tcp_process(dev, tqe);
-	wilc_wlan_txq_add_to_tail(dev, tqe);
-	return wilc->txq_entries;
-}
-
-int wilc_wlan_txq_add_mgmt_pkt(struct net_device *dev, void *priv, u8 *buffer,
-			       u32 buffer_size, wilc_tx_complete_func_t func)
-{
-	struct txq_entry_t *tqe;
-	struct wilc_vif *vif = netdev_priv(dev);
-	struct wilc *wilc;
-
-	wilc = vif->wilc;
-
-	if (wilc->quit)
-		return 0;
-
-	tqe = kmalloc(sizeof(*tqe), GFP_KERNEL);
-
-	if (!tqe)
-		return 0;
-	tqe->type = WILC_MGMT_PKT;
-	tqe->buffer = buffer;
-	tqe->buffer_size = buffer_size;
-	tqe->tx_complete_func = func;
-	tqe->priv = priv;
-	tqe->tcp_pending_ack_idx = NOT_TCP_ACK;
-	wilc_wlan_txq_add_to_tail(dev, tqe);
-	return 1;
-}
-
-static struct txq_entry_t *wilc_wlan_txq_get_first(struct wilc *wilc)
-{
-	struct txq_entry_t *tqe;
-	unsigned long flags;
-
-	spin_lock_irqsave(&wilc->txq_spinlock, flags);
-
-	tqe = wilc->txq_head;
-
-	spin_unlock_irqrestore(&wilc->txq_spinlock, flags);
-
-	return tqe;
-}
-
-static struct txq_entry_t *wilc_wlan_txq_get_next(struct wilc *wilc,
-						  struct txq_entry_t *tqe)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&wilc->txq_spinlock, flags);
-
-	tqe = tqe->next;
-	spin_unlock_irqrestore(&wilc->txq_spinlock, flags);
-
-	return tqe;
-}
-
-static int wilc_wlan_rxq_add(struct wilc *wilc, struct rxq_entry_t *rqe)
-{
-	if (wilc->quit)
-		return 0;
-
-	mutex_lock(&wilc->rxq_cs);
-	if (!wilc->rxq_head) {
-		rqe->next = NULL;
-		wilc->rxq_head = rqe;
-		wilc->rxq_tail = rqe;
-	} else {
-		wilc->rxq_tail->next = rqe;
-		rqe->next = NULL;
-		wilc->rxq_tail = rqe;
-	}
-	wilc->rxq_entries += 1;
-	mutex_unlock(&wilc->rxq_cs);
-	return wilc->rxq_entries;
-}
-
-static struct rxq_entry_t *wilc_wlan_rxq_remove(struct wilc *wilc)
-{
-	if (wilc->rxq_head) {
-		struct rxq_entry_t *rqe;
-
-		mutex_lock(&wilc->rxq_cs);
-		rqe = wilc->rxq_head;
-		wilc->rxq_head = wilc->rxq_head->next;
-		wilc->rxq_entries -= 1;
-		mutex_unlock(&wilc->rxq_cs);
-		return rqe;
-	}
-	return NULL;
-}
-
-void chip_allow_sleep(struct wilc *wilc)
-{
-	u32 reg = 0;
-
-	wilc->hif_func->hif_read_reg(wilc, 0xf0, &reg);
-
-	wilc->hif_func->hif_write_reg(wilc, 0xf0, reg & ~BIT(0));
-	wilc->hif_func->hif_write_reg(wilc, 0xfa, 0);
-}
-EXPORT_SYMBOL_GPL(chip_allow_sleep);
-
-void chip_wakeup(struct wilc *wilc)
-{
-	u32 reg, clk_status_reg;
-
-	if ((wilc->io_type & 0x1) == HIF_SPI) {
-		do {
-			wilc->hif_func->hif_read_reg(wilc, 1, &reg);
-			wilc->hif_func->hif_write_reg(wilc, 1, reg | BIT(1));
-			wilc->hif_func->hif_write_reg(wilc, 1, reg & ~BIT(1));
-
-			do {
-				usleep_range(2 * 1000, 2 * 1000);
-				wilc_get_chipid(wilc, true);
-			} while (wilc_get_chipid(wilc, true) == 0);
-		} while (wilc_get_chipid(wilc, true) == 0);
-	} else if ((wilc->io_type & 0x1) == HIF_SDIO)	 {
-		wilc->hif_func->hif_write_reg(wilc, 0xfa, 1);
-		udelay(200);
-		wilc->hif_func->hif_read_reg(wilc, 0xf0, &reg);
-		do {
-			wilc->hif_func->hif_write_reg(wilc, 0xf0,
-						      reg | BIT(0));
-			wilc->hif_func->hif_read_reg(wilc, 0xf1,
-						     &clk_status_reg);
-
-			while ((clk_status_reg & 0x1) == 0) {
-				usleep_range(2 * 1000, 2 * 1000);
-
-				wilc->hif_func->hif_read_reg(wilc, 0xf1,
-							     &clk_status_reg);
-			}
-			if ((clk_status_reg & 0x1) == 0) {
-				wilc->hif_func->hif_write_reg(wilc, 0xf0,
-							      reg & (~BIT(0)));
-			}
-		} while ((clk_status_reg & 0x1) == 0);
-	}
-
-	if (chip_ps_state == CHIP_SLEEPING_MANUAL) {
-		if (wilc_get_chipid(wilc, false) < 0x1002b0) {
-			u32 val32;
-
-			wilc->hif_func->hif_read_reg(wilc, 0x1e1c, &val32);
-			val32 |= BIT(6);
-			wilc->hif_func->hif_write_reg(wilc, 0x1e1c, val32);
-
-			wilc->hif_func->hif_read_reg(wilc, 0x1e9c, &val32);
-			val32 |= BIT(6);
-			wilc->hif_func->hif_write_reg(wilc, 0x1e9c, val32);
-		}
-	}
-	chip_ps_state = CHIP_WAKEDUP;
-}
-EXPORT_SYMBOL_GPL(chip_wakeup);
-
-void wilc_chip_sleep_manually(struct wilc *wilc)
-{
-	if (chip_ps_state != CHIP_WAKEDUP)
-		return;
-	acquire_bus(wilc, ACQUIRE_ONLY);
-
-	chip_allow_sleep(wilc);
-	wilc->hif_func->hif_write_reg(wilc, 0x10a8, 1);
-
-	chip_ps_state = CHIP_SLEEPING_MANUAL;
-	release_bus(wilc, RELEASE_ONLY);
-}
-EXPORT_SYMBOL_GPL(wilc_chip_sleep_manually);
-
-void host_wakeup_notify(struct wilc *wilc)
-{
-	acquire_bus(wilc, ACQUIRE_ONLY);
-	wilc->hif_func->hif_write_reg(wilc, 0x10b0, 1);
-	release_bus(wilc, RELEASE_ONLY);
-}
-EXPORT_SYMBOL_GPL(host_wakeup_notify);
-
-void host_sleep_notify(struct wilc *wilc)
-{
-	acquire_bus(wilc, ACQUIRE_ONLY);
-	wilc->hif_func->hif_write_reg(wilc, 0x10ac, 1);
-	release_bus(wilc, RELEASE_ONLY);
-}
-EXPORT_SYMBOL_GPL(host_sleep_notify);
-
-int wilc_wlan_handle_txq(struct net_device *dev, u32 *txq_count)
-{
-	int i, entries = 0;
-	u32 sum;
-	u32 reg;
-	u8 *txb;
-	u32 offset = 0;
-	int vmm_sz = 0;
-	struct txq_entry_t *tqe;
-	int ret = 0;
-	int counter;
-	int timeout;
-	u32 vmm_table[WILC_VMM_TBL_SIZE];
-	struct wilc_vif *vif;
-	struct wilc *wilc;
-
-	vif = netdev_priv(dev);
-	wilc = vif->wilc;
-
-	txb = wilc->tx_buffer;
-	wilc->txq_exit = 0;
-	do {
-		if (wilc->quit)
-			break;
-
-		mutex_lock(&wilc->txq_add_to_head_cs);
-		wilc_wlan_txq_filter_dup_tcp_ack(dev);
-		tqe = wilc_wlan_txq_get_first(wilc);
-		i = 0;
-		sum = 0;
-		do {
-			if (tqe && (i < (WILC_VMM_TBL_SIZE - 1))) {
-				if (tqe->type == WILC_CFG_PKT)
-					vmm_sz = ETH_CONFIG_PKT_HDR_OFFSET;
-
-				else if (tqe->type == WILC_NET_PKT)
-					vmm_sz = ETH_ETHERNET_HDR_OFFSET;
-
-				else
-					vmm_sz = HOST_HDR_OFFSET;
-
-				vmm_sz += tqe->buffer_size;
-
-				if (vmm_sz & 0x3)
-					vmm_sz = (vmm_sz + 4) & ~0x3;
-
-				if ((sum + vmm_sz) > LINUX_TX_SIZE)
-					break;
-
-				vmm_table[i] = vmm_sz / 4;
-				if (tqe->type == WILC_CFG_PKT)
-					vmm_table[i] |= BIT(10);
-				vmm_table[i] = cpu_to_le32(vmm_table[i]);
-
-				i++;
-				sum += vmm_sz;
-				tqe = wilc_wlan_txq_get_next(wilc, tqe);
-			} else {
-				break;
-			}
-		} while (1);
-
-		if (i == 0)
-			break;
-		vmm_table[i] = 0x0;
-
-		acquire_bus(wilc, ACQUIRE_AND_WAKEUP);
-		counter = 0;
-		do {
-			ret = wilc->hif_func->hif_read_reg(wilc,
-							   WILC_HOST_TX_CTRL,
-							   &reg);
-			if (!ret)
-				break;
-
-			if ((reg & 0x1) == 0)
-				break;
-
-			counter++;
-			if (counter > 200) {
-				counter = 0;
-				ret = wilc->hif_func->hif_write_reg(wilc, WILC_HOST_TX_CTRL, 0);
-				break;
-			}
-		} while (!wilc->quit);
-
-		if (!ret)
-			goto _end_;
-
-		timeout = 200;
-		do {
-			ret = wilc->hif_func->hif_block_tx(wilc, WILC_VMM_TBL_RX_SHADOW_BASE, (u8 *)vmm_table, ((i + 1) * 4));
-			if (!ret)
-				break;
-
-			ret = wilc->hif_func->hif_write_reg(wilc,
-							    WILC_HOST_VMM_CTL,
-							    0x2);
-			if (!ret)
-				break;
-
-			do {
-				ret = wilc->hif_func->hif_read_reg(wilc, WILC_HOST_VMM_CTL, &reg);
-				if (!ret)
-					break;
-				if ((reg >> 2) & 0x1) {
-					entries = ((reg >> 3) & 0x3f);
-					break;
-				}
-				release_bus(wilc, RELEASE_ALLOW_SLEEP);
-			} while (--timeout);
-			if (timeout <= 0) {
-				ret = wilc->hif_func->hif_write_reg(wilc, WILC_HOST_VMM_CTL, 0x0);
-				break;
-			}
-
-			if (!ret)
-				break;
-
-			if (entries == 0) {
-				ret = wilc->hif_func->hif_read_reg(wilc, WILC_HOST_TX_CTRL, &reg);
-				if (!ret)
-					break;
-				reg &= ~BIT(0);
-				ret = wilc->hif_func->hif_write_reg(wilc, WILC_HOST_TX_CTRL, reg);
-				if (!ret)
-					break;
-				break;
-			}
-			break;
-		} while (1);
-
-		if (!ret)
-			goto _end_;
-
-		if (entries == 0) {
-			ret = WILC_TX_ERR_NO_BUF;
-			goto _end_;
-		}
-
-		release_bus(wilc, RELEASE_ALLOW_SLEEP);
-
-		offset = 0;
-		i = 0;
-		do {
-			tqe = wilc_wlan_txq_remove_from_head(dev);
-			if (tqe && (vmm_table[i] != 0)) {
-				u32 header, buffer_offset;
-
-				vmm_table[i] = cpu_to_le32(vmm_table[i]);
-				vmm_sz = (vmm_table[i] & 0x3ff);
-				vmm_sz *= 4;
-				header = (tqe->type << 31) |
-					 (tqe->buffer_size << 15) |
-					 vmm_sz;
-				if (tqe->type == WILC_MGMT_PKT)
-					header |= BIT(30);
-				else
-					header &= ~BIT(30);
-
-				header = cpu_to_le32(header);
-				memcpy(&txb[offset], &header, 4);
-				if (tqe->type == WILC_CFG_PKT) {
-					buffer_offset = ETH_CONFIG_PKT_HDR_OFFSET;
-				} else if (tqe->type == WILC_NET_PKT) {
-					char *bssid = ((struct tx_complete_data *)(tqe->priv))->bssid;
-
-					buffer_offset = ETH_ETHERNET_HDR_OFFSET;
-					memcpy(&txb[offset + 8], bssid, 6);
-				} else {
-					buffer_offset = HOST_HDR_OFFSET;
-				}
-
-				memcpy(&txb[offset + buffer_offset],
-				       tqe->buffer, tqe->buffer_size);
-				offset += vmm_sz;
-				i++;
-				tqe->status = 1;
-				if (tqe->tx_complete_func)
-					tqe->tx_complete_func(tqe->priv,
-							      tqe->status);
-				if (tqe->tcp_pending_ack_idx != NOT_TCP_ACK &&
-				    tqe->tcp_pending_ack_idx < MAX_PENDING_ACKS)
-					pending_acks_info[tqe->tcp_pending_ack_idx].txqe = NULL;
-				kfree(tqe);
-			} else {
-				break;
-			}
-		} while (--entries);
-
-		acquire_bus(wilc, ACQUIRE_AND_WAKEUP);
-
-		ret = wilc->hif_func->hif_clear_int_ext(wilc, ENABLE_TX_VMM);
-		if (!ret)
-			goto _end_;
-
-		ret = wilc->hif_func->hif_block_tx_ext(wilc, 0, txb, offset);
-		if (!ret)
-			goto _end_;
-
-_end_:
-
-		release_bus(wilc, RELEASE_ALLOW_SLEEP);
-		if (ret != 1)
-			break;
-	} while (0);
-	mutex_unlock(&wilc->txq_add_to_head_cs);
-
-	wilc->txq_exit = 1;
-	*txq_count = wilc->txq_entries;
-	return ret;
-}
-
-static void wilc_wlan_handle_rxq(struct wilc *wilc)
-{
-	int offset = 0, size;
-	u8 *buffer;
-	struct rxq_entry_t *rqe;
-
-	wilc->rxq_exit = 0;
-
-	do {
-		if (wilc->quit) {
-			complete(&wilc->cfg_event);
-			break;
-		}
-		rqe = wilc_wlan_rxq_remove(wilc);
-		if (!rqe)
-			break;
-
-		buffer = rqe->buffer;
-		size = rqe->buffer_size;
-		offset = 0;
-
-		do {
-			u32 header;
-			u32 pkt_len, pkt_offset, tp_len;
-			int is_cfg_packet;
-
-			memcpy(&header, &buffer[offset], 4);
-			header = cpu_to_le32(header);
-
-			is_cfg_packet = (header >> 31) & 0x1;
-			pkt_offset = (header >> 22) & 0x1ff;
-			tp_len = (header >> 11) & 0x7ff;
-			pkt_len = header & 0x7ff;
-
-			if (pkt_len == 0 || tp_len == 0)
-				break;
-
-			#define IS_MANAGMEMENT				0x100
-			#define IS_MANAGMEMENT_CALLBACK			0x080
-			#define IS_MGMT_STATUS_SUCCES			0x040
-
-			if (pkt_offset & IS_MANAGMEMENT) {
-				pkt_offset &= ~(IS_MANAGMEMENT |
-						IS_MANAGMEMENT_CALLBACK |
-						IS_MGMT_STATUS_SUCCES);
-
-				WILC_WFI_mgmt_rx(wilc, &buffer[offset + HOST_HDR_OFFSET], pkt_len);
-			} else {
-				if (!is_cfg_packet) {
-					if (pkt_len > 0) {
-						wilc_frmw_to_linux(wilc,
-								   &buffer[offset],
-								   pkt_len,
-								   pkt_offset);
-					}
-				} else {
-					struct wilc_cfg_rsp rsp;
-
-					wilc_wlan_cfg_indicate_rx(wilc, &buffer[pkt_offset + offset], pkt_len, &rsp);
-					if (rsp.type == WILC_CFG_RSP) {
-						if (wilc->cfg_seq_no == rsp.seq_no)
-							complete(&wilc->cfg_event);
-					} else if (rsp.type == WILC_CFG_RSP_STATUS) {
-						wilc_mac_indicate(wilc, WILC_MAC_INDICATE_STATUS);
-
-					} else if (rsp.type == WILC_CFG_RSP_SCAN) {
-						wilc_mac_indicate(wilc, WILC_MAC_INDICATE_SCAN);
-					}
-				}
-			}
-			offset += tp_len;
-			if (offset >= size)
-				break;
-		} while (1);
-		kfree(rqe);
-	} while (1);
-
-	wilc->rxq_exit = 1;
-}
-
-static void wilc_unknown_isr_ext(struct wilc *wilc)
-{
-	wilc->hif_func->hif_clear_int_ext(wilc, 0);
-}
-
-static void wilc_pllupdate_isr_ext(struct wilc *wilc, u32 int_stats)
-{
-	int trials = 10;
-
-	wilc->hif_func->hif_clear_int_ext(wilc, PLL_INT_CLR);
-
-	if (wilc->io_type == HIF_SDIO)
-		mdelay(WILC_PLL_TO_SDIO);
-	else
-		mdelay(WILC_PLL_TO_SPI);
-
-	while (!(ISWILC1000(wilc_get_chipid(wilc, true)) && --trials))
-		mdelay(1);
-}
-
-static void wilc_sleeptimer_isr_ext(struct wilc *wilc, u32 int_stats1)
-{
-	wilc->hif_func->hif_clear_int_ext(wilc, SLEEP_INT_CLR);
-}
-
-static void wilc_wlan_handle_isr_ext(struct wilc *wilc, u32 int_status)
-{
-	u32 offset = wilc->rx_buffer_offset;
-	u8 *buffer = NULL;
-	u32 size;
-	u32 retries = 0;
-	int ret = 0;
-	struct rxq_entry_t *rqe;
-
-	size = (int_status & 0x7fff) << 2;
-
-	while (!size && retries < 10) {
-		wilc->hif_func->hif_read_size(wilc, &size);
-		size = (size & 0x7fff) << 2;
-		retries++;
-	}
-
-	if (size > 0) {
-		if (LINUX_RX_SIZE - offset < size)
-			offset = 0;
-
-		if (wilc->rx_buffer)
-			buffer = &wilc->rx_buffer[offset];
-		else
-			goto _end_;
-
-		wilc->hif_func->hif_clear_int_ext(wilc,
-					      DATA_INT_CLR | ENABLE_RX_VMM);
-		ret = wilc->hif_func->hif_block_rx_ext(wilc, 0, buffer, size);
-
-_end_:
-		if (ret) {
-			offset += size;
-			wilc->rx_buffer_offset = offset;
-			rqe = kmalloc(sizeof(*rqe), GFP_KERNEL);
-			if (rqe) {
-				rqe->buffer = buffer;
-				rqe->buffer_size = size;
-				wilc_wlan_rxq_add(wilc, rqe);
-			}
-		}
-	}
-	wilc_wlan_handle_rxq(wilc);
-}
-
-void wilc_handle_isr(struct wilc *wilc)
-{
-	u32 int_status;
-
-	acquire_bus(wilc, ACQUIRE_AND_WAKEUP);
-	wilc->hif_func->hif_read_int(wilc, &int_status);
-
-	if (int_status & PLL_INT_EXT)
-		wilc_pllupdate_isr_ext(wilc, int_status);
-
-	if (int_status & DATA_INT_EXT)
-		wilc_wlan_handle_isr_ext(wilc, int_status);
-
-	if (int_status & SLEEP_INT_EXT)
-		wilc_sleeptimer_isr_ext(wilc, int_status);
-
-	if (!(int_status & (ALL_INT_EXT)))
-		wilc_unknown_isr_ext(wilc);
-
-	release_bus(wilc, RELEASE_ALLOW_SLEEP);
-}
-EXPORT_SYMBOL_GPL(wilc_handle_isr);
-
-int wilc_wlan_firmware_download(struct wilc *wilc, const u8 *buffer,
-				u32 buffer_size)
-{
-	u32 offset;
-	u32 addr, size, size2, blksz;
-	u8 *dma_buffer;
-	int ret = 0;
-
-	blksz = BIT(12);
-
-	dma_buffer = kmalloc(blksz, GFP_KERNEL);
-	if (!dma_buffer)
-		return -EIO;
-
-	offset = 0;
-	do {
-		memcpy(&addr, &buffer[offset], 4);
-		memcpy(&size, &buffer[offset + 4], 4);
-		addr = cpu_to_le32(addr);
-		size = cpu_to_le32(size);
-		acquire_bus(wilc, ACQUIRE_ONLY);
-		offset += 8;
-		while (((int)size) && (offset < buffer_size)) {
-			if (size <= blksz)
-				size2 = size;
-			else
-				size2 = blksz;
-
-			memcpy(dma_buffer, &buffer[offset], size2);
-			ret = wilc->hif_func->hif_block_tx(wilc, addr,
-							   dma_buffer, size2);
-			if (!ret)
-				break;
-
-			addr += size2;
-			offset += size2;
-			size -= size2;
-		}
-		release_bus(wilc, RELEASE_ONLY);
-
-		if (!ret) {
-			ret = -EIO;
-			goto _fail_;
-		}
-	} while (offset < buffer_size);
-
-_fail_:
-
-	kfree(dma_buffer);
-
-	return (ret < 0) ? ret : 0;
-}
-
-int wilc_wlan_start(struct wilc *wilc)
-{
-	u32 reg = 0;
-	int ret;
-	u32 chipid;
-
-	if (wilc->io_type == HIF_SDIO) {
-		reg = 0;
-		reg |= BIT(3);
-	} else if (wilc->io_type == HIF_SPI) {
-		reg = 1;
-	}
-	acquire_bus(wilc, ACQUIRE_ONLY);
-	ret = wilc->hif_func->hif_write_reg(wilc, WILC_VMM_CORE_CFG, reg);
-	if (!ret) {
-		release_bus(wilc, RELEASE_ONLY);
-		return -EIO;
-	}
-	reg = 0;
-	if (wilc->io_type == HIF_SDIO && wilc->dev_irq_num)
-		reg |= WILC_HAVE_SDIO_IRQ_GPIO;
-
-#ifdef WILC_DISABLE_PMU
-#else
-	reg |= WILC_HAVE_USE_PMU;
-#endif
-
-#ifdef WILC_SLEEP_CLK_SRC_XO
-	reg |= WILC_HAVE_SLEEP_CLK_SRC_XO;
-#elif defined WILC_SLEEP_CLK_SRC_RTC
-	reg |= WILC_HAVE_SLEEP_CLK_SRC_RTC;
-#endif
-
-#ifdef WILC_EXT_PA_INV_TX_RX
-	reg |= WILC_HAVE_EXT_PA_INV_TX_RX;
-#endif
-	reg |= WILC_HAVE_USE_IRQ_AS_HOST_WAKE;
-	reg |= WILC_HAVE_LEGACY_RF_SETTINGS;
-#ifdef XTAL_24
-	reg |= WILC_HAVE_XTAL_24;
-#endif
-#ifdef DISABLE_WILC_UART
-	reg |= WILC_HAVE_DISABLE_WILC_UART;
-#endif
-
-	ret = wilc->hif_func->hif_write_reg(wilc, WILC_GP_REG_1, reg);
-	if (!ret) {
-		release_bus(wilc, RELEASE_ONLY);
-		return -EIO;
-	}
-
-	wilc->hif_func->hif_sync_ext(wilc, NUM_INT_EXT);
-
-	ret = wilc->hif_func->hif_read_reg(wilc, 0x1000, &chipid);
-	if (!ret) {
-		release_bus(wilc, RELEASE_ONLY);
-		return -EIO;
-	}
-
-	wilc->hif_func->hif_read_reg(wilc, WILC_GLB_RESET_0, &reg);
-	if ((reg & BIT(10)) == BIT(10)) {
-		reg &= ~BIT(10);
-		wilc->hif_func->hif_write_reg(wilc, WILC_GLB_RESET_0, reg);
-		wilc->hif_func->hif_read_reg(wilc, WILC_GLB_RESET_0, &reg);
-	}
-
-	reg |= BIT(10);
-	ret = wilc->hif_func->hif_write_reg(wilc, WILC_GLB_RESET_0, reg);
-	wilc->hif_func->hif_read_reg(wilc, WILC_GLB_RESET_0, &reg);
-	release_bus(wilc, RELEASE_ONLY);
-
-	return (ret < 0) ? ret : 0;
-}
-
-int wilc_wlan_stop(struct wilc *wilc)
-{
-	u32 reg = 0;
-	int ret;
-	u8 timeout = 10;
-
-	acquire_bus(wilc, ACQUIRE_AND_WAKEUP);
-
-	ret = wilc->hif_func->hif_read_reg(wilc, WILC_GLB_RESET_0, &reg);
-	if (!ret) {
-		release_bus(wilc, RELEASE_ALLOW_SLEEP);
-		return ret;
-	}
-
-	reg &= ~BIT(10);
-	ret = wilc->hif_func->hif_write_reg(wilc, WILC_GLB_RESET_0, reg);
-	if (!ret) {
-		release_bus(wilc, RELEASE_ALLOW_SLEEP);
-		return ret;
-	}
-
-	do {
-		ret = wilc->hif_func->hif_read_reg(wilc,
-						   WILC_GLB_RESET_0, &reg);
-		if (!ret) {
-			release_bus(wilc, RELEASE_ALLOW_SLEEP);
-			return ret;
-		}
-
-		if ((reg & BIT(10))) {
-			reg &= ~BIT(10);
-			ret = wilc->hif_func->hif_write_reg(wilc,
-							    WILC_GLB_RESET_0,
-							    reg);
-			timeout--;
-		} else {
-			ret = wilc->hif_func->hif_read_reg(wilc,
-							   WILC_GLB_RESET_0,
-							   &reg);
-			if (!ret) {
-				release_bus(wilc, RELEASE_ALLOW_SLEEP);
-				return ret;
-			}
-			break;
-		}
-
-	} while (timeout);
-	reg = (BIT(0) | BIT(1) | BIT(2) | BIT(3) | BIT(8) | BIT(9) | BIT(26) |
-	       BIT(29) | BIT(30) | BIT(31));
-
-	wilc->hif_func->hif_write_reg(wilc, WILC_GLB_RESET_0, reg);
-	reg = (u32)~BIT(10);
-
-	ret = wilc->hif_func->hif_write_reg(wilc, WILC_GLB_RESET_0, reg);
-
-	release_bus(wilc, RELEASE_ALLOW_SLEEP);
-
-	return ret;
-}
-
-void wilc_wlan_cleanup(struct net_device *dev)
-{
-	struct txq_entry_t *tqe;
-	struct rxq_entry_t *rqe;
-	u32 reg = 0;
-	int ret;
-	struct wilc_vif *vif;
-	struct wilc *wilc;
-
-	vif = netdev_priv(dev);
-	wilc = vif->wilc;
-
-	wilc->quit = 1;
-	do {
-		tqe = wilc_wlan_txq_remove_from_head(dev);
-		if (!tqe)
-			break;
-		if (tqe->tx_complete_func)
-			tqe->tx_complete_func(tqe->priv, 0);
-		kfree(tqe);
-	} while (1);
-
-	do {
-		rqe = wilc_wlan_rxq_remove(wilc);
-		if (!rqe)
-			break;
-		kfree(rqe);
-	} while (1);
-
-	kfree(wilc->rx_buffer);
-	wilc->rx_buffer = NULL;
-	kfree(wilc->tx_buffer);
-	wilc->tx_buffer = NULL;
-
-	acquire_bus(wilc, ACQUIRE_AND_WAKEUP);
-
-	ret = wilc->hif_func->hif_read_reg(wilc, WILC_GP_REG_0, &reg);
-	if (!ret)
-		release_bus(wilc, RELEASE_ALLOW_SLEEP);
-
-	ret = wilc->hif_func->hif_write_reg(wilc, WILC_GP_REG_0,
-					(reg | ABORT_INT));
-	if (!ret)
-		release_bus(wilc, RELEASE_ALLOW_SLEEP);
-
-	release_bus(wilc, RELEASE_ALLOW_SLEEP);
-	wilc->hif_func->hif_deinit(NULL);
-}
-
-static int wilc_wlan_cfg_commit(struct wilc_vif *vif, int type,
-				u32 drv_handler)
-{
-	struct wilc *wilc = vif->wilc;
-	struct wilc_cfg_frame *cfg = &wilc->cfg_frame;
-	int total_len = wilc->cfg_frame_offset + 4 + DRIVER_HANDLER_SIZE;
-	int seq_no = wilc->cfg_seq_no % 256;
-	int driver_handler = (u32)drv_handler;
-
-	if (type == WILC_CFG_SET)
-		cfg->wid_header[0] = 'W';
-	else
-		cfg->wid_header[0] = 'Q';
-	cfg->wid_header[1] = seq_no;
-	cfg->wid_header[2] = (u8)total_len;
-	cfg->wid_header[3] = (u8)(total_len >> 8);
-	cfg->wid_header[4] = (u8)driver_handler;
-	cfg->wid_header[5] = (u8)(driver_handler >> 8);
-	cfg->wid_header[6] = (u8)(driver_handler >> 16);
-	cfg->wid_header[7] = (u8)(driver_handler >> 24);
-	wilc->cfg_seq_no = seq_no;
-
-	if (!wilc_wlan_txq_add_cfg_pkt(vif, &cfg->wid_header[0], total_len))
-		return -1;
-
-	return 0;
-}
-
-int wilc_wlan_cfg_set(struct wilc_vif *vif, int start, u16 wid, u8 *buffer,
-		      u32 buffer_size, int commit, u32 drv_handler)
-{
-	u32 offset;
-	int ret_size;
-	struct wilc *wilc = vif->wilc;
-
-	if (wilc->cfg_frame_in_use)
-		return 0;
-
-	if (start)
-		wilc->cfg_frame_offset = 0;
-
-	offset = wilc->cfg_frame_offset;
-	ret_size = wilc_wlan_cfg_set_wid(wilc->cfg_frame.frame, offset,
-					 wid, buffer, buffer_size);
-	offset += ret_size;
-	wilc->cfg_frame_offset = offset;
-
-	if (commit) {
-		netdev_dbg(vif->ndev,
-			   "[WILC]PACKET Commit with sequence number %d\n",
-			   wilc->cfg_seq_no);
-		netdev_dbg(vif->ndev, "Processing cfg_set()\n");
-		wilc->cfg_frame_in_use = 1;
-
-		if (wilc_wlan_cfg_commit(vif, WILC_CFG_SET, drv_handler))
-			ret_size = 0;
-
-		if (!wait_for_completion_timeout(&wilc->cfg_event,
-						 msecs_to_jiffies(CFG_PKTS_TIMEOUT))) {
-			netdev_dbg(vif->ndev, "Set Timed Out\n");
-			ret_size = 0;
-		}
-
-		wilc->cfg_frame_in_use = 0;
-		wilc->cfg_frame_offset = 0;
-		wilc->cfg_seq_no += 1;
-	}
-
-	return ret_size;
-}
-
-int wilc_wlan_cfg_get(struct wilc_vif *vif, int start, u16 wid, int commit,
-		      u32 drv_handler)
-{
-	u32 offset;
-	int ret_size;
-	struct wilc *wilc = vif->wilc;
-
-	if (wilc->cfg_frame_in_use)
-		return 0;
-
-	if (start)
-		wilc->cfg_frame_offset = 0;
-
-	offset = wilc->cfg_frame_offset;
-	ret_size = wilc_wlan_cfg_get_wid(wilc->cfg_frame.frame, offset, wid);
-	offset += ret_size;
-	wilc->cfg_frame_offset = offset;
-
-	if (commit) {
-		wilc->cfg_frame_in_use = 1;
-
-		if (wilc_wlan_cfg_commit(vif, WILC_CFG_QUERY, drv_handler))
-			ret_size = 0;
-
-		if (!wait_for_completion_timeout(&wilc->cfg_event,
-					msecs_to_jiffies(CFG_PKTS_TIMEOUT))) {
-			netdev_dbg(vif->ndev, "Get Timed Out\n");
-			ret_size = 0;
-		}
-		wilc->cfg_frame_in_use = 0;
-		wilc->cfg_frame_offset = 0;
-		wilc->cfg_seq_no += 1;
-	}
-
-	return ret_size;
-}
-
-int wilc_wlan_cfg_get_val(u16 wid, u8 *buffer, u32 buffer_size)
-{
-	return wilc_wlan_cfg_get_wid_value(wid, buffer, buffer_size);
-}
-
-int wilc_send_config_pkt(struct wilc_vif *vif, u8 mode, struct wid *wids,
-			 u32 count, u32 drv)
-{
-	int i;
-	int ret = 0;
-
-	if (mode == GET_CFG) {
-		for (i = 0; i < count; i++) {
-			if (!wilc_wlan_cfg_get(vif, !i,
-					       wids[i].id,
-					       (i == count - 1),
-					       drv)) {
-				ret = -ETIMEDOUT;
-				break;
-			}
-		}
-		for (i = 0; i < count; i++) {
-			wids[i].size = wilc_wlan_cfg_get_val(wids[i].id,
-							     wids[i].val,
-							     wids[i].size);
-		}
-	} else if (mode == SET_CFG) {
-		for (i = 0; i < count; i++) {
-			if (!wilc_wlan_cfg_set(vif, !i,
-					       wids[i].id,
-					       wids[i].val,
-					       wids[i].size,
-					       (i == count - 1),
-					       drv)) {
-				ret = -ETIMEDOUT;
-				break;
-			}
-		}
-	}
-
-	return ret;
-}
-
-static u32 init_chip(struct net_device *dev)
-{
-	u32 chipid;
-	u32 reg, ret = 0;
-	struct wilc_vif *vif;
-	struct wilc *wilc;
-
-	vif = netdev_priv(dev);
-	wilc = vif->wilc;
-
-	acquire_bus(wilc, ACQUIRE_ONLY);
-
-	chipid = wilc_get_chipid(wilc, true);
-
-	if ((chipid & 0xfff) != 0xa0) {
-		ret = wilc->hif_func->hif_read_reg(wilc, 0x1118, &reg);
-		if (!ret) {
-			netdev_err(dev, "fail read reg 0x1118\n");
-			return ret;
-		}
-		reg |= BIT(0);
-		ret = wilc->hif_func->hif_write_reg(wilc, 0x1118, reg);
-		if (!ret) {
-			netdev_err(dev, "fail write reg 0x1118\n");
-			return ret;
-		}
-		ret = wilc->hif_func->hif_write_reg(wilc, 0xc0000, 0x71);
-		if (!ret) {
-			netdev_err(dev, "fail write reg 0xc0000\n");
-			return ret;
-		}
-	}
-
-	release_bus(wilc, RELEASE_ONLY);
-
-	return ret;
-}
-
-u32 wilc_get_chipid(struct wilc *wilc, bool update)
-{
-	static u32 chipid;
-	u32 tempchipid = 0;
-	u32 rfrevid = 0;
-
-	if (chipid == 0 || update) {
-		wilc->hif_func->hif_read_reg(wilc, 0x1000, &tempchipid);
-		wilc->hif_func->hif_read_reg(wilc, 0x13f4, &rfrevid);
-		if (!ISWILC1000(tempchipid)) {
-			chipid = 0;
-			return chipid;
-		}
-		if (tempchipid == 0x1002a0) {
-			if (rfrevid != 0x1)
-				tempchipid = 0x1002a1;
-		} else if (tempchipid == 0x1002b0) {
-			if (rfrevid == 0x4)
-				tempchipid = 0x1002b1;
-			else if (rfrevid != 0x3)
-				tempchipid = 0x1002b2;
-		}
-
-		chipid = tempchipid;
-	}
-	return chipid;
-}
-
-int wilc_wlan_init(struct net_device *dev)
-{
-	int ret = 0;
-	struct wilc_vif *vif = netdev_priv(dev);
-	struct wilc *wilc;
-
-	wilc = vif->wilc;
-
-	wilc->quit = 0;
-
-	if (!wilc->hif_func->hif_init(wilc, false)) {
-		ret = -EIO;
-		goto _fail_;
-	}
-
-	if (!wilc_wlan_cfg_init()) {
-		ret = -ENOBUFS;
-		goto _fail_;
-	}
-
-	if (!wilc->tx_buffer)
-		wilc->tx_buffer = kmalloc(LINUX_TX_SIZE, GFP_KERNEL);
-
-	if (!wilc->tx_buffer) {
-		ret = -ENOBUFS;
-		goto _fail_;
-	}
-
-	if (!wilc->rx_buffer)
-		wilc->rx_buffer = kmalloc(LINUX_RX_SIZE, GFP_KERNEL);
-
-	if (!wilc->rx_buffer) {
-		ret = -ENOBUFS;
-		goto _fail_;
-	}
-
-	if (!init_chip(dev)) {
-		ret = -EIO;
-		goto _fail_;
-	}
-
-	return 1;
-
-_fail_:
-
-	kfree(wilc->rx_buffer);
-	wilc->rx_buffer = NULL;
-	kfree(wilc->tx_buffer);
-	wilc->tx_buffer = NULL;
-
-	return ret;
-}
-- 
2.7.4

